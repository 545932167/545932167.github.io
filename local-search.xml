<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>redis-持久化</title>
    <link href="/2022/10/17/redis-%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2022/10/17/redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><blockquote><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中，所以执行快照是一个比较重的操作</p></blockquote><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><p>(1)save：阻塞当前Redis服务器，直到RDB过程完成为止 (不推荐)</p><p>(2)bgsave: Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责 （推荐）</p><blockquote><p>bgsave是主流的触发RDB持久化方式</p></blockquote><h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220418150641199.png" alt="image-20220418150641199"></p><ol><li>执行bgsave命令，如果有存在正在执行的子进程，这直接返回</li><li>执行fork操作创建子进程，fork完成后父进程<strong>可以继续响应其他命令</strong></li><li>子进程根据父进程内存生成临时快照文件，完成后替换原有RDB文件，通知父进程完成</li></ol><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><blockquote><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性</p></blockquote><ul><li>AOF 文件的内容是操作命令；</li><li>RDB 文件的内容是二进制数据。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220418151715491.png" alt="image-20220418151715491"></p><p>1）所有的写人命令会追加到aof_buf（缓冲区）中。<br> 2）AOF 缓冲区根据对应的策略向硬盘做同步操作。<br> 3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。<br> 4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</p><h3 id="文件同步策略"><a href="#文件同步策略" class="headerlink" title="文件同步策略"></a>文件同步策略</h3><blockquote><p>Redis提供了多种AOF 缓冲区同步文件策略，由参数appendfsync控制</p></blockquote><ol><li><p>always</p><p>命令写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回</p></li><li><p>everysec</p><p>命令写人aof_buf后调用系统write操作，write完成操作后线程返回。fsync同步文件操作由专门线程每秒调用一次</p></li><li><p>no</p><p>命令写人aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒</p></li></ol><h4 id="系统调用write和fsync"><a href="#系统调用write和fsync" class="headerlink" title="系统调用write和fsync"></a>系统调用write和fsync</h4><p>调用wirte的时候，会将aof缓存区的文件先放入到内核缓存区中，然后再由fsync放入到硬盘中，所以调用wirte的本质还是调用fsync</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220418152439209.png" alt="image-20220418152439209"></p><p>由此我们可知三种同步策略只是在控制fsync()函数的调用时机不同而已。</p><ul><li>Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；</li><li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数；</li><li>No 策略就是永不执行 fsync() 函数;</li></ul><h3 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h3><blockquote><p>AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程</p></blockquote><h4 id="重写的aof文件为什么变小？"><a href="#重写的aof文件为什么变小？" class="headerlink" title="重写的aof文件为什么变小？"></a>重写的aof文件为什么变小？</h4><ol><li>进程内已经超时的数据不再写人文件。</li><li>旧的AOF文件含有无效命令，比如del key1，重写使用进程内数据直接生成，只保留最终数据的写入命令</li><li>多条写命令可以合并为一个</li></ol><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220418153222820.png" alt="image-20220418153222820"></p><ol><li>执行AOF重写请求。<br> 如果当前进程正在执行AOF重写，请求不执行</li><li>父进程执行fork创建子进程来执行重写操作，fork完成后可以继续响应其他命令</li><li>由于fork操作运用<strong>写时复制技术</strong>，子进程只能共享fork操作时的内存数据。由于父进程依然响应命令，Redis使用“<strong>AOF重写缓冲区</strong>”保存这部分新数据，防止新AOF文件生成期间丢失这部分数据。</li><li>重写完成后，子进程发送信号给父进程，父进程把<strong>AOF重写缓存区</strong>写入到新的AOF文件中</li><li>将新AOF文件替换老文件</li></ol><h2 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h2><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220418160735605.png" alt="image-20220418160735605"></p><ol><li>AOF持久化开启且存在AOF文件时，优先加载AOF文件</li><li>AOF关闭或者AOF文件不存在时，加载RDB文件</li><li>加载AOF&#x2F;RDB文件成功后，Redis启动成功</li><li>AOF&#x2F;RDB文件存在错误时，Redis启动失败并打印错误信息</li></ol><h2 id="写时复制技术"><a href="#写时复制技术" class="headerlink" title="写时复制技术"></a>写时复制技术</h2><p>在RDB的bgsave中跟AOF的重写中都用到了写时复制技术，它可以使得子进程在操作的过程中，当父进程需要修改数据时，不会互相影响。通过 <code>fork()</code> 创建子进程后，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220418161128316.png" alt="image-20220418161128316"></p><p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p><p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>缺页中断</strong>，这个缺页中断是由于违反权限导致的，然后操作系统会在「缺页异常处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为「*<em>写时复制 (*</em>*<em>*Copy On Write**</em>**)**」。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220418161115854.png" alt="image-20220418161115854"></p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-内部数据类型</title>
    <link href="/2022/10/17/Redis-%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/10/17/Redis-%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>提供给用户的数据类型 有String，List，Hash，Set，ZSet</p><p>Redis内部数据结构有：SDS(简单动态字符串),链表，字典，跳跃表，整数集合，压缩列表</p><h3 id="Redis数据类型与内部数据结构的关系"><a href="#Redis数据类型与内部数据结构的关系" class="headerlink" title="Redis数据类型与内部数据结构的关系"></a>Redis数据类型与内部数据结构的关系</h3><p>Redis没有直接使用基础数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这些对象是供用户直接使用的。Redis数据库中的每个键值对的键和值都是一个对象，五种类型的对象至少都支持两种或者两种以上的基础数据结构，不同的数据结构可以在不同的使用场景上优化对象的使用效率。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/92cca2e0544c4ce3b9218885c6846a13.png" alt="img"></p><p>String是唯一一个会被其它四种对象嵌套使用的对象。List、Hash、Set、ZSet之所以会虚线指向SDS也是嵌套使用String的原因。</p><h2 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Redis没有直接使用C语言字符串，而是自己创建了一个名为简单动态字符串（Simple Dynamic String）的抽象类型来表示字符串。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424124704964.png" alt="image-20220424124704964"></p><h3 id="SDS比C字符串更适合用于Redis的原因"><a href="#SDS比C字符串更适合用于Redis的原因" class="headerlink" title="SDS比C字符串更适合用于Redis的原因"></a>SDS比C字符串更适合用于Redis的原因</h3><ol><li><p>常数复杂度获取字符串长度</p><p>只要访问SDS的len属性就可以立即知道SDS的长度</p></li><li><p>杜绝缓冲区溢出</p><p>当SDS  API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。</p></li><li><p>减少修改字符串时带来的内存重分配次数</p><p>SDS通过未使用空间解除了字符申长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录</p><blockquote><p>通过未使用空间， SDS实现了空间预分配和惰性空间释放两种优化策略</p></blockquote></li><li><p>二进制安全</p></li></ol><p>C字符串的字符<strong>必须符合某种编码</strong>，并且中间<strong>不能</strong>有空字符，否则读取时会被误以为是字符串结尾。种种局限使得C字符串只能存文本，不能存图片，音频，视频，压缩文件等二进制数据。 为确保<strong>Redis对不同使用场景的支持</strong>，SDS API都是二进制安全的，也就是所有SDS API都会以<strong>二进制的方式</strong>存取buf中的数据，数据的写入和读出都是一个样的。由于SDS读取时并不是依靠空字符来判断结束的，而是<strong>len属性</strong>，所以是二进制安全的。</p><ol><li><p>兼容部分C字符串函数</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424125955066.png" alt="image-20220424125955066"></p></li></ol><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a><strong>空间预分配</strong></h4><p>空间预分配用于优化SDS字符串<strong>增长操作</strong>。在扩展SDS空间前，SDS API会先检查未使用空间够不够，如果不够，则进行空间预分配。此时，程序不仅会为SDS分配修改所必须要的空间，还为其分配额外未使用的空间。</p><ul><li>修改后的SDS&lt;1MB，程序分配和len属性<strong>同样大小</strong>的未使用空间，此时SDS的len与free大小相等。</li><li>修改后SDS&gt;&#x3D;1MB。程序会分配<strong>1MB</strong>的未使用空间。</li></ul><blockquote><p>通过空间的预分配，将<strong>连续增长N次字符串需要的内存分配次数</strong>从一定需要N次变为<strong>最多N次</strong>。因而可以减少连续执行字符串增长操作所需的内存重分配的次数。</p></blockquote><h4 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a><strong>惰性空间释放</strong></h4><p>惰性空间的释放用于优化SDS字符串<strong>缩短操作</strong>。当SDS API需要缩短保存的字符串时，程序并不立即回收这部分内存，而是使用free属性将字节的数量记录，等待使用。与此同时，SDS提供了相关API，在有需要时，<strong>真正释放</strong>未使用空间，不需要担心惰性空间造成的内存浪费</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs none">typedef struct listNode&#123;<br>    //前置节点<br>    struct listNode *prev;<br>    //后置节点<br>    struct listNode *next;<br>    //节点的值<br>    void *value;<br>&#125;listNode;<br></code></pre></td></tr></table></figure><p>节点由前驱后继组成，多个节点组成的链表为双端链表。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424130518054.png" alt="image-20220424130518054"></p><p>使用<code>adlist.h/list</code>来持有，操作链表：</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424130556005.png" alt="image-20220424130556005"></p><p>Redis链表特性可以总结如下：</p><p><strong>双端</strong>：链表节点带有prev和next指针，获取前置和后置节点的复杂度都是O(1)。<br> <strong>无环</strong>：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。 带表头指针和表尾指针 带链表长度计数器 。<br> <strong>头尾指针</strong>：将程序获取头尾节点的复杂度降为O(1)。<br> <strong>长度计数器</strong>：将程序获取表长的复杂度降为O(1)。<br> <strong>多态</strong>：链表节点使用void*指针来保存节点值，并且可以通过list结构的<code>dup、free、match</code>为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>Redis的字典使用<strong>哈希表</strong>作为底层实现，一个哈希表里面可以有<strong>多个哈希表节点</strong>，每个哈希表节点保存了字典中的<strong>一个键值对</strong>。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><strong>哈希表</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs none">typedef struct dictht&#123;<br>    //哈希表数组<br>    dictEntry **table;<br>    //哈希表大小<br>    unsigned long size;<br>    //哈希表大小掩码，用于计算索引值<br>    //总是等于size-1<br>    unsigned long sizemask;<br>    //该哈希表已有节点的数量<br>    unsigned long used;<br>&#125;dictht;<br></code></pre></td></tr></table></figure><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424130652493.png" alt="image-20220424130652493"></p><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a><strong>哈希表节点</strong></h3><p>哈希表节点使用dictEntry实现，每个dictEntry都存储着一个键值对：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs none">typedef struct dictEntry&#123;<br>    //键<br>    void *key;<br>    //值<br>    union&#123;<br>        void *val;<br>        uint64_t u64;<br>        int64_t s64;<br>    &#125; v;<br>    //指向下个哈希表节点，形成链表<br>    struct dictEntry *next;<br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424130721344.png" alt="image-20220424130721344"></p><p>键值对的值可以是一个指针，或一个<code>uint64_t</code>整数，或一个<code>int64_t</code>整数。next是<strong>指向另一个哈希节点的指针</strong>，可将多个<strong>哈希值相同的键值对连接在一起</strong>，以此来解决冲突。</p><h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h3><p>Redis中的字典由dict.h&#x2F;dict结构表示 ，由这个数据结构将<strong>哈希表</strong>组织在一起</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs none">typedef struct dict&#123;<br>    //类型特定函数<br>    dictType *type;<br>    //私有数据<br>    void *privdata;<br>    //哈希表<br>    dictht ht[2];<br>    //rehash索引<br>    //当rehash不在进行时，值为-1<br>    int rehashidx;<br>&#125; dict;<br></code></pre></td></tr></table></figure><ul><li>type属性是一个指向dictType的结构指针，每个dictType结构保存了一簇用于<strong>操作特定类型键值对的函数</strong>，Redis为用途不同的字典设置不同类型特定函数。</li><li>privdata属性保存了需要传给那些类型特定函数的可选参数。</li><li>ht属性是包含<strong>两个项</strong>的数组，每项都是一个哈希表，ht[0]平时使用，而ht[1]仅在rehash时使用。</li><li>rehashidx记录了rehash的进度，初始为-1。</li></ul><p>普通状态下，没有进行rehash的字典：</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424130920284.png" alt="image-20220424130920284"></p><h3 id="如何解决Hash冲突？-与Java的HashMap有哪些异同点？"><a href="#如何解决Hash冲突？-与Java的HashMap有哪些异同点？" class="headerlink" title="如何解决Hash冲突？ 与Java的HashMap有哪些异同点？"></a>如何解决Hash冲突？ 与Java的HashMap有哪些异同点？</h3><p>Redis采用链地址法来解决冲突（解决冲突的方法基本上有链地址法，开放定址法，再哈希法等），与Java的HashMap的异同点：绿色为相同点，橙色为不同点。</p><p>为什么Redis字典没有使用红黑树来提高查询效率？</p><ol><li>Redis负载因子是使用了 已经存在的节点数量&#x2F;数组长度，基本上链表节点个数不会超过数组的长度。Java HashMap负载因子是使用的数组中已有节点数量&#x2F;数组长度。</li><li>Redis的链表结构已经做了优化，红黑树插入新节点时要进行颜色切换，树扭转，更消耗空间。</li></ol><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行响应的扩容或缩容</p><p>(1)为字典ht[1]哈希表<strong>分配空间</strong>，大小取决于要执行的操作与ht[0]<strong>当前键值对的数量</strong></p><ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used * 2 的2^n (2的n次方幂)</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n</li></ul><p>(2)将保存在ht[0]中的所有键值对存放到ht[1]指定的位置</p><p>(3)当ht[0]的所有键值对都迁移完毕后，<strong>释放ht[0]<strong>，并</strong>指向</strong>ht[1]，并在ht[1]上创建一个空的哈希表，为下次rehash准备。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424131207748.png" alt="image-20220424131207748"></p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>ehash时会将ht[0]中所有的键值对rehash到ht[1]，如果键值对很多并且一次性操作的话，容易导致服务器<strong>在一段时间内停止服务</strong>。为避免这种情况，Redis采用渐进式rehash，将ht[0]中的键值对分多次，<strong>慢慢的rehash</strong>到ht[1]之中。</p><p>因为在进行渐进式rehash的过程中，<strong>字典会同时使用ht[0] , ht[1]两个哈希表</strong>，所以在<strong>渐进式rehash期间</strong>，字典的<strong>删除(delete)、查找(find)、更新(update)等操作会在两个哈希表上进行</strong>。例如，要在字典里面查找一个键的话，程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht[1]里面进行查找，诸如此类。</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>跳跃表（skiplist）是一种<strong>有序</strong>的数据结构，通过在每个节点<strong>维持多个指向其他节点的指针</strong>，达到快速访问节点的目的。</p><p>Redis的跳跃表由<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code>两个数据结构定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs none">typedef struct zskiplist&#123;<br>    //表头节点和表尾节点<br>    structz zskiplistNode *header,* tail;<br>    //表中节点的数量<br>    unsigned long length;<br>    //表中层数最大的节点的层数<br>    int level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p>跳跃表由zskiplist组织，通过多个跳跃表节点zskiplistNode组成一个跳跃表。值得注意的是，记录level时，表头结点的层高不会记录在内。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424131406786.png" alt="image-20220424131406786"></p><p><strong>跳跃表节点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs none">typedef strct zskiplistNode&#123;<br>    //后退指针<br>    struct zskiplistNode *backward;<br>    //分值<br>    double score;<br>    //成员对象<br>    robj *obj;<br>    //层<br>    struct zskiplistlevel&#123;<br>        //前进指针<br>        struct zskiplistNode *forward;<br>        //跨度<br>        unsigned int span;<br>    &#125;level[];<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><ol><li><p>层 - level</p><p>跳跃表的每个节点都会包含多个层，每次创建一个新跳跃表时，都会根据幂次定律，随机生成一个1~32之间的数作为层的大小。每个层都会包含前进指针和跨度。</p></li><li><p>前进指针（forword）</p><p>用于访问下一个节点。跨度表示<strong>两个节点之间的距离</strong>，指向NULL的所有前进指针的<strong>跨度为0</strong>。跨度用于计算排位，访问某一结点的经过的<strong>跨度之和</strong>就是当前节点的排位</p></li><li><p>后退指针–backward</p><p>用于从表尾向表头方向访问节点，<strong>前进指针可以一次跳过多个节点</strong>，后退指针<strong>只能后退至前一个</strong>节点，因为每个节点只有一个后退指针。</p></li><li><p>分值–score</p><p>分值是一个<strong>double类型的浮点数</strong>，跳跃表中节点都按照分值排序。</p></li><li><p>成员对象–obj</p><p>是一个指针，指向字符串<strong>SDS对象</strong>。一个跳跃表中，<strong>对象必须是唯一的，但分值可以相同</strong>。相同时按对象字典序来排序。</p><blockquote><p>字典序的大小是指成员对象在字典中的排序</p></blockquote></li></ol><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>当一个集合只包含整数元素，并且元素不多时，Redis就会使用整数集合作为集合键的底层实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs none">typedef struct intset&#123;<br>    //编码方式<br>    uint32_t encoding;<br>    //集合包含的元素数量<br>    uint32_t length;<br>    //保存元素的数组<br>    int8_t contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><p>contents数组是<strong>整数集合的底层实现</strong>：整数集合的<strong>每个元素都是contents数据的一个数组项</strong>(item) ,各个项在数组中按值得大小<strong>从小到大有序地排列</strong>，并且数组中不包含任何重复项。</p><p>length属性记录了整数集合包含的元素数量，contents是整数集合的底层实现。contents存储元素的真实类型<strong>取决于encoding</strong>，比如<code>encoding==INT_ENC_INT16</code>时，contents数组中每个向都是int16_t类型的整数。可以为<code>int16_t</code>,<code>int32_t</code>或<code>int64_t</code>。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424131941382.png" alt="image-20220424131941382"></p><p><strong>升级</strong></p><p>当我们要将一个新元素添加至集合时，并且新元素的类型<strong>比现有集合类型都长</strong>时，整数集合就要升级。</p><p>步骤：</p><ol><li>根据新元素类型，<strong>扩展</strong>数组空间，为新元素分配空间。</li><li>将底层数组现有所有元素<strong>都转为新元素相同类型</strong>，并将类型转换后的元素放到正确位置。</li><li>将新元素<strong>添加</strong>到底层数组。</li></ol><p>由于每次向整数集合添加新元素都<strong>可能会引起升级</strong>，而每次升级都需要对底层数组中已有元素进行类型转换，所以添加的**时间复杂度为O(N)**。</p><p><strong>升级的好处</strong></p><p>有两个好处，可以提升整数集合的<strong>灵活性</strong>，也能尽可能地<strong>节约内存</strong>。<br> C语言是静态类型语言，一般数组中的元素类型都相同，使用升级可以<strong>不用担心类型兼容</strong>问题，提升灵活性。元素统一以最大类型存储，而不是都用<code>int64_t</code>，可节约内存。</p><p><strong>降级</strong></p><p>整数集合<strong>不支持降低</strong>，一旦升级就不能降级。</p><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>为节约内存而开发的，由一系列<strong>特殊编码</strong>的<strong>连续内存块</strong>组成的<strong>顺序型</strong>数据结构。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424132113019.png" alt="image-20220424132113019"></p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424132120306.png" alt="image-20220424132120306"></p><h3 id="压缩列表节点"><a href="#压缩列表节点" class="headerlink" title="压缩列表节点"></a>压缩列表节点</h3><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424132153858.png" alt="image-20220424132153858"></p><p><strong>previous_entry_length</strong></p><p>单位是字节，记录压缩列表<strong>前一个节点的长度</strong>。该属性长度为<strong>1字节或5字节</strong>，前<strong>两位</strong>表示该属性长度为2位还是10位。</p><p><strong>encoding</strong></p><p>encoding记录了节点的content属性所保存<strong>数据类型</strong>和<strong>长度</strong>。<strong>高两位</strong>表示存储的是字节数组还是整数。</p><p><strong>content</strong></p><p>存储节点的值。</p><h3 id="连续更新"><a href="#连续更新" class="headerlink" title="连续更新"></a>连续更新</h3><p>当<strong>多个连续</strong>的长度<strong>介于250字节到253字节</strong>之间的节点，插入新的头节点（长度大于等于245字节），后面节点的previous_entry_length就要新增4字节的空间（1字节变成5字节），需要进行<strong>内存重分配</strong>，由于前一个节点的变更，每个节点的previous_entry_length属性<strong>也需要记录之前的长度而发生相应的变更</strong>，所以会出现连锁更新。除了新增节点，删除节点也可能会遇到这种情况。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行<strong>N次空间重分配操作</strong>，每次<strong>重分配的的最坏时间复杂度</strong>为</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战应用</title>
    <link href="/2022/10/17/Redis%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <url>/2022/10/17/Redis%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="如何使用redis实现消息队列"><a href="#如何使用redis实现消息队列" class="headerlink" title="如何使用redis实现消息队列"></a>如何使用redis实现消息队列</h2><h3 id="消息队列的存取需求"><a href="#消息队列的存取需求" class="headerlink" title="消息队列的存取需求"></a>消息队列的存取需求</h3><ol><li><p>消息保序</p><p>虽然消费者是异步处理消息，但是，消费者仍然需要按照生产者发送消息的顺序来处理消 息，避免后发送的消息被先处理了</p></li><li><p>重复消息处理</p><p>消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。此时，消费 者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成 一个业务逻辑被多次执行</p></li><li><p>消息可靠性保证</p><p>消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。当消费者重启后，可以重新读取消息再次进行处理</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="基于List的消息队列解决方案"><a href="#基于List的消息队列解决方案" class="headerlink" title="基于List的消息队列解决方案"></a>基于List的消息队列解决方案</h4><p><strong>消息保序：</strong>生产者可以使用 LPUSH 命令把要发送的消息依次写入 List，而消费者则可以使 用 RPOP 命令，从 List 的另一端按照消息的写入顺序，依次读取消息并进行处理。</p><p>因为List不会主动通知消费者有新消息写入，redis提供了BRPOP命令（阻塞式读取），客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列。</p><p><strong>重复消息处理：</strong>我们可以为每一个消息提供全局唯一的ID号，List 本身是不会为每个消息生成 ID 号的，所以，消息的全局唯一 ID 号就需要生产者程序在发送消息前自行生成。生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p><p><strong>消息可靠性：</strong>List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从 一个 List  中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份  List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从 备份 List 中重新读取消息并进行处理了。</p><h4 id="基于Streams的消息队列解决方案"><a href="#基于Streams的消息队列解决方案" class="headerlink" title="基于Streams的消息队列解决方案"></a>基于Streams的消息队列解决方案</h4><p>Streams 是 Redis 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令</p><ul><li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li><li>XREAD：用于读取消息，可以按 ID 读取数据，可以设置block配置，实现阻塞读取操作。</li><li>XREADGROUP：按消费组形式读取消息；</li><li>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取 但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</li></ul><blockquote><p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的</p></blockquote><ol><li><strong>消息保序：</strong>XADD和XREAD命令</li><li><strong>重复消息处理</strong>：消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消 费组内的其他消费者读取了</li><li><strong>消息可靠性：</strong> Streams 会自动使用内部队列（也称为 PENDING  List）留存消费组里每个消费者读取的消息，直到 消费者使用 XACK 命令通知 Streams“消息已经处理完成”。如果消费者没有成功处理消  息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启 后，用 XPENDING  命令查看已读取、但尚未确认处理完成的消息。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220424190724890.png" alt="image-20220424190724890"></p><h2 id="如何解决缓存和数据库的数据不一致问题"><a href="#如何解决缓存和数据库的数据不一致问题" class="headerlink" title="如何解决缓存和数据库的数据不一致问题"></a>如何解决缓存和数据库的数据不一致问题</h2><h3 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h3><p>要想保证缓存和数据库中的数据一致，就要采用同步直写策略，同时更新缓存和数据库。所以我们要在业务中使用事务机制，保证缓存和数据库的更新具有原子性。</p><blockquote><p>同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致；</p><p>异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。 使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么，此时，数据 库就没有最新的数据了。</p></blockquote><h3 id="只读缓存"><a href="#只读缓存" class="headerlink" title="只读缓存"></a>只读缓存</h3><h4 id="1-新增数据"><a href="#1-新增数据" class="headerlink" title="1. 新增数据"></a>1. 新增数据</h4><p>直接写入到数据库中，缓存和数据库的数据是一致的。</p><h4 id="2-删改数据"><a href="#2-删改数据" class="headerlink" title="2. 删改数据"></a>2. 删改数据</h4><p>根据删除缓存和更新数据库的顺序不同会有不同的问题：</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220425071356565.png" alt="image-20220425071356565"></p><h5 id="无并发请求时"><a href="#无并发请求时" class="headerlink" title="无并发请求时"></a>无并发请求时</h5><p>两种情况均适用</p><p>重试机制</p><p>可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消 息队列中重新读取这些值，然后再次进行删除或更新。</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220425072518318.png" alt="image-20220425072518318"></p><h5 id="有并发请求时"><a href="#有并发请求时" class="headerlink" title="有并发请求时"></a>有并发请求时</h5><p>情况一：先删除缓存，再更新数据库</p><p>问题：</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220425071833360.png" alt="image-20220425071833360"></p><p>解决办法：在线程A更新完数据库值后，可以让它sleep一小段时间，再进行一次缓存删除操作。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫 做<strong>“延迟双删”</strong></p><blockquote><p>之所以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存（读取到的是旧值），然后，线程 A 再进行删除。这样一来，其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值。</p></blockquote><p>情况二：先更新数据库，再删除缓存值</p><p>问题：</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220425072100255.png" alt="image-20220425072100255"></p><p>期间有不一致数据短暂存在，，对业务影响较小</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220425072731205.png" alt="image-20220425072731205"></p><h2 id="Redis如何应对并发访问"><a href="#Redis如何应对并发访问" class="headerlink" title="Redis如何应对并发访问"></a>Redis如何应对并发访问</h2><p>并发访问控制对应的操作主要是数据修改操作。当客户端需要修改数据时，基本流程分成 两步：</p><ol><li>客户端先把数据读取到本地，在本地进行修改；</li><li>客户端修改完数据后，再写回 Redis。</li></ol><p>我们把这个流程叫做“读取 - 修改 - 写回”操作（Read-Modify-Write，简称为 RMW 操 作）。</p><p>在并发情况下，这三个操作不具有互斥性，多个客户端值基于相同的初始值进行修改，而不是基于前一个客户端修改后的值进行修改。</p><p>所以要应对并发访问，我们就需要将这三个并发操作变成串行操作。</p><h3 id="办法一"><a href="#办法一" class="headerlink" title="办法一"></a>办法一</h3><p>加锁</p><p>加锁可以将并发操作变成串行操作，但是会导致系统并发性能降低，且如果有多个客户端加锁时，需要使用分布式锁</p><p><img src="https://wuchunlin-blog-img.oss-cn-beijing.aliyuncs.com/img/image-20220425074253905.png" alt="image-20220425074253905"></p><h3 id="办法二"><a href="#办法二" class="headerlink" title="办法二"></a>办法二</h3><p>为了实现并发控制要求的临界区代码互斥执行，Redis 的原子操作采用了两种方法：</p><ol><li><p>把多个操作在 Redis 中实现成一个操作，也就是单命令操作；</p><p>INCR&#x2F;DECR 命令可以对数据进行增值 &#x2F; 减值操作，而且它们本身就是单个命令操作， Redis 在执行它们时，本身就具有互斥性。</p></li><li><p>把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本。</p><p>Redis 会把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而 保证了 Lua  脚本中操作的原子性。如果我们有多个操作要执行，但是又无法用 INCR&#x2F;DECR 这种命令操作来实现，就可以把这些要执行的操作编写到一个 Lua  脚本中</p></li></ol><h2 id="如何使用Redis实现分布式锁？"><a href="#如何使用Redis实现分布式锁？" class="headerlink" title="如何使用Redis实现分布式锁？"></a>如何使用Redis实现分布式锁？</h2><p>分布式锁是由共享存储系统维护的变量，多个客户端可以向共享存储系统发送命令进行加 锁或释放锁操作。Redis 作为一个共享存储系统，可以用来实现分布式锁。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><h4 id="基于单个-Redis-节点实现分布式锁"><a href="#基于单个-Redis-节点实现分布式锁" class="headerlink" title="基于单个 Redis 节点实现分布式锁"></a>基于单个 Redis 节点实现分布式锁</h4><p>对于加锁操作，我们需要满足三个条件</p><ol><li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的 方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li><li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所 以，我们在 SET 命令执行时加上 EX&#x2F;PX 选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操 作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用 于标识客户端。</li></ol><h4 id="基于多个-Redis-节点实现高可靠的分布式锁"><a href="#基于多个-Redis-节点实现高可靠的分布式锁" class="headerlink" title="基于多个 Redis 节点实现高可靠的分布式锁"></a>基于多个 Redis 节点实现高可靠的分布式锁</h4><p>可以使用分布式锁算法Redlock</p><p>Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户 端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布 式锁了，否则加锁失败。</p><p>这样一来，即使有单个 Redis 实例发生故障，因为锁变量在其它 实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>释放锁包含了读取锁变量值、判断锁变量值和删除锁变量三个操作，我们无法使用单个命令来实现，所以，我们可以采用 Lua 脚本执行释放锁操作，通过 Redis 原子性地执行 Lua 脚本，来保证释放锁操作的原子性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis实战</title>
    <link href="/2022/10/17/Redis%E5%AE%9E%E6%88%98/"/>
    <url>/2022/10/17/Redis%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="共享session登录问题"><a href="#共享session登录问题" class="headerlink" title="共享session登录问题"></a>共享session登录问题</h2><h3 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h3><p>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。</p><p>session的替代方案应该满足：</p><p>• 数据共享</p><p>• 内存存储</p><p>• key、value结构</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ca229e01241af492ff0d1577936625a2.png" alt="image-20220516093700643"></p><h3 id="使用Redis实现共享session登录"><a href="#使用Redis实现共享session登录" class="headerlink" title="使用Redis实现共享session登录"></a>使用Redis实现共享session登录</h3><ul><li>当我们发送验证码时，以手机号为key，存储验证码（String）</li><li>登录验证通过后，以随机token为key，存储用户数据（Hash）</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/138580536c2f762d93fae8e0cc9b0c83.png" alt="image-20220516093914252"></p><p>发送验证码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sedCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">//1. 校验手机号</span><br>        <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>            <span class="hljs-comment">//2.如果不符合，返回错误信息</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//3. 符合，生成验证码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>        <span class="hljs-comment">//4. 保存验证码到session</span><br><span class="hljs-comment">//        session.setAttribute(&quot;code&quot;,code);</span><br>        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">//5. 发送验证码</span><br>        log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码:&#123;&#125;&quot;</span>,code);<br>        <span class="hljs-comment">//返回ok</span><br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br></code></pre></td></tr></table></figure><p>登录验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">//1. 校验手机号</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>        <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//2. 校验验证码</span><br>         <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY+phone);<br><span class="hljs-comment">//        Object cacheCode = session.getAttribute(&quot;code&quot;);</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>        <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code))&#123;<br>            <span class="hljs-comment">//3. 不一致，报错</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//4.一致，根据手机号查询用户</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>        <span class="hljs-comment">//5. 判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//6. 不存在，创建新用户</span><br>            user = createUserWithPhone(phone);<br>        &#125;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span>  <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>                CopyOptions.create()<br>                        .setIgnoreNullValue(<span class="hljs-literal">true</span>)<br>                        .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));<br>        String tokenkey=LOGIN_USER_KEY+token;<br>        stringRedisTemplate.opsForHash().putAll(tokenkey,userMap);<br>        stringRedisTemplate.expire(tokenkey,LOGIN_USER_TTL,TimeUnit.MINUTES);<br><br>        <span class="hljs-keyword">return</span> Result.ok(token);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="登录拦截器"><a href="#登录拦截器" class="headerlink" title="登录拦截器"></a>登录拦截器</h3><blockquote><p>每次发送请求时，需要进行身份校验，并且还需要刷新token有效期，这些步骤适合放在登录拦截器中处理</p></blockquote><p>流程分析：</p><ol><li>获取token</li><li>查询Redis的用户<ul><li>不存在，拦截</li><li>存在，继续</li></ul></li><li>保存到ThreadLocal</li><li>刷新token有效期</li><li>放行</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/288e6b46258bc3af7dae76a74831ae90.png" alt="image-20220516094619775"></p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.获取请求头中的token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.基于TOKEN获取redis中的用户</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span>  <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>    Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br>    <span class="hljs-comment">// 3.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 5.将查询到的hash数据转为UserDTO</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 6.存在，保存用户信息到 ThreadLocal</span><br>    UserHolder.saveUser(userDTO);<br><br>    <span class="hljs-comment">// 7.刷新token有效期</span><br>    stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 8.放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意这里之所以要保存信息到ThreadLocal中，是为了后面在service中方便拿出使用，因为存在线程不安全问题，所以使用ThreadLocal保存</p></blockquote><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><blockquote><p>店铺类型在很多地方都用到，为了提高查询效率，添加查询缓存，但与此同时，因为更新缓存和更新数据库的操作不是原子性的，可能会导致缓存和数据不一致问题</p></blockquote><p>业务场景：</p><ul><li>低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存 （设置过期时间）</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存（使用更新策略）</li></ul><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><h4 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h4><ol><li><p>Cache Aside Pattern</p><p>由缓存的调用者，在更新数据库的同时更新缓存</p></li><li><p>Read&#x2F;Write Through Pattern</p><p>缓存与数据库整合为一个服务，由服务来维护一致性。<br> 调用者调用该服务，无需关心缓存一致性问题</p></li><li><p>Write Behind Caching Pattern<br> 调用者只操作缓存，由其它线程异步的将缓存数据持久化到数据库，保证最终一致。</p></li></ol><blockquote><p>综合各种考虑，我们这里的更新策略选择第一种，可以更好的与当前业务结合。</p></blockquote><h4 id="更新顺序不一致导致的问题"><a href="#更新顺序不一致导致的问题" class="headerlink" title="更新顺序不一致导致的问题"></a>更新顺序不一致导致的问题</h4><p>根据删除缓存和更新数据库的顺序不同会有不同的问题：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a3012d6ed8569d257834d6c1c103ed7b.png" alt="img"></p><ol><li><p>先删除缓存，后更新数据库：</p><p>会导致缓存中存放的是旧值</p></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/f7388746fc189792f84b90e1a58dc5fa.png" alt="image-20220516100907814"></p><ol><li><p>先更新数据库，后删除缓存</p><p>更新数据库后，未删除缓存时，存在短暂数据不一致情况</p></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/9751313f764f9767ddb9f8612890659f.png" alt="img"></p><blockquote><p>先更新数据库值，后删除缓存的方案在等待缓存删除完成期间会有短暂的不一致数据存在。但对于商铺详情信息来说，可以接受。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(Shop shop)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> shop.getId();<br>    <span class="hljs-keyword">if</span>(id == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺id不能为空&quot;</span>);<br>    &#125;<br>    updateById(shop);<br>    stringRedisTemplate.delete(CACHE_SHOP_KEY+id);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h3><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ol><li>缓存空对象</li></ol><p>​ ◆ 优点：实现简单，维护方便</p><p>​◆ 缺点：</p><p>​• 额外的内存消耗</p><p>​ • 可能造成短期的不一致</p><ol><li><p>布隆过滤</p><p>◆ 优点：内存占用较少，没有多余key</p><p>◆ 缺点：</p><p>​• 实现复杂</p><p>​• 存在误判可能</p></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/cb0579f9d8d7f1ee27f2c7f96ef62c1e.png" alt="image-20220516102010002"></p><blockquote><p>这里我们选择缓存空对象来解决</p></blockquote><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>流程分析：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1f828e2185e7849bc1a951525e00936d.png" alt="image-20220516102112424"></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Shop <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(Long id)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY+id;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br><br>    <span class="hljs-comment">//不为null和“”</span><br>    <span class="hljs-keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;<br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span>  shop;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (shopJson!=<span class="hljs-literal">null</span> &amp;&amp; shopJson.length()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//命中的是空值“”</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-keyword">if</span>(shop==<span class="hljs-literal">null</span>)&#123;<br>        stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span>  <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL,TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><p>◆ 给不同的Key的TTL添加随机值</p><p>◆ 利用Redis集群提高服务的可用性</p><p>◆ 给缓存业务添加降级限流策略</p><p>◆ 给业务添加多级缓存</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ee8d009b493d66ab851d28b6dbafe283.png" alt="image-20220516102731884"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问 会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/e48b78590b17c1806fbcdd967a0c26f0.png" alt="image-20220516102901205"></p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>如果热点key失效，只运行一个线程去更新缓存，其他线程等更新好后再来获取</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e8053dd68f00bf85bf0ce606f639bbe6.png" alt="image-20220516102952256"></p><p>流程分析：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c1c644357476d0ea49029c852e710e05.png" alt="image-20220516103138696"></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>    stringRedisTemplate.delete(key);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(</span><br><span class="hljs-params">    String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>    <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.存在，直接返回</span><br>        <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, type);<br>    &#125;<br>    <span class="hljs-comment">// 判断命中的是否是空值</span><br>    <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 返回一个错误信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 4.实现缓存重建</span><br>    <span class="hljs-comment">// 4.1.获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>        <span class="hljs-comment">// 4.2.判断是否获取成功</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            <span class="hljs-comment">// 4.3.获取锁失败，休眠并重试</span><br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            <span class="hljs-keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);<br>        &#125;<br>        <span class="hljs-comment">// 4.4.获取锁成功，根据id查询数据库</span><br>        r = dbFallback.apply(id);<br>        <span class="hljs-comment">// 5.不存在，返回错误</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 将空值写入redis</span><br>            stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>            <span class="hljs-comment">// 返回错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 6.存在，写入redis</span><br>        <span class="hljs-built_in">this</span>.set(key, r, time, unit);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 7.释放锁</span><br>        unlock(lockKey);<br>    &#125;<br>    <span class="hljs-comment">// 8.返回</span><br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="逻辑锁过期"><a href="#逻辑锁过期" class="headerlink" title="逻辑锁过期"></a>逻辑锁过期</h4><p>没有设置过期时间，但会为每个key设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独线程去构建缓存。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/58072a74a7338c10dce91785c3955d50.png" alt="image-20220516104717854"></p><p>流程分析：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/50092d5cc10402d98ea903c49712e6d3.png" alt="image-20220516104745962"></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(</span><br><span class="hljs-params">           String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>       <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <br>       <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>       <span class="hljs-comment">// 2.判断是否存在</span><br>       <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>         <span class="hljs-comment">//热点key会进行预热，即会提前传入缓存中，</span><br>       <span class="hljs-comment">// 如果缓存中都没有，则表明这个数据也不在数据库，没有必要继续查询数据库了</span><br>        <span class="hljs-comment">// 3.不存在，直接返回</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-comment">// 4.命中，需要先把json反序列化为对象</span><br>       <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>       <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);<br>       <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>       <span class="hljs-comment">// 5.判断是否过期</span><br>       <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;<br>           <span class="hljs-comment">// 5.1.未过期，直接返回店铺信息</span><br>           <span class="hljs-keyword">return</span> r;<br>       &#125;<br>       <span class="hljs-comment">// 5.2.已过期，需要缓存重建</span><br>       <span class="hljs-comment">// 6.缓存重建</span><br>       <span class="hljs-comment">// 6.1.获取互斥锁</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>       <span class="hljs-comment">// 6.2.判断是否获取锁成功</span><br>       <span class="hljs-keyword">if</span> (isLock)&#123;<br>           <span class="hljs-comment">// 6.3.成功，开启独立线程，实现缓存重建</span><br>           CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-comment">// 查询数据库</span><br>                   <span class="hljs-type">R</span> <span class="hljs-variable">newR</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>                   <span class="hljs-comment">// 重建缓存</span><br>                   <span class="hljs-built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);<br>               &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>               &#125;<span class="hljs-keyword">finally</span> &#123;<br>                   <span class="hljs-comment">// 释放锁</span><br>                   unlock(lockKey);<br>               &#125;<br>           &#125;);<br>       &#125;<br>       <span class="hljs-comment">// 6.4.返回过期的商铺信息</span><br>       <span class="hljs-keyword">return</span> r;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/809bda5a7aa4d897172b5709cb07e0e4.png" alt="image-20220516104936500"></p><h2 id="优惠劵秒杀"><a href="#优惠劵秒杀" class="headerlink" title="优惠劵秒杀"></a>优惠劵秒杀</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题 ：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制，分布式场景下无法使用</li></ul><blockquote><p>我们可以借助redis的incr指令来做自增</p></blockquote><p>全局ID生成器</p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/640d438eb7fe4b9a03e84b87d55d191c.png" alt="image-20220516105549647"></p><p>ID的组成部分：</p><ul><li>符号位：1bit，永远为0</li><li>时间戳：31bit，以秒为单位，可以使用69年</li><li>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID（使用redis实现）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列号的位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisIdWorker</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br><br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1.获取当前日期，精确到天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">// 2.2.自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br><br>        <span class="hljs-comment">// 3.拼接并返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的redis的key是<code>&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date</code>，这样就可以每天一个key，方便统计订单量</p></blockquote><h3 id="实现优惠劵秒杀下单"><a href="#实现优惠劵秒杀下单" class="headerlink" title="实现优惠劵秒杀下单"></a>实现优惠劵秒杀下单</h3><p>下单时需要判断两点：</p><p>• 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</p><p>• 库存是否充足，不足则无法下单</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5b388af0f29583c44f381f8bb79df4ab.png" alt="image-20220516125521092"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 库存不足</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//创建订单</span><br>    <span class="hljs-keyword">return</span> createVoucherOrder(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>认为线程安全问题一定会发生，因此 在操作数据之前先获取锁，确保线程 串行执行。这里使用synchronized来加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 5.一人一单</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>        <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 7.1.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 7.2.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 7.3.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        save(voucherOrder);<br><br>        <span class="hljs-comment">// 7.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优点：简单粗暴</p><p>缺点：性能一般</p></blockquote><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>认为线程安全问题不一定会发生，因 此不加锁，只是在更新数据时去判断 有没有其它线程对数据做了修改。</p><p>◆ 如果没有修改则认为是安全的，自 己才更新数据。</p><p>◆ 如果已经被其它线程修改说明发生 了安全问题，此时可以重试或异常。</p><ol><li><p>版本号法</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9e3836b69dd84f9043a13db3cb1b407e.png" alt="image-20220516210403193"></p><blockquote><p>需要增加一个版本号字段，如果修改了的话就增加1</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/f698a60608388990aa6f7c4ab3a51f93.png" alt="image-20220516210114906"></p></li><li><p>CAS法</p><blockquote><p>扣减前获取库存量，调用sql扣减时判断此时库存是否等于前面查到的库存，如果没有变化就是没有人修改过</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/57f4bda147a7c167e5719f8cdca9900a.png" alt="image-20220516210633910"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 5.一人一单</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>    <span class="hljs-comment">// 创建锁对象</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>    <span class="hljs-comment">// 尝试获取锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.tryLock();<br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span>(!isLock)&#123;<br>        <span class="hljs-comment">// 获取锁失败，直接返回失败或者重试</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 7.1.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 7.2.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 7.3.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        save(voucherOrder);<br><br>        <span class="hljs-comment">// 7.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        redisLock.unlock();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li></li></ol><blockquote><p>性能好，但适合读多写少的情况，这种秒杀的情况，读跟写差不多的话使用CAS就回导致成功率低</p></blockquote><h4 id="mysql的排他锁"><a href="#mysql的排他锁" class="headerlink" title="mysql的排他锁"></a>mysql的排他锁</h4><p>只需要在更新时判断此时库存是否大于0</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> goods <span class="hljs-keyword">set</span> stock <span class="hljs-operator">=</span> stock <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1001</span> <span class="hljs-keyword">and</span> stock <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>使用update时会加排他锁，这一行不能被任何其他线程修改和读写</p><p>排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p>流程分析：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/57d664d273be5f1ffa5a362426456591.png" alt="image-20220516211344556"></p><p>存在的并发问题：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4ae317472d555ae2bc24ddfab70a6d8a.png" alt="image-20220516211421177"></p><blockquote><p>并发情况下，他们同时查询到订单中没有他们的，于是他们都认为自己是第一次购买，导致一人多单情况</p></blockquote><h4 id="单机情况下"><a href="#单机情况下" class="headerlink" title="单机情况下"></a>单机情况下</h4><p>可以使用锁来保证并发安全</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c04bec7fc052259a658abaa09cca1b0c.png" alt="image-20220516211642662"></p><p>具体代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 5.一人一单</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>        <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 7.创建订单</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 7.1.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 7.2.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 7.3.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        save(voucherOrder);<br><br>        <span class="hljs-comment">// 7.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里锁住的是<code>userId.toString().intern()</code>，通过intern()可以将字符串放入常量池中，对于一个JVM实例中，常量池中的常量唯一，这样多个线程就可以基于这个唯一常量加锁。</p></blockquote><h4 id="分布式下"><a href="#分布式下" class="headerlink" title="分布式下"></a>分布式下</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/6d88ad72359b557dbf4587f366355698.png" alt="image-20220516212333213"></p><blockquote><p>分布式锁是由共享存储系统维护的变量，多个客户端可以向共享存储系统发送命令进行加 锁或释放锁操作。Redis 作为一个共享存储系统，可以用来实现分布式锁。</p></blockquote><h5 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h5><p>对于加锁操作，我们需要满足三个条件</p><ol><li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的 方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li><li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所 以，我们在 SET 命令执行时加上 EX&#x2F;PX 选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操 作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用 于标识客户端。</li></ol><p>对于释放锁操作，需要注意</p><p>释放锁包含了读取锁变量值、判断锁变量值和删除锁变量三个操作，我们无法使用单个命令来实现，所以，我们可以采用 Lua 脚本执行释放锁操作，通过 Redis 原子性地执行 Lua 脚本，来保证释放锁操作的原子性。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/aec719b1fc7f7a3e8466dd617f2c379a.png" alt="image-20220516213013356"></p><p>加锁操作，需要加入线程标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>        .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br></code></pre></td></tr></table></figure><p>释放锁，调用lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 比较线程标示与锁中的标示是否一致</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) ==  ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 释放锁 del key</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="分布式锁-Redission"><a href="#分布式锁-Redission" class="headerlink" title="分布式锁-Redission"></a>分布式锁-Redission</h3><p>基于setnx实现的分布式锁存在下面的问题</p><ol><li>不可重入 : 同一个线程无法多次获取同一把</li><li>不可重试 :  获取锁只尝试一次就返回 false，没有重试机制</li><li>超时释放 : 锁超时释放虽然可以避免 死锁，但如果是业务执行 耗时较长，也会导致锁释 放，存在安全隐患</li><li>主从一致性 : 如果Redis提供了主从集群， 主从同步存在延迟，当主 宕机时，如果从并同步主 中的锁数据，则会出现锁 实现</li></ol><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布 式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。使用Redission可以解决上面提到的4个问题。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/23f7409d26d8ba1b02aaa27a8ff2a203.png" alt="image-20220516213851729"></p><h3 id="Redis优化秒杀"><a href="#Redis优化秒杀" class="headerlink" title="Redis优化秒杀"></a>Redis优化秒杀</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/0e1432a91e8c5d574a3dc2e486152dab.png" alt="image-20220518202549208"></p><p>我们之前的操作都是基于数据库的，但是操作数据库的性能是比较慢的，我们可以将判断秒杀库存跟校验一人一单的操作放到Redis缓存中，然后再开启另外一个线程去处理数据库相关的步骤。</p><p>优化思路：</p><p>① 先利用Redis完成库存余量、一人一单判断，完成抢单业务</p><p>② 再将下单业务放入阻塞队列，利用独立线程异步下单</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dd08e5227a5f25282d9a7e1785928f71.png" alt="image-20220518202840873"></p><p>步骤分析：</p><p>① 新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p><p>② 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p><p>③ 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p><p>④ 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p><p>代码实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1.优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2.用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1.库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2.订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>public Result seckillVoucher(Long voucherId) &#123;<br>    Long userId = UserHolder.getUser().getId();<br>    // <span class="hljs-number">1.</span>执行lua脚本<br>    Long result = stringRedisTemplate.<span class="hljs-built_in">execute</span>(<br>        SECKILL_SCRIPT,<br>        Collections.emptyList(),<br>        voucherId.toString(), userId.toString()<br>    );<br>    int r = result.intValue();<br>    // <span class="hljs-number">2.</span>判断结果是否为<span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>        // <span class="hljs-number">2.1</span>.不为<span class="hljs-number">0</span> ，代表没有购买资格<br>        <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>    &#125;<br>    // <span class="hljs-number">2.2</span>.为<span class="hljs-number">0</span> ，有购买资格，把下单信息保存到阻塞队列<br>    VoucherOrder voucherOrder = new VoucherOrder();<br>    // <span class="hljs-number">2.3</span>.订单id<br>    long orderId = redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    // <span class="hljs-number">2.4</span>.用户id<br>    voucherOrder.setUserId(userId);<br>    // <span class="hljs-number">2.5</span>.代金券id<br>    voucherOrder.setVoucherId(voucherId);<br>    // <span class="hljs-number">2.6</span>.放入阻塞队列<br>    orderTasks.add(voucherOrder);<br><br>    // <span class="hljs-number">3.</span>返回订单id<br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br><br>//处理阻塞线程中的订单，保存到数据库中<br>private BlockingQueue&lt;VoucherOrder&gt; orderTasks = new ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br>    private class VoucherOrderHandler implements Runnable&#123;<br><br>        @Override<br>        public void run() &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                try &#123;<br>                    // <span class="hljs-number">1.</span>获取队列中的订单信息<br>                    VoucherOrder voucherOrder = orderTasks.take();<br>                    // <span class="hljs-number">2.</span>创建订单<br>                    createVoucherOrder(voucherOrder);<br>                &#125; catch (Exception e) &#123;<br>                    <span class="hljs-built_in">log</span>.<span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这种基于java的阻塞队列的异步秒杀存在哪些问题？</p><ul><li>内存限制问题</li><li>数据安全问题</li></ul><h3 id="Redis消息队列实现异步秒杀"><a href="#Redis消息队列实现异步秒杀" class="headerlink" title="Redis消息队列实现异步秒杀"></a>Redis消息队列实现异步秒杀</h3><p>消息队列（Message Queue），字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c80040567a441559ccb093de1b46431e.png" alt="image-20220518205827187"></p><p>Redis提供了三种不同的方式来实现消息队列：</p><p>◆ list结构：基于List结构模拟消息队列</p><p>◆ PubSub：基本的点对点消息模型</p><p>◆ Stream：比较完善的消息队列模型</p><h4 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h4><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟 出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。</p><p>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息 。</p><p>因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/83416c30f4d51e9bbfab913171ebd897.png" alt="image-20220518210225552"></p><p>基于List的消息队列有哪些优缺点？</p><p>优点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">• 利用Redis存储，不受限于JVM内存上限 <br></code></pre></td></tr></table></figure><p>​• 基于Redis的持久化机制，数据安全性有保证</p><p>​• 可以满足消息有序性</p><p>缺点：</p><p>​• 无法避免消息丢失</p><p>​• 只支持单消费者</p><h4 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h4><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者 向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p>◼ SUBSCRIBE channel [channel] ：订阅一个或多个频道</p><p>◼ PUBLISH channel msg ：向一个频道发送消息</p><p>◼ PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ea686180de49926bbd30cbfd357618b6.png" alt="image-20220518210545049"></p><p>基于PubSub的消息队列有哪些优缺点？</p><p>优点：</p><p>​ • 采用发布订阅模型，支持多生产、多消费</p><p>缺点：</p><p>​ • 不支持数据持久化</p><p>​• 无法避免消息丢失</p><p>​ • 消息堆积有上限，超出时数据丢失</p><h4 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h4><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。 发送消息的命令</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1ed0d94f7ac2a54452e002df6e2cd6f6.png" alt="image-20220518210800377"></p><p>例如：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5d47f7780c0ad53d64a51d0e14025a17.png" alt="image-20220518210814446"></p><h5 id="1-基于Stream的消息队列-XREAD"><a href="#1-基于Stream的消息队列-XREAD" class="headerlink" title="1. 基于Stream的消息队列-XREAD"></a>1. 基于Stream的消息队列-XREAD</h5><p>​读取消息的方式之一：XREAD</p><p><img src="https://img-blog.csdnimg.cn/img_convert/46752e9c3ec76d6c1d07cbcf14c149ba.png" alt="image-20220518210845461"></p><p>​例如，使用XREAD读取第一个消息：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/49668ab1a9cb5389c8d93b93816cc436.png" alt="image-20220518210920772"></p><p>XREAD阻塞方式，读取最新的消息：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/45af63955c7be7a3688088c96f7b1453.png" alt="image-20220518210936922"></p><p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-a5PVuDHs-1652915735655)(C:&#x2F;Users&#x2F;wcl&#x2F;AppData&#x2F;Roaming&#x2F;Typora&#x2F;typora-user-images&#x2F;image-20220518210952049.png)]</p><blockquote><p>当我们指定起始ID为$时，代表读取最新的消息，如果我们处 理一条消息的过程中，又有超过1条以上的消息到达队列，则 下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p></blockquote><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h5 id="2-基于Stream的消息队列-消费者组"><a href="#2-基于Stream的消息队列-消费者组" class="headerlink" title="2. 基于Stream的消息队列-消费者组"></a>2. 基于Stream的消息队列-消费者组</h5><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p>（1）消息分流</p><p>队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度</p><p>（2）消息标示</p><p>消费者组会维护一个标示， 记录最后一个被处理的消息， 哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费。</p><p>（3）消息确认</p><p>消费者获取消息后，消息处于 pending状态，并存入一个 pending-list。当处理完成后 需要通过XACK来确认消息，标记 消息为已处理，才会从pendinglist移除</p><p><strong>具体命令</strong></p><p>创建消费者组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">XGROUP CREATE key groupName ID [MKSTREAM]<br></code></pre></td></tr></table></figure><ul><li>key：队列名称</li><li>groupName：消费者组名称</li><li>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息</li><li>MKSTREAM：队列不存在时自动创建队列</li></ul><p>其它常见命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs none"># 删除指定的消费者组<br>XGROUP DESTORY key groupName<br># 给指定的消费者组添加消费者<br>XGROUP CREATECONSUMER key groupname consumername<br># 删除消费者组中的指定消费者<br>XGROUP DELCONSUMER key groupname consumername<br></code></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS <br>key [key ...] ID [ID ...<br></code></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li><li>“&gt;”：从下一个未消费的消息开始</li><li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一 个消息开始</li></ul><p><strong>消费者监听消息的基本思路</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/80da4b11294df11e08410fc709355c06.png" alt="image-20220518211817883"></p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/4bfe64768b79c088e83c10073bc6dc33.png" alt="image-20220518211934855"></p><p>因此我们这里选择基于Redis的Stream机构作为消息队列，实现异步秒杀下单</p><p>思路分析：</p><p>① 创建一个Stream类型的消息队列，名为stream.orders</p><p>② 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包 含voucherId、userId、orderId</p><p>③ 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</p><p>具体实现：</p><ol><li>创建一个Stream类型的消息队列</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/2defe0224aa70a75e61cb7f2f46bab68.png" alt="image-20220518212512553"></p><ol><li><p>修改lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1.优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2.用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><span class="hljs-comment">-- 1.3.订单id</span><br><span class="hljs-keyword">local</span> orderId = ARGV[<span class="hljs-number">3</span>]<br><br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1.库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2.订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span><br>redis.call(<span class="hljs-string">&#x27;xadd&#x27;</span>, <span class="hljs-string">&#x27;stream.orders&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>, userId, <span class="hljs-string">&#x27;voucherId&#x27;</span>, voucherId, <span class="hljs-string">&#x27;id&#x27;</span>, orderId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li></li><li><p>执行lua脚本</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    <span class="hljs-comment">// 1.执行lua脚本</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>            SECKILL_SCRIPT,<br>            Collections.emptyList(),<br>            voucherId.toString(), userId.toString(), String.valueOf(orderId)<br>    );<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>    <span class="hljs-comment">// 2.判断结果是否为0</span><br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 2.1.不为0 ，代表没有购买资格</span><br>        <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>从redis的消息队列取出订单，同步到数据库中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br>                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(<br>                        Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                        StreamReadOptions.empty().count(<span class="hljs-number">1</span>).block(Duration.ofSeconds(<span class="hljs-number">2</span>)),<br>                        StreamOffset.create(<span class="hljs-string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())<br>                );<br>                <span class="hljs-comment">// 2.判断订单信息是否为空</span><br>                <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 如果为null，说明没有消息，继续下一次循环</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 解析数据</span><br>                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="hljs-number">0</span>);<br>                Map&lt;Object, Object&gt; value = record.getValue();<br>                <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 3.创建订单</span><br>                createVoucherOrder(voucherOrder);<br>                <span class="hljs-comment">// 4.确认消息 XACK</span><br>                stringRedisTemplate.opsForStream().acknowledge(<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, record.getId());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>                handlePendingList();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePendingList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span><br>                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(<br>                        Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                        StreamReadOptions.empty().count(<span class="hljs-number">1</span>),<br>                        StreamOffset.create(<span class="hljs-string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="hljs-string">&quot;0&quot;</span>))<br>                );<br>                <span class="hljs-comment">// 2.判断订单信息是否为空</span><br>                <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 如果为null，说明没有异常消息，结束循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 解析数据</span><br>                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="hljs-number">0</span>);<br>                Map&lt;Object, Object&gt; value = record.getValue();<br>                <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 3.创建订单</span><br>                createVoucherOrder(voucherOrder);<br>                <span class="hljs-comment">// 4.确认消息 XACK</span><br>                stringRedisTemplate.opsForStream().acknowledge(<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, record.getId());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>title</title>
    <link href="/2022/10/11/TCPIP%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82%EF%BC%9F/"/>
    <url>/2022/10/11/TCPIP%20%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-IP-网络模型有哪几层？"><a href="#TCP-x2F-IP-网络模型有哪几层？" class="headerlink" title="TCP&#x2F;IP 网络模型有哪几层？"></a>TCP&#x2F;IP 网络模型有哪几层？</h1><p>问大家，为什么要有 TCP&#x2F;IP 网络模型？</p><p>对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套<strong>通用的网络协议</strong>。</p><p>这个网络协议是分层的，每一层都有各自的作用和职责，接下来就根据「 TCP&#x2F;IP 网络模型」分别对每一层进行介绍。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="# 应用层"></a><a href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html#%E5%BA%94%E7%94%A8%E5%B1%82">#</a> 应用层</h2><p>最上层的，也是我们能直接接触到的就是<strong>应用层</strong>（<em>Application Layer</em>），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</p><p>所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。</p><p>而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="# 传输层"></a><a href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html#%E4%BC%A0%E8%BE%93%E5%B1%82">#</a> 传输层</h2><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="img"></p><p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p>TCP 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比  UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p>UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度）  ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP  协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCP Segment</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png" alt="img"></p><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p><p>比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。</p><p>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="# 网络层"></a><a href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html#%E7%BD%91%E7%BB%9C%E5%B1%82">#</a> 网络层</h2><p>传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。</p><p>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。</p><p>也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="img"></p><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="img"></p><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。</p><p>我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8  位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p><p>因此，需要将 IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>怎么分的呢？这需要配合<strong>子网掩码</strong>才能算出 IP 地址 的网络号和主机号。</p><p>举个例子，比如 10.100.122.0&#x2F;24，后面的<code>/24</code>表示就是 <code>255.255.255.0</code> 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用&#x2F;24代替255.255.255.0。</p><p>知道了子网掩码，该怎么计算出网络地址和主机地址呢？</p><p>将 10.100.122.2 和 255.255.255.0 进行<strong>按位与运算</strong>，就可以得到网络号，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg" alt="img"></p><p>将 255.255.255.0 取反后与IP地址进行进行<strong>按位与运算</strong>，就可以得到主机号。</p><p>大家可以去搜索下子网掩码计算器，自己改变下「掩码位」的数值，就能体会到子网掩码的作用了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E5%99%A8.png" alt="子网掩码计算器"></p><p>那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。</p><p>除了寻址能力， IP 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p><p>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg" alt="IP地址的网络号"></p><p>所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h2 id="网络接口层"><a href="#网络接口层" class="headerlink" title="# 网络接口层"></a><a href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82">#</a> 网络接口层</h2><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="img"></p><p>IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。</p><p>什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。</p><p>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</p><h2 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a><a href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html#%E6%80%BB%E7%BB%93">#</a> 总结</h2><p>综上所述，TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="img"></p><p>再给大家贴一下每一层的封装格式：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务应用</title>
    <link href="/2022/10/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/"/>
    <url>/2022/10/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务应用"><a href="#微服务应用" class="headerlink" title="微服务应用"></a>微服务应用</h1><h2 id="分布式权限校验"><a href="#分布式权限校验" class="headerlink" title="分布式权限校验"></a>分布式权限校验</h2><p>虽然完成前面的部分，我们已经可以自己去编写一个比较中规中矩的微服务项目了，但是还有一个问题我们没有解决，登录问题。假如现在要求用户登录之后，才能进行图书的查询、借阅等操作，那么我们又该如何设计这个系统呢？</p><p>回顾我们之前进行权限校验的原理，服务器是如何判定一个请求是来自哪个用户的呢？</p><ul><li>首先浏览器会向服务端发送请求，访问我们的网站。</li><li>服务端收到请求后，会创建一个SESSION ID，并暂时存储在服务端，然后会发送给浏览器作为Cookie保存。</li><li>之后浏览器会一直携带此Cookie访问服务器，这样在收到请求后，就能根据携带的Cookie中的SESSION ID判断是哪个用户了。</li><li>这样服务端和浏览器之间可以轻松地建立会话了。</li></ul><p>但是我们想一下，我们现在采用的是分布式的系统，那么在用户服务进行登录之后，其他服务比如图书服务和借阅服务，它们会知道用户登录了吗？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0uko0a27mj21ia08y0u9.jpg" alt="image-20220401220634827"></p><p>实际上我们登录到用户服务之后，Session中的用户数据只会在用户服务的应用中保存，而在其他服务中，并没有对应的信息，但是我们现在希望的是，所有的服务都能够同步这些Session信息，这样我们才能实现在用户服务登录之后其他服务都能知道，那么我们该如何实现Session的同步呢？</p><ol><li>我们可以在每台服务器上都复制一份Session，但是这样显然是很浪费时间的，并且用户验证数据占用的内存会成倍的增加。</li><li>将Session移出服务器，用统一存储来存放，比如我们可以直接在Redis或是MySQL中存放用户的Session信息，这样所有的服务器在需要获取Session信息时，统一访问Redis或是MySQL即可，这样就能保证所有服务都可以同步Session了（是不是越来越感觉只要有问题，没有什么是加一个中间件解决不了的）</li></ol><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0v7jwaum4j21qk0amq4h.jpg" alt="image-20220402111827054"></p><p>那么，我们就着重来研究一下，然后实现2号方案，这里我们就使用Redis作为Session统一存储，我们把一开始的压缩包重新解压一次，又来从头开始编写吧。</p><p>这里我们就只使用Nacos就行了，和之前一样，我们把Nacos的包导入一下，然后进行一些配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0v6vpkivcj22ca0baju3.jpg" alt="image-20220402105512397"></p><p>现在我们需要为每个服务都添加验证机制，首先导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  SpringSession Redis支持  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--  添加Redis的Starter  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后我们依然使用SpringSecurity框架作为权限校验框架：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们在每个服务都编写一下对应的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">session:</span><br>  <span class="hljs-comment"># 存储类型修改为redis</span><br>    <span class="hljs-attr">store-type:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">redis:</span><br>  <span class="hljs-comment"># Redis服务器的信息，该咋写咋写</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">1.14</span><span class="hljs-number">.121</span><span class="hljs-number">.107</span><br></code></pre></td></tr></table></figure><p>这样，默认情况下，每个服务的接口都会被SpringSecurity所保护，只有登录成功之后，才可以被访问。</p><p>我们来打开Nacos看看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0v6x7rkvuj22cm09sq4s.jpg" alt="image-20220402105638986"></p><p>可以看到三个服务都正常注册了，接着我们去访问图书服务：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0v6yoo6hbj226g0jkjsy.jpg" alt="image-20220402105803658"></p><p>可以看到，访问失败，直接把我们给重定向到登陆页面了，也就是说必须登陆之后才能访问，同样的方式去访问其他服务，也是一样的效果。</p><p>由于现在是统一Session存储，那么我们就可以在任意一个服务登录之后，其他服务都可以正常访问，现在我们在当前页面登录，登录之后可以看到图书服务能够正常访问了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0v73kpsaaj219u06a0tg.jpg" alt="image-20220402110245827"></p><p>同时用户服务也能正常访问了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0v74bgewzj216m06874r.jpg" alt="image-20220402110328674"></p><p>我们可以查看一下Redis服务器中是不是存储了我们的Session信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0v754p9ihj20z8048aax.jpg" alt="image-20220402110416031"></p><p>虽然看起来好像确实没啥问题了，但是借阅服务炸了，我们来看看为什么：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0v768pgt2j21sk096q7k.jpg" alt="image-20220402110519893"></p><p>在RestTemplate进行远程调用的时候，由于我们的请求没有携带对应SESSION的Cookie，所以导致验证失败，访问不成功，返回401，所以虽然这种方案看起来比较合理，但是在我们的实际使用中，还是存在一些不便的。</p><hr><h2 id="OAuth-2-0-实现单点登录"><a href="#OAuth-2-0-实现单点登录" class="headerlink" title="OAuth 2.0 实现单点登录"></a>OAuth 2.0 实现单点登录</h2><p><strong>注意：</strong>第一次接触可能会比较难，不太好理解，需要多实践和观察。</p><p>前面我们虽然使用了统一存储来解决Session共享问题，但是我们发现就算实现了Session共享，依然存在一些问题，由于我们每个服务都有自己的验证模块，实际上整个系统是存在冗余功能的、同时还有我们上面出现的问题，那么能否实现只在一个服务进行登录，就可以访问其他的服务呢？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h12or8uglrj21s20gawh8.jpg" alt="image-20220408223238760"></p><p>实际上之前的登录模式称为多点登录，而我们希望的是实现单点登陆，因此，我们得找一个更好的解决方案。</p><p>这里我们首先需要了解一种全新的登录方式：<strong>OAuth 2.0</strong>，我们经常看到一些网站支持第三方登录，比如淘宝、咸鱼我们就可以使用支付宝进行登录，腾讯游戏可以用QQ或是微信登陆，以及微信小程序都可以直接使用微信进行登录。我们知道它们并不是属于同一个系统，比如淘宝和咸鱼都不属于支付宝这个应用，但是由于需要获取支付宝的用户信息，这时我们就需要使用 OAuth2.0 来实现第三方授权，基于第三方应用访问用户信息的权限（本质上就是给别人调用自己服务接口的权限），那么它是如何实现的呢？</p><h3 id="四种授权模式"><a href="#四种授权模式" class="headerlink" title="四种授权模式"></a>四种授权模式</h3><p>我们还是从理论开始讲解，OAuth 2.0一共有四种授权模式：</p><ol><li><p><strong>客户端模式（Client Credentials）</strong></p><p>这是最简单的一种模式，我们可以直接向验证服务器请求一个Token（这里可能有些小伙伴对Token的概念不是很熟悉，Token相当于是一个令牌，我们需要在验证服务器<strong>（User Account And Authentication）</strong>服务拿到令牌之后，才能去访问资源，比如用户信息、借阅信息等，这样资源服务器才能知道我们是谁以及是否成功登录了）</p><p>当然，这里的前端页面只是一个例子，它还可以是其他任何类型的<strong>客户端</strong>，比如App、小程序甚至是第三方应用的服务。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h13srxpu4pj21720940tz.jpg" alt="image-20220409213716233"></p><p>虽然这种模式比较简便，但是已经失去了用户验证的意义，压根就不是给用户校验准备的，而是更适用于服务内部调用的场景。</p></li><li><p><strong>密码模式（Resource Owner Password Credentials）</strong></p><p>密码模式相比客户端模式，就多了用户名和密码的信息，用户需要提供对应账号的用户名和密码，才能获取到Token。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h13srezf2xj218k09c0u6.jpg" alt="image-20220409213646255"></p><p>虽然这样看起来比较合理，但是会直接将账号和密码泄露给客户端，需要后台完全信任客户端不会拿账号密码去干其他坏事，所以这也不是我们常见的。</p></li><li><p><strong>隐式授权模式（Implicit Grant）</strong></p><p>首先用户访问页面时，会重定向到认证服务器，接着认证服务器给用户一个认证页面，等待用户授权，用户填写信息完成授权后，认证服务器返回Token。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h13s7a0nxzj21ey0da0uw.jpg" alt="image-20220409211722092"></p><p>它适用于没有服务端的第三方应用页面，并且相比前面一种形式，验证都是在验证服务器进行的，敏感信息不会轻易泄露，但是Token依然存在泄露的风险。</p></li><li><p><strong>授权码模式（Authrization Code）</strong></p><p>这种模式是最安全的一种模式，也是推荐使用的一种，比如我们手机上的很多App都是使用的这种模式。</p><p>相比隐式授权模式，它并不会直接返回Token，而是返回授权码，真正的Token是通过应用服务器访问验证服务器获得的。在一开始的时候，应用服务器（客户端通过访问自己的应用服务器来进而访问其他服务）和验证服务器之间会共享一个<code>secret</code>，这个东西没有其他人知道，而验证服务器在用户验证完成之后，会返回一个授权码，应用服务器最后将授权码和<code>secret</code>一起交给验证服务器进行验证，并且Token也是在服务端之间传递，不会直接给到客户端。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h13ue89sjxj21dg0fq40y.jpg" alt="image-20220409223317823"></p><p>这样就算有人中途窃取了授权码，也毫无意义，因为，Token的获取必须同时携带授权码和secret，但是<code>secret</code>第三方是无法得知的，并且Token不会直接丢给客户端，大大减少了泄露的风险。</p></li></ol><p>但是乍一看，OAuth 2.0不应该是那种第三方应用为了请求我们的服务而使用的吗，而我们这里需要的只是实现同一个应用内部服务之间的认证，其实我也可以利用 OAuth2.0 来实现单点登录，只是少了资源服务器这一角色，客户端就是我们的整个系统，接下来就让我们来实现一下。</p><h3 id="搭建验证服务器"><a href="#搭建验证服务器" class="headerlink" title="搭建验证服务器"></a>搭建验证服务器</h3><p>第一步就是最重要的，我们需要搭建一个验证服务器，它是我们进行权限校验的核心，验证服务器有很多的第三方实现也有Spring官方提供的实现，这里我们使用Spring官方提供的验证服务器。</p><p>这里我们将最开始保存好的项目解压，就重新创建一个新的项目，首先我们在父项目中添加最新的SpringCloud依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着创建一个新的模块<code>auth-service</code>，添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--  OAuth2.0依赖，不再内置了，所以得我们自己指定一下版本  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们修改一下配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span><br>  <span class="hljs-attr">servlet:</span><br>  <span class="hljs-comment">#为了防止一会在服务之间跳转导致Cookie打架（因为所有服务地址都是localhost，都会存JSESSIONID）</span><br>  <span class="hljs-comment">#这里修改一下context-path，这样保存的Cookie会使用指定的路径，就不会和其他服务打架了</span><br>  <span class="hljs-comment">#但是注意之后的请求都得在最前面加上这个路径</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/sso</span><br></code></pre></td></tr></table></figure><p>接着我们需要编写一下配置类，这里需要两个配置类，一个是OAuth2的配置类，还有一个是SpringSecurity的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http<br>                .authorizeRequests()<br>                .anyRequest().authenticated()  <span class="hljs-comment">//</span><br>                .and()<br>                .formLogin().permitAll();    <span class="hljs-comment">//使用表单登录</span><br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BCryptPasswordEncoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();<br>        auth<br>                .inMemoryAuthentication()   <span class="hljs-comment">//直接创建一个用户，懒得搞数据库了</span><br>                .passwordEncoder(encoder)<br>                .withUser(<span class="hljs-string">&quot;test&quot;</span>).password(encoder.encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;USER&quot;</span>);<br>    &#125;<br>  <br>  <span class="hljs-meta">@Bean</span>   <span class="hljs-comment">//这里需要将AuthenticationManager注册为Bean，在OAuth配置中使用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title function_">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.authenticationManagerBean();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAuthorizationServer</span>   <span class="hljs-comment">//开启验证服务器</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OAuth2Configuration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AuthorizationServerConfigurerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AuthenticationManager manager;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BCryptPasswordEncoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这个方法是对客户端进行配置，一个验证服务器可以预设很多个客户端，</span><br><span class="hljs-comment">     * 之后这些指定的客户端就可以按照下面指定的方式进行验证</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clients 客户端配置工具</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        clients<br>                .inMemory()   <span class="hljs-comment">//这里我们直接硬编码创建，当然也可以像Security那样自定义或是使用JDBC从数据库读取</span><br>                .withClient(<span class="hljs-string">&quot;web&quot;</span>)   <span class="hljs-comment">//客户端名称，随便起就行</span><br>                .secret(encoder.encode(<span class="hljs-string">&quot;654321&quot;</span>))      <span class="hljs-comment">//只与客户端分享的secret，随便写，但是注意要加密</span><br>                .autoApprove(<span class="hljs-literal">false</span>)    <span class="hljs-comment">//自动审批，这里关闭，要的就是一会体验那种感觉</span><br>                .scopes(<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;borrow&quot;</span>)     <span class="hljs-comment">//授权范围，这里我们使用全部all</span><br>                .authorizedGrantTypes(<span class="hljs-string">&quot;client_credentials&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;implicit&quot;</span>, <span class="hljs-string">&quot;authorization_code&quot;</span>, <span class="hljs-string">&quot;refresh_token&quot;</span>);<br>                <span class="hljs-comment">//授权模式，一共支持5种，除了之前我们介绍的四种之外，还有一个刷新Token的模式</span><br>                <span class="hljs-comment">//这里我们直接把五种都写上，方便一会实验，当然各位也可以单独只写一种一个一个进行测试</span><br>                <span class="hljs-comment">//现在我们指定的客户端就支持这五种类型的授权方式了</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> &#123;<br>        security<br>                .passwordEncoder(encoder)    <span class="hljs-comment">//编码器设定为BCryptPasswordEncoder</span><br>                .allowFormAuthenticationForClients()  <span class="hljs-comment">//允许客户端使用表单验证，一会我们POST请求中会携带表单信息</span><br>                .checkTokenAccess(<span class="hljs-string">&quot;permitAll()&quot;</span>);     <span class="hljs-comment">//允许所有的Token查询请求</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> &#123;<br>        endpoints<br>                .authenticationManager(manager);<br>        <span class="hljs-comment">//由于SpringSecurity新版本的一些底层改动，这里需要配置一下authenticationManager，才能正常使用password模式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们就可以启动服务器了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14iuwapslj220008ejx2.jpg" alt="image-20220410123941157"></p><p>然后我们使用Postman进行接口测试，首先我们从最简单的客户端模式进行测试，客户端模式只需要提供id和secret即可直接拿到Token，注意需要再添加一个grant_type来表明我们的授权方式，默认请求路径为<a href="http://localhost:8500/sso/oauth/token%EF%BC%9A">http://localhost:8500/sso/oauth/token：</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14jafpizcj21cw0eg76a.jpg" alt="image-20220410125437766"></p><p>发起请求后，可以看到我们得到了Token，它是以JSON格式给到我们的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14jehayojj21cw0am0ty.jpg" alt="image-20220410125831300"></p><p>我们还可以访问 <a href="http://localhost:8500/sso/oauth/check_token">http://localhost:8500/sso/oauth/check_token</a> 来验证我们的Token是否有效：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14ji6rg42j21bk0cgmym.jpg" alt="image-20220410130204734"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14jiieikmj21bi0ew75d.jpg" alt="image-20220410130223312"></p><p>可以看到active为true，表示我们刚刚申请到的Token是有效的。</p><p>接着我们来测试一下第二种password模式，我们还需要提供具体的用户名和密码，授权模式定义为password即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14jqelib5j21bg0fg0u9.jpg" alt="image-20220410130958929"></p><p>接着我们需要在请求头中添加Basic验证信息，这里我们直接填写id和secret即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14jooye3nj21b00d4q4n.jpg" alt="image-20220410130819980"></p><p>可以看到在请求头中自动生成了Basic验证相关内容：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14jq4t7y9j21a207s751.jpg" alt="image-20220410130942662"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14jra2ysyj21ay0bgta5.jpg" alt="image-20220410131048992"></p><p>响应成功，得到Token信息，并且这里还多出了一个refresh_token，这是用于刷新Token的，我们之后会进行讲解。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14jxemfuxj21d20fcjsq.jpg" alt="image-20220410131641887"></p><p>查询Token信息之后还可以看到登录的具体用户以及角色权限等。</p><p>接着我们来看隐式授权模式，这种模式我们需要在验证服务器上进行登录操作，而不是直接请求Token，验证登录请求地址：<a href="http://localhost:8500/sso/oauth/authorize?client_id=web&amp;response_type=token">http://localhost:8500/sso/oauth/authorize?client_id=web&amp;response_type=token</a></p><p>注意response_type一定要是token类型，这样才会直接返回Token，浏览器发起请求后，可以看到熟悉而又陌生的界面，没错，实际上这里就是使用我们之前讲解的SpringSecurity进行登陆，当然也可以配置一下记住我之类的功能，这里就不演示了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14k666r5sj22aq0js0ue.jpg" alt="image-20220410132507626"></p><p>但是登录之后我们发现出现了一个错误：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14k71g3joj21ae0a60u3.jpg" alt="image-20220410132557704"></p><p>这是因为登录成功之后，验证服务器需要将结果给回客户端，所以需要提供客户端的回调地址，这样浏览器就会被重定向到指定的回调地址并且请求中会携带Token信息，这里我们随便配置一个回调地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    clients<br>            .inMemory()<br>            .withClient(<span class="hljs-string">&quot;web&quot;</span>)<br>            .secret(encoder.encode(<span class="hljs-string">&quot;654321&quot;</span>))<br>            .autoApprove(<span class="hljs-literal">false</span>)<br>            .scopes(<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;borrow&quot;</span>)<br>            .redirectUris(<span class="hljs-string">&quot;http://localhost:8201/login&quot;</span>)   <span class="hljs-comment">//可以写多个，当有多个时需要在验证请求中指定使用哪个地址进行回调</span><br>            .authorizedGrantTypes(<span class="hljs-string">&quot;client_credentials&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;implicit&quot;</span>, <span class="hljs-string">&quot;authorization_code&quot;</span>, <span class="hljs-string">&quot;refresh_token&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着重启验证服务器，再次访问：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14kaonj56j21fw0gw40h.jpg" alt="image-20220410132927907"></p><p>可以看到这里会让我们选择哪些范围进行授权，就像我们在微信小程序中登陆一样，会让我们授予用户信息权限、支付权限、信用查询权限等，我们可以自由决定要不要给客户端授予访问这些资源的权限，这里我们全部选择授予：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14kcehaeej21ye08o758.jpg" alt="image-20220410133106639"></p><p>授予之后，可以看到浏览器被重定向到我们刚刚指定的回调地址中，并且携带了Token信息，现在我们来校验一下看看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14kdhpibjj21d00e675i.jpg" alt="image-20220410133210183"></p><p>可以看到，Token也是有效的。</p><p>最后我们来看看第四种最安全的授权码模式，这种模式其实流程和上面是一样的，但是请求的是code类型：<a href="http://localhost:8500/sso/oauth/authorize?client_id=web&amp;response_type=code">http://localhost:8500/sso/oauth/authorize?client_id=web&amp;response_type=code</a></p><p>可以看到访问之后，依然会进入到回调地址，但是这时给的就是授权码了，而不是直接给Token，那么这个Token该怎么获取呢？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14kflls50j2178066glw.jpg" alt="image-20220410133411554"></p><p>按照我们之前讲解的原理，我们需要携带授权码和secret一起请求，才能拿到Token，正常情况下是由回调的服务器进行处理，这里我们就在Postman中进行，我们复制刚刚得到的授权码，接口依然是<code>localhost:8500/sso/oauth/token</code>：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14kike171j21ba0f8404.jpg" alt="image-20220410133702534"></p><p>可以看到结果也是正常返回了Token信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14klb6srtj21be0bmgn6.jpg" alt="image-20220410133940312"></p><p>这样我们四种最基本的Token请求方式就实现了。</p><p>最后还有一个是刷新令牌使用的，当我们的Token过期时，我们就可以使用这个refresh_token来申请一个新的Token：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14lesf7waj21bc0giq4u.jpg" alt="image-20220410140759967"></p><p>但是执行之后我们发现会直接出现一个内部错误：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14lf5oqckj217804mt8w.jpg" alt="image-20220410140822286"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14lffhh02j21w601qmy6.jpg" alt="image-20220410140838064"></p><p>查看日志发现，这里还需要我们单独配置一个UserDetailsService，我们直接把Security中的实例注册为Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title function_">userDetailsServiceBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.userDetailsServiceBean();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在Endpoint中设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>UserDetailsService service;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> &#123;<br>    endpoints<br>            .userDetailsService(service)<br>            .authenticationManager(manager);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再次尝试刷新Token：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14linq3lkj21bc0bumyp.jpg" alt="image-20220410141143519"></p><p>OK，成功刷新Token，返回了一个新的。</p><h3 id="基于-EnableOAuth2Sso实现"><a href="#基于-EnableOAuth2Sso实现" class="headerlink" title="基于@EnableOAuth2Sso实现"></a>基于@EnableOAuth2Sso实现</h3><p>前面我们将验证服务器已经搭建完成了，现在我们就来实现一下单点登陆吧，SpringCloud为我们提供了客户端的直接实现，我们只需要添加一个注解和少量配置即可将我们的服务作为一个单点登陆应用，使用的是第四种授权码模式。</p><p>一句话来说就是，这种模式只是将验证方式由原本的默认登录形式改变为了统一在授权服务器登陆的形式。</p><p>首先还是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们只需要直接在启动类上添加即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableOAuth2Sso</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(BookApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们不需要进行额外的配置类，因为这个注解已经帮我们做了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@EnableOAuth2Client</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;OAuth2SsoProperties.class&#125;)</span><br><span class="hljs-meta">@Import(&#123;OAuth2SsoDefaultConfiguration.class, OAuth2SsoCustomConfiguration.class, ResourceServerTokenServicesConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableOAuth2Sso &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它直接注册了OAuth2SsoDefaultConfiguration，而这个类就是帮助我们对Security进行配置的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Conditional(&#123;NeedsWebSecurityCondition.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OAuth2SsoDefaultConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>  <span class="hljs-comment">//直接继承的WebSecurityConfigurerAdapter，帮我们把验证设置都写好了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OAuth2SsoDefaultConfiguration</span><span class="hljs-params">(ApplicationContext applicationContext)</span> &#123;<br>        <span class="hljs-built_in">this</span>.applicationContext = applicationContext;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接着我们需要在配置文件中配置我们的验证服务器相关信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">security:</span><br>  <span class="hljs-attr">oauth2:</span><br>    <span class="hljs-attr">client:</span><br>      <span class="hljs-comment">#不多说了</span><br>      <span class="hljs-attr">client-id:</span> <span class="hljs-string">web</span><br>      <span class="hljs-attr">client-secret:</span> <span class="hljs-number">654321</span><br>      <span class="hljs-comment">#Token获取地址</span><br>      <span class="hljs-attr">access-token-uri:</span> <span class="hljs-string">http://localhost:8500/sso/oauth/token</span><br>      <span class="hljs-comment">#验证页面地址</span><br>      <span class="hljs-attr">user-authorization-uri:</span> <span class="hljs-string">http://localhost:8500/sso/oauth/authorize</span><br>    <span class="hljs-attr">resource:</span><br>      <span class="hljs-comment">#Token信息获取和校验地址</span><br>      <span class="hljs-attr">token-info-uri:</span> <span class="hljs-string">http://localhost:8500/sso/oauth/check_token</span><br></code></pre></td></tr></table></figure><p>现在我们就开启图书服务，调用图书接口：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14mj9etfuj22730u0q8o.jpg" alt="image-20220410144654362"></p><p>可以看到在发现没有登录验证时，会直接跳转到授权页面，进行授权登录，之后才可以继续访问图书服务：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14mkinbbyj219806mjs1.jpg" alt="image-20220410144806506"></p><p>那么用户信息呢？是否也一并保存过来了？我们这里直接获取一下SpringSecurity的Context查看用户信息，获取方式跟我们之前的视频中讲解的是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>Book <span class="hljs-title function_">findBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>&#123;<br>  <span class="hljs-comment">//通过SecurityContextHolder将用户信息取出</span><br>    <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SecurityContextHolder.getContext();<br>    System.out.println(context.getAuthentication());<br>    <span class="hljs-keyword">return</span> service.getBookById(bid);<br>&#125;<br></code></pre></td></tr></table></figure><p>再次访问图书管理接口，可以看到：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14moza8zuj220k01adge.jpg" alt="image-20220410145224153"></p><p>这里使用的不是之前的UsernamePasswordAuthenticationToken也不是RememberMeAuthenticationToken，而是新的OAuth2Authentication，它保存了验证服务器的一些信息，以及经过我们之前的登陆流程之后，验证服务器发放给客户端的Token信息，并通过Token信息在验证服务器进行验证获取用户信息，最后保存到Session中，表示用户已验证，所以本质上还是要依赖浏览器存Cookie的。</p><p>接下来我们将所有的服务都使用这种方式进行验证，别忘了把重定向地址给所有服务都加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    clients<br>            .inMemory()<br>            .withClient(<span class="hljs-string">&quot;web&quot;</span>)<br>            .secret(encoder.encode(<span class="hljs-string">&quot;654321&quot;</span>))<br>            .autoApprove(<span class="hljs-literal">true</span>)   <span class="hljs-comment">//这里把自动审批开了，就不用再去手动选同意了</span><br>            .scopes(<span class="hljs-string">&quot;book&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;borrow&quot;</span>)<br>            .redirectUris(<span class="hljs-string">&quot;http://localhost:8101/login&quot;</span>, <span class="hljs-string">&quot;http://localhost:8201/login&quot;</span>, <span class="hljs-string">&quot;http://localhost:8301/login&quot;</span>)<br>            .authorizedGrantTypes(<span class="hljs-string">&quot;client_credentials&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;implicit&quot;</span>, <span class="hljs-string">&quot;authorization_code&quot;</span>, <span class="hljs-string">&quot;refresh_token&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以实现只在验证服务器登陆，如果登陆过其他的服务都可以访问了。</p><p>但是我们发现一个问题，就是由于SESSION不同步，每次切换不同的服务进行访问都会重新导验证服务器去验证一次：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14oue66ytj212606wq42.jpg" alt="image-20220410160648326"></p><p>这里有两个方案：</p><ul><li>像之前一样做SESSION统一存储</li><li>设置context-path路径，每个服务单独设置，就不会打架了</li></ul><p>但是这样依然没法解决服务间调用的问题，所以仅仅依靠单点登陆的模式不太行。</p><h3 id="基于-EnableResourceServer实现"><a href="#基于-EnableResourceServer实现" class="headerlink" title="基于@EnableResourceServer实现"></a>基于@EnableResourceServer实现</h3><p>前面我们讲解了将我们的服务作为单点登陆应用直接实现单点登陆，那么现在我们如果是以第三方应用进行访问呢？这时我们就需要将我们的服务作为资源服务了，作为资源服务就不会再提供验证的过程，而是直接要求请求时携带Token，而验证过程我们这里就继续用Postman来完成，这才是我们常见的模式。</p><p>一句话来说，跟上面相比，我们只需要携带Token就能访问这些资源服务器了，客户端被独立了出来，用于携带Token去访问这些服务。</p><p>我们也只需要添加一个注解和少量配置即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableResourceServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(BookApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置中只需要：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">security:</span><br>  <span class="hljs-attr">oauth2:</span><br>    <span class="hljs-attr">client:</span><br>    <span class="hljs-comment">#基操</span><br>      <span class="hljs-attr">client-id:</span> <span class="hljs-string">web</span><br>      <span class="hljs-attr">client-secret:</span> <span class="hljs-number">654321</span><br>    <span class="hljs-attr">resource:</span><br>    <span class="hljs-comment">#因为资源服务器得验证你的Token是否有访问此资源的权限以及用户信息，所以只需要一个验证地址</span><br>      <span class="hljs-attr">token-info-uri:</span> <span class="hljs-string">http://localhost:8500/sso/oauth/check_token</span><br></code></pre></td></tr></table></figure><p>配置完成后，我们启动服务器，直接访问会发现：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15iekw720j21mw0b0mz5.jpg" alt="image-20220411090932561"></p><p>这是由于我们的请求头中没有携带Token信息，现在有两种方式可以访问此资源：</p><ul><li>在URL后面添加<code>access_token</code>请求参数，值为Token值</li><li>在请求头中添加<code>Authorization</code>，值为<code>Bearer +Token值</code></li></ul><p>我们先来试试看最简的一种：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15ii54emij2176066wfi.jpg" alt="image-20220411091259795"></p><p>另一种我们需要使用Postman来完成：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15ikgy886j21c60ikjty.jpg" alt="image-20220411091514501"></p><p>添加验证信息后，会帮助我们转换成请求头信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15im8lcwuj21b008cwfo.jpg" alt="image-20220411091655947"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15imovn8jj216m056aaa.jpg" alt="image-20220411091722652"></p><p>这样我们就将资源服务器搭建完成了。</p><p>我们接着来看如何对资源服务器进行深度自定义，我们可以为其编写一个配置类，比如我们现在希望用户授权了某个Scope才可以访问此服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ResourceServerConfigurerAdapter</span> &#123; <span class="hljs-comment">//继承此类进行高度自定义</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <span class="hljs-comment">//这里也有HttpSecurity对象，方便我们配置SpringSecurity</span><br>        http<br>                .authorizeRequests()<br>                .anyRequest().access(<span class="hljs-string">&quot;#oauth2.hasScope(&#x27;lbwnb&#x27;)&quot;</span>);  <span class="hljs-comment">//添加自定义规则</span><br>      <span class="hljs-comment">//Token必须要有我们自定义scope授权才可以访问此资源</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到当没有对应的scope授权时，那么会直接返回<code>insufficient_scope</code>错误：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15iynrm44j21d00acjth.jpg" alt="image-20220411092852367"></p><p>不知道各位是否有发现，实际上资源服务器完全没有必要将Security的信息保存在Session中了，因为现在只需要将Token告诉资源服务器，那么资源服务器就可以联系验证服务器，得到用户信息，就不需要使用之前的Session存储机制了，所以你会发现HttpSession中没有<strong>SPRING_SECURITY_CONTEXT</strong>，现在Security信息都是通过连接资源服务器获取。</p><p>接着我们将所有的服务都</p><p>但是还有一个问题没有解决，我们在使用RestTemplate进行服务间的远程调用时，会得到以下错误：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15nbvmhyqj21zo070n12.jpg" alt="image-20220411115958560"></p><p>实际上这是因为在服务调用时没有携带Token信息，我们得想个办法把用户传来的Token信息在进行远程调用时也携带上，因此，我们可以直接使用OAuth2RestTemplate，它会在请求其他服务时携带当前请求的Token信息。它继承自RestTemplate，这里我们直接定义一个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    OAuth2ClientContext context;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OAuth2RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OAuth2RestTemplate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientCredentialsResourceDetails</span>(), context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们直接替换掉之前的RestTemplate即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Resource</span><br>    OAuth2RestTemplate template;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.getForObject(<span class="hljs-string">&quot;http://localhost:8101/user/&quot;</span>+uid, User.class);<br>        <span class="hljs-comment">//获取每一本书的详细信息</span><br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; template.getForObject(<span class="hljs-string">&quot;http://localhost:8201/book/&quot;</span>+b.getBid(), Book.class))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到服务成功调用了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15omvqe0nj21im06emyf.jpg" alt="image-20220411124509007"></p><p>现在我们来将Nacos加入，并通过Feign实现远程调用。</p><p>依赖还是贴一下，不然找不到：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>所有服务都已经注册成功了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15pvei9c9j220w0cgdia.jpg" alt="image-20220411132756540"></p><p>接着我们配置一下借阅服务的负载均衡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    OAuth2ClientContext context;<br><br>    <span class="hljs-meta">@LoadBalanced</span>   <span class="hljs-comment">//和RestTemplate一样直接添加注解就行了</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OAuth2RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OAuth2RestTemplate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientCredentialsResourceDetails</span>(), context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15q67k904j21ho06a75k.jpg" alt="image-20220411133819847"></p><p>现在我们来把它替换为Feign，老样子，两个客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;user-service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;book-service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookClient</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是配置完成之后，又出现刚刚的问题了，OpenFeign也没有携带Token进行访问：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15qotlr59j21zq06s77b.jpg" alt="image-20220411135612728"></p><p>那么怎么配置Feign携带Token访问呢？遇到这种问题直接去官方查：<a href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#oauth2-support%EF%BC%8C%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%EF%BC%8C%E4%B8%A4%E4%B8%AA%E9%85%8D%E7%BD%AE%E5%B0%B1%E6%90%9E%E5%AE%9A%EF%BC%9A">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#oauth2-support，非常简单，两个配置就搞定：</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">oauth2:</span><br>  <span class="hljs-comment">#开启Oauth支持，这样就会在请求头中携带Token了</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#同时开启负载均衡支持</span><br>    <span class="hljs-attr">load-balanced:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>重启服务器，可以看到结果OK了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h15rupqldmj21ko07kmyl.jpg" alt="image-20220411143628451"></p><p>这样我们就成功将之前的三个服务作为资源服务器了，注意和我们上面的作为客户端是不同的，将服务直接作为客户端相当于只需要验证通过即可，并且还是要保存Session信息，相当于只是将登录流程换到统一的验证服务器上进行罢了。而将其作为资源服务器，那么就需要另外找客户端（可以是浏览器、小程序、App、第三方服务等）来访问，并且也是需要先进行验证然后再通过携带Token进行访问，这种模式是我们比较常见的模式。</p><h3 id="使用jwt存储Token"><a href="#使用jwt存储Token" class="headerlink" title="使用jwt存储Token"></a>使用jwt存储Token</h3><p>官网：<a href="https://jwt.io/">https://jwt.io</a></p><p>JSON Web Token令牌（JWT）是一个开放标准（<a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>），它定义了一种紧凑和自成一体的方式，用于在各方之间作为JSON对象安全地传输信息。这些信息可以被验证和信任，因为它是数字签名的。JWT可以使用密钥（使用<strong>HMAC</strong>算法）或使用<strong>RSA</strong>或<strong>ECDSA</strong>进行公钥&#x2F;私钥对进行签名。</p><p>实际上，我们之前都是携带Token向资源服务器发起请求后，资源服务器由于不知道我们Token的用户信息，所以需要向验证服务器询问此Token的认证信息，这样才能得到Token代表的用户信息，但是各位是否考虑过，如果每次用户请求都去查询用户信息，那么在大量请求下，验证服务器的压力可能会非常的大。而使用JWT之后，Token中会直接保存用户信息，这样资源服务器就不再需要询问验证服务器，自行就可以完成解析，我们的目标是不联系验证服务器就能直接完成验证。</p><p>JWT令牌的格式如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h16n64387aj22b10u0wjb.jpg" alt="image-20220412083957167"></p><p>一个JWT令牌由3部分组成：标头(Header)、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的3部分分别进行Base64编码后用<code>.</code>进行连接形成最终需要传输的字符串。</p><ul><li>标头：包含一些元数据信息，比如JWT签名所使用的加密算法，还有类型，这里统一都是JWT。</li><li>有效载荷：包括用户名称、令牌发布时间、过期时间、JWT ID等，当然我们也可以自定义添加字段，我们的用户信息一般都在这里存放。</li><li>签名：首先需要指定一个密钥，该密钥仅仅保存在服务器中，保证不能让其他用户知道。然后使用Header中指定的算法对Header和Payload进行base64加密之后的结果通过密钥计算哈希值，然后就得出一个签名哈希。这个会用于之后验证内容是否被篡改。</li></ul><p>这里还是补充一下一些概念，因为很多东西都是我们之前没有接触过的：</p><ul><li><p><strong>Base64：</strong>就是包括小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”&#x2F;“一共64个字符的字符集（末尾还有1个或多个<code>=</code>用来凑够字节数），任何的符号都可以转换成这个字符集中的字符，这个转换过程就叫做Base64编码，编码之后会生成只包含上述64个字符的字符串。相反，如果需要原本的内容，我们也可以进行Base64解码，回到原有的样子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你们可能不知道只用20万赢到578万是什么概念&quot;</span>;<br>  <span class="hljs-comment">//Base64不只是可以对字符串进行编码，任何byte[]数据都可以，编码结果可以是byte[]，也可以是字符串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">encodeStr</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(str.getBytes());<br>    System.out.println(<span class="hljs-string">&quot;Base64编码后的字符串：&quot;</span>+encodeStr);<br><br>    System.out.println(<span class="hljs-string">&quot;解码后的字符串：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Base64.getDecoder().decode(encodeStr)));<br>&#125;<br></code></pre></td></tr></table></figure><p>注意Base64不是加密算法，只是一种信息的编码方式而已。</p></li><li><p><strong>加密算法：</strong>加密算法分为对称加密和非对称加密，其中<strong>对称加密（Symmetric Cryptography）</strong>比较好理解，就像一把锁配了两把钥匙一样，这两把钥匙你和别人都有一把，然后你们直接传递数据，都会把数据用锁给锁上，就算传递的途中有人把数据窃取了，也没办法解密，因为钥匙只有你和对方有，没有钥匙无法进行解密，但是这样有个问题，既然解密的关键在于钥匙本身，那么如果有人不仅窃取了数据，而且对方那边的治安也不好，于是顺手就偷走了钥匙，那你们之间发的数据不就凉凉了吗。</p><p>因此，<strong>非对称加密（Asymmetric Cryptography）</strong>算法出现了，它并不是直接生成一把钥匙，而是生成一个公钥和一个私钥，私钥只能由你保管，而公钥交给对方或是你要发送的任何人都行，现在你需要把数据传给对方，那么就需要使用私钥进行加密，但是，这个数据只能使用对应的公钥进行解密，相反，如果对方需要给你发送数据，那么就需要用公钥进行加密，而数据只能使用私钥进行解密，这样的话就算对方的公钥被窃取，那么别人发给你的数据也没办法解密出来，因为需要私钥才能解密，而只有你才有私钥。</p><p>因此，非对称加密的安全性会更高一些，包括HTTPS的隐私信息正是使用非对称加密来保障传输数据的安全（当然HTTPS并不是单纯地使用非对称加密完成的，感兴趣的可以去了解一下）</p><p>对称加密和非对称加密都有很多的算法，比如对称加密，就有：DES、IDEA、RC2，非对称加密有：RSA、DAS、ECC</p></li><li><p><strong>不可逆加密算法：</strong>常见的不可逆加密算法有MD5, HMAC, SHA-1, SHA-224, SHA-256, SHA-384, 和SHA-512, 其中SHA-224、SHA-256、SHA-384，和SHA-512我们可以统称为SHA2加密算法，SHA加密算法的安全性要比MD5更高，而SHA2加密算法比SHA1的要高，其中SHA后面的数字表示的是加密后的字符串长度，SHA1默认会产生一个160位的信息摘要。经过不可逆加密算法得到的加密结果，是无法解密回去的，也就是说加密出来是什么就是什么了。本质上，其就是一种哈希函数，用于对一段信息产生摘要，以<strong>防止被篡改</strong>。</p><p>实际上这种算法就常常被用作信息摘要计算，同样的数据通过同样的算法计算得到的结果肯定也一样，而如果数据被修改，那么计算的结果肯定就不一样了。</p></li></ul><p>这里我们就可以利用jwt，将我们的Token采用新的方式进行存储：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h16s4h08b9j21ku0dumz4.jpg" alt="image-20220412113124880"></p><p>这里我们使用最简单的一种方式，对称密钥，我们需要对验证服务器进行一些修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> JwtAccessTokenConverter <span class="hljs-title function_">tokenConverter</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">//Token转换器，将其转换为JWT</span><br>    <span class="hljs-type">JwtAccessTokenConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JwtAccessTokenConverter</span>();<br>    converter.setSigningKey(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//这个是对称密钥，一会资源服务器那边也要指定为这个</span><br>    <span class="hljs-keyword">return</span> converter;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> TokenStore <span class="hljs-title function_">tokenStore</span><span class="hljs-params">(JwtAccessTokenConverter converter)</span>&#123;  <span class="hljs-comment">//Token存储方式现在改为JWT存储</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JwtTokenStore</span>(converter);  <span class="hljs-comment">//传入刚刚定义好的转换器</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>TokenStore store;<br><br><span class="hljs-meta">@Resource</span><br>JwtAccessTokenConverter converter;<br><br><span class="hljs-keyword">private</span> AuthorizationServerTokenServices <span class="hljs-title function_">serverTokenServices</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">//这里对AuthorizationServerTokenServices进行一下配置</span><br>    <span class="hljs-type">DefaultTokenServices</span> <span class="hljs-variable">services</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTokenServices</span>();<br>    services.setSupportRefreshToken(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//允许Token刷新</span><br>    services.setTokenStore(store);   <span class="hljs-comment">//添加刚刚的TokenStore</span><br>    services.setTokenEnhancer(converter);   <span class="hljs-comment">//添加Token增强，其实就是JwtAccessTokenConverter，增强是添加一些自定义的数据到JWT中</span><br>    <span class="hljs-keyword">return</span> services;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> &#123;<br>    endpoints<br>            .tokenServices(serverTokenServices())   <span class="hljs-comment">//设定为刚刚配置好的AuthorizationServerTokenServices</span><br>            .userDetailsService(service)<br>            .authenticationManager(manager);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们就可以重启验证服务器了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h16sxi8zk7j21c20dkdjy.jpg" alt="image-20220412115919019"></p><p>可以看到成功获取了AccessToken，但是这里的格式跟我们之前的格式就大不相同了，因为现在它是JWT令牌，我们可以对其进行一下Base64解码：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h16szvyek8j22om0dsmzi.jpg" alt="image-20220412120136453"></p><p>可以看到所有的验证信息包含在内，现在我们对资源服务器进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">security:</span><br>  <span class="hljs-attr">oauth2:</span><br>    <span class="hljs-attr">resource:</span><br>      <span class="hljs-attr">jwt:</span><br>        <span class="hljs-attr">key-value:</span> <span class="hljs-string">lbwnb</span> <span class="hljs-comment">#注意这里要跟验证服务器的密钥一致，这样算出来的签名才会一致</span><br></code></pre></td></tr></table></figure><p>然后启动资源服务器，请求一下接口试试看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h16t27q8g1j21b60foacd.jpg" alt="image-20220412120350331"></p><p>请求成功，得到数据：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h16t2o2neej21ca08074t.jpg" alt="image-20220412120417005"></p><p>注意如果Token有误，那么会得到：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h16t33dv9kj215m04uaab.jpg" alt="image-20220412120441794"></p><hr><h2 id="Redis与分布式"><a href="#Redis与分布式" class="headerlink" title="Redis与分布式"></a>Redis与分布式</h2><p>在SpringBoot阶段，我们学习了Redis，它是一个基于内存的高性能数据库，我们当时已经学习了包括基本操作、常用数据类型、持久化、事务和锁机制以及使用Java与Redis进行交互等，利用它的高性能，我们还使用它来做Mybatis的二级缓存、以及Token的持久化存储。而这一部分，我们将继续深入，探讨Redis在分布式开发场景下的应用。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>在分布式场景下，我们可以考虑让Redis实现主从模式：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h170fqh9k0j21ao07gwf9.jpg" alt="image-20220412161901616"></p><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(Master)，后者称为从节点(Slave)，数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。</p><p>这样的好处肯定是显而易见的：</p><ul><li>实现了读写分离，提高了性能。</li><li>在写少读多的场景下，我们甚至可以安排很多个从节点，这样就能够大幅度的分担压力，并且就算挂掉一个，其他的也能使用。</li></ul><p>那么我们现在就来尝试实现一下，这里我们还是在Windows下进行测试，打开Redis文件夹，我们要开启两个Redis服务器，修改配置文件<code>redis.windows.conf</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf"># Accept connections on the specified port, default is 6379 (IANA #815344).<br># If port 0 is specified Redis will not listen on a TCP socket.<br>port 6001<br></code></pre></td></tr></table></figure><p>一个服务器的端口设定为6001，复制一份，另一个的端口为6002，接着我们指定配置文件进行启动，打开cmd：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17ycpqc7aj21ho0iytcq.jpg" alt="image-20220413115227344"></p><p>现在我们的两个服务器就启动成功了，接着我们可以使用命令查看当前服务器的主从状态，我们打开客户端：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17yfaen55j21ge0d6dj4.jpg" alt="image-20220413115458597"></p><p>输入<code>info replication</code>命令来查看当前的主从状态，可以看到默认的角色为：master，也就是说所有的服务器在启动之后都是主节点的状态。那么现在我们希望让6002作为从节点，通过一个命令即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17yhstlr6j21hk0k078p.jpg" alt="image-20220413115722765"></p><p>可以看到，在输入<code>replicaof 127.0.0.1 6001</code>命令后，就会将6001服务器作为主节点，而当前节点作为6001的从节点，并且角色也会变成：slave，接着我们来看看6001的情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17ykiln90j21cq0c4tbw.jpg" alt="image-20220413115959759"></p><p>可以看到从节点信息中已经出现了6002服务器，也就是说现在我们的6001和6002就形成了主从关系（还包含一个偏移量，这个偏移量反应的是从节点的同步情况）</p><blockquote><p>主服务器和从服务器都会维护一个复制偏移量，主服务器每次向从服务器中传递 N 个字节的时候，会将自己的复制偏移量加上 N。从服务器中收到主服务器的 N 个字节的数据，就会将自己额复制偏移量加上 N，通过主从服务器的偏移量对比可以很清楚的知道主从服务器的数据是否处于一致，如果不一致就需要进行增量同步了。</p></blockquote><p>那么我们现在可以来测试一下，在主节点新增数据，看看是否会同步到从节点：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17ym5549oj219w06kjs4.jpg" alt="image-20220413120133934"></p><p>可以看到，我们在6001服务器插入的<code>a</code>，可以在从节点6002读取到，那么，从节点新增的数据在主节点能得到吗？我们来测试一下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17yn7gu6zj20xy0323z1.jpg" alt="image-20220413120235138"></p><p>可以看到，从节点压根就没办法进行数据插入，节点的模式为只读模式。那么如果我们现在不想让6002作为6001的从节点了呢？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17zqijbfmj21bu09s76d.jpg" alt="image-20220413124021549"></p><p>可以看到，通过输入<code>replicaof no one</code>，即可变回Master角色。接着我们再来启动一台6003服务器，流程是一样的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17yypexpij215c062gmg.jpg" alt="image-20220413121338391"></p><p>可以看到，在连接之后，也会直接同步主节点的数据，因此无论是已经处于从节点状态还是刚刚启动完成的服务器，都会从主节点同步数据，实际上整个同步流程为：</p><ol><li>从节点执行replicaof ip port命令后，从节点会保存主节点相关的地址信息。</li><li>从节点通过每秒运行的定时任务发现配置了新的主节点后，会尝试与该节点建立网络连接，专门用于接收主节点发送的复制命令。</li><li>连接成功后，第一次会将主节点的数据进行全量复制，之后采用增量复制，持续将新来的写命令同步给从节点。</li></ol><p>当我们的主节点关闭后，从节点依然可以读取数据：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17z9oo7bdj21ce0majw5.jpg" alt="image-20220413122411006"></p><p>但是从节点会疯狂报错：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17zb0v187j21he032myo.jpg" alt="image-20220413122528096"></p><p>当然每次都去敲个命令配置主从太麻烦了，我们可以直接在配置文件中配置，添加这样行即可：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">replicaof</span> <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">6001</span><br></code></pre></td></tr></table></figure><p>这里我们给6002和6003服务器都配置一下，现在我们重启三个服务器。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17zehyh4pj21hg0d6gu1.jpg" alt="image-20220413122848685"></p><p>当然，除了作为Master节点的从节点外，我们还可以将其作为从节点的从节点，比如现在我们让6003作为6002的从节点：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17zgkb251j216e09mq4n.jpg" alt="image-20220413123047711"></p><p>也就是说，现在差不多是这样的的一个情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h17zm1h2wpj21ja0ikjv0.jpg" alt="image-20220413123603650"></p><p>采用这种方式，优点肯定是显而易见的，但是缺点也很明显，整个传播链路一旦中途出现问题，那么就会导致后面的从节点无法及时同步。</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>前面我们讲解了Redis实现主从复制的一些基本操作，那么我们接着来看哨兵模式。</p><p>经过之前的学习，我们发现，实际上最关键的还是主节点，因为一旦主节点出现问题，那么整个主从系统将无法写入，因此，我们得想一个办法，处理一下主节点故障的情况。实际上我们可以参考之前的服务治理模式，比如Nacos和Eureka，所有的服务都会被实时监控，那么只要出现问题，肯定是可以及时发现的，并且能够采取响应的补救措施，这就是我们即将介绍的哨兵：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h184yisdi6j218i0dk405.jpg" alt="image-20220413154102800"></p><p>注意这里的哨兵不是我们之前学习SpringCloud Alibaba的那个，是专用于Redis的。哨兵会对所有的节点进行监控，如果发现主节点出现问题，那么会立即让从节点进行投票，选举一个新的主节点出来，这样就不会由于主节点的故障导致整个系统不可写（注意要实现这样的功能最小的系统必须是一主一从，再小的话就没有意义了）</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h185d16octj21940dawg5.jpg" alt="image-20220413155459399"></p><p>那么怎么启动一个哨兵呢？我们只需要稍微修改一下配置文件即可，这里直接删除全部内容，添加：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">sentinel<span class="hljs-built_in"> monitor </span>lbwnb 127.0.0.1 6001 1<br></code></pre></td></tr></table></figure><p>其中第一个和第二个是固定，第三个是为监控对象名称，随意，后面就是主节点的相关信息，包括IP地址和端口，最后一个1我们暂时先不说，然后我们使用此配置文件启动服务器，可以看到启动后：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h185umqg2rj21fg0maq8l.jpg" alt="image-20220413161154185"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h185vv5uuvj217e03u40p.jpg" alt="image-20220413161306103"></p><p>可以看到以哨兵模式启动后，会自动监控主节点，然后还会显示那些节点是作为从节点存在的。</p><p>现在我们直接把主节点关闭，看看会发生什么事情：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1860g13toj21hg072n1k.jpg" alt="image-20220413161730035"></p><p>可以看到从节点还是正常的在报错，一开始的时候不会直接重新进行选举而是继续尝试重连（因为有可能只是网络小卡一下，没必要这么敏感），但是我们发现，经过一段时间之后，依然无法连接，哨兵输出了以下内容：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1861pyd5uj21gs0jman3.jpg" alt="image-20220413161843439"></p><p>可以看到哨兵发现主节点已经有一段时间不可用了，那么就会开始进行重新选举，6003节点被选为了新的主节点，并且之前的主节点6001变成了新的主节点的从节点：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18665ksokj21hq05sjuu.jpg" alt="image-20220413162259056"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1866crze4j21f207kq5f.jpg" alt="image-20220413162310821"></p><p>当我们再次启动6001时，会发现，它自动变成了6003的从节点，并且会将数据同步过来：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h186j4ul8mj21gu09qq8y.jpg" alt="image-20220413163527235"></p><p>那么，这个选举规则是怎样的呢？是在所有的从节点中随机选取还是遵循某种规则呢？</p><ol><li>首先会根据优先级进行选择，可以在配置文件中进行配置，添加<code>replica-priority</code>配置项（默认是100），越小表示优先级越高。</li><li>如果优先级一样，那就选择偏移量最大的</li><li>要是还选不出来，那就选择runid（启动时随机生成的）最小的。</li></ol><p>要是哨兵也挂了咋办？没事，咱们可以多安排几个哨兵，只需要把哨兵的配置复制一下，然后修改端口，这样就可以同时启动多个哨兵了，我们启动3个哨兵（一主二从三哨兵），这里我们吧最后一个值改为<code>2</code>：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">sentinel<span class="hljs-built_in"> monitor </span>lbwnb 192.168.0.8 6001 2<br></code></pre></td></tr></table></figure><p>这个值实际上代表的是当有几个哨兵认为主节点挂掉时，就判断主节点真的挂掉了</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18csiah4ej21e60b8794.jpg" alt="image-20220413201201051"></p><p>现在我们把6001节点挂掉，看看这三个哨兵会怎么样：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18df6teykj21h60fk7d0.jpg" alt="image-20220413203351360"></p><p>可以看到都显示将master切换为6002节点了。</p><p>那么，在哨兵重新选举新的主节点之后，我们Java中的Redis的客户端怎么感知到呢？我们来看看，首先还是导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//这里我们直接使用JedisSentinelPool来获取Master节点</span><br>        <span class="hljs-comment">//需要把三个哨兵的地址都填入</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">JedisSentinelPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(<span class="hljs-string">&quot;lbwnb&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;192.168.0.8:26741&quot;</span>, <span class="hljs-string">&quot;192.168.0.8:26740&quot;</span>, <span class="hljs-string">&quot;192.168.0.8:26739&quot;</span>)))) &#123;<br>            <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> pool.getResource();   <span class="hljs-comment">//直接询问并得到Jedis对象，这就是连接的Master节点</span><br>            jedis.set(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>);    <span class="hljs-comment">//直接写入即可，实际上就是向Master节点写入</span><br><br>            <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis2</span> <span class="hljs-operator">=</span> pool.getResource();   <span class="hljs-comment">//再次获取</span><br>            System.out.println(jedis2.get(<span class="hljs-string">&quot;test&quot;</span>));   <span class="hljs-comment">//读取操作</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，Jedis对象就可以通过哨兵来获取，当Master节点更新后，也能得到最新的。</p><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p>如果我们服务器的内存不够用了，但是现在我们的Redis又需要继续存储内容，那么这个时候就可以利用集群来实现扩容。</p><p>因为单机的内存容量最大就那么多，已经没办法再继续扩展了，但是现在又需要存储更多的内容，这时我们就可以让N台机器上的Redis来分别存储各个部分的数据（每个Redis可以存储1&#x2F;N的数据量），这样就实现了容量的横向扩展。同时每台Redis还可以配一个从节点，这样就可以更好地保证数据的安全性。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18eoii8ttj21c60homz7.jpg" alt="image-20220413211725149"></p><p>那么问题来，现在用户来了一个写入的请求，数据该写到哪个节点上呢？我们来研究一下集群的机制：</p><p>首先，一个Redis集群包含16384个插槽，集群中的每个Redis 实例负责维护一部分插槽以及插槽所映射的键值数据，那么这个插槽是什么意思呢？</p><p>实际上，插槽就是键的Hash计算后的一个结果，注意这里出现了<code>计算机网络</code>中的CRC循环冗余校验，这里采用CRC16，能得到16个bit位的数据，也就是说算出来之后结果是0-65535之间，再进行取模，得到最终结果：</p><p><strong>Redis key的路由计算公式：slot &#x3D; CRC16（key） % 16384</strong></p><p>结果的值是多少，就应该存放到对应维护的Redis下，比如Redis节点1负责0-25565的插槽，而这时客户端插入了一个新的数据<code>a=10</code>，a在Hash计算后结果为666，那么a就应该存放到1号Redis节点中。简而言之，本质上就是通过哈希算法将插入的数据分摊到各个节点的，所以说哈希算法真的是处处都有用啊。</p><p>那么现在我们就来搭建一个简单的Redis集群，这里创建6个配置，注意开启集群模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span><br><span class="hljs-comment"># started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="hljs-comment"># cluster node enable the cluster support uncommenting the following:</span><br><span class="hljs-comment">#</span><br>cluster-enabled <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>接着记得把所有的持久化文件全部删除，所有的节点内容必须是空的。</p><p>然后输入<code>redis-cli.exe --cluster create --cluster-replicas 1 127.0.0.1:6001 127.0.0.1:6002 127.0.0.1:6003 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003</code>，这里的<code>--cluster-replicas 1</code>指的是每个节点配一个从节点：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18fw9o0isj21hc0mw12l.jpg" alt="image-20220413215928157"></p><p>输入之后，会为你展示客户端默认分配的方案，并且会询问你当前的方案是否合理。可以看到6001&#x2F;6002&#x2F;6003都被选为主节点，其他的为从节点，我们直接输入yes即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18fp8r1m9j21h605sabp.jpg" alt="image-20220413215243309"></p><p>最后分配成功，可以看到插槽的分配情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18fwsc8ecj21go0li467.jpg" alt="image-20220413215958201"></p><p>现在我们随便连接一个节点，尝试插入一个值：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18g381vqlj2122030dgk.jpg" alt="image-20220413220609800"></p><p>在插入时，出现了一个错误，实际上这就是因为a计算出来的哈希值（插槽），不归当前节点管，我们得去管这个插槽的节点执行，通过上面的分配情况，我们可以得到15495属于节点6003管理：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18g5ccyqpj20y205e3z8.jpg" alt="image-20220413220811536"></p><p>在6003节点插入成功，当然我们也可以使用集群方式连接，这样我们无论在哪个节点都可以插入，只需要添加<code>-c</code>表示以集群模式访问：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18g6stccaj216y04uwfk.jpg" alt="image-20220413220935678"></p><p>可以看到，在6001节点成功对a的值进行了更新，只不过还是被重定向到了6003节点进行插入。</p><p>我们可以输入<code>cluster nodes</code>命令来查看当前所有节点的信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18gir6s5mj21hk09mgs0.jpg" alt="image-20220413222104845"></p><p>那么现在如果我们让某一个主节点挂掉会怎么样？现在我们把6001挂掉：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18gurtemjj21h808wwkx.jpg" alt="image-20220413223237962"></p><p>可以看到原本的6001从节点7001，晋升为了新的主节点，而之前的6001已经挂了，现在我们将6001重启试试看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18gvstwbkj21hk04e76h.jpg" alt="image-20220413223337494"></p><p>可以看到6001变成了7001的从节点，那么要是6001和7001都挂了呢？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18gzd1jxzj21ha0460v0.jpg" alt="image-20220413223702884"></p><p>这时我们尝试插入新的数据：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18gzqibkqj20va03a74o.jpg" alt="image-20220413223724440"></p><p>可以看到，当存在节点不可用时，会无法插入新的数据，现在我们将6001和7001恢复：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h18h0l5pcnj21gs07a77z.jpg" alt="image-20220413223813370"></p><p>可以看到恢复之后又可以继续正常使用了。</p><p>最后我们来看一下如何使用Java连接到集群模式下的Redis，我们需要用到JedisCluster对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//和客户端一样，随便连一个就行，也可以多写几个，构造方法有很多种可以选择</span><br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">JedisCluster</span> <span class="hljs-variable">cluster</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisCluster</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HostAndPort</span>(<span class="hljs-string">&quot;192.168.0.8&quot;</span>, <span class="hljs-number">6003</span>)))&#123;<br>            System.out.println(<span class="hljs-string">&quot;集群实例数量：&quot;</span>+cluster.getClusterNodes().size());<br>            cluster.set(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;yyds&quot;</span>);<br>            System.out.println(cluster.get(<span class="hljs-string">&quot;a&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>操作基本和Jedis对象一样，这里就不多做赘述了。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在我们的传统单体应用中，经常会用到锁机制，目的是为了防止多线程竞争导致的并发问题，但是现在我们在分布式环境下，又该如何实现锁机制呢？可能一条链路上有很多的应用，它们都是独立运行的，这时我们就可以借助Redis来实现分布式锁。</p><p>还记得我们上一章最后提出的问题吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doBorrow</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> bid)</span> &#123;<br>  <span class="hljs-comment">//1. 判断图书和用户是否都支持借阅，如果此时来了10个线程，都进来了，那么都能够判断为可以借阅</span><br>    <span class="hljs-keyword">if</span>(bookClient.bookRemain(bid) &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;图书数量不足&quot;</span>);<br>    <span class="hljs-keyword">if</span>(userClient.userRemain(uid) &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户借阅量不足&quot;</span>);<br>  <span class="hljs-comment">//2. 首先将图书的数量-1，由于上面10个线程同时进来，同时判断可以借阅，那么这个10个线程就同时将图书数量-1，那库存岂不是直接变成负数了？？？</span><br>    <span class="hljs-keyword">if</span>(!bookClient.bookBorrow(bid))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;在借阅图书时出现错误！&quot;</span>);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上在高并发下，我们看似正常的借阅流程，会出现问题，比如现在同时来了10个同学要借同一本书，但是现在只有3本，而我们的判断规则是，首先看书够不够，如果此时这10个请求都已经走到这里，并且都判定为可以进行借阅，那么问题就出现了，接下来这10个请求都开始进行借阅操作，导致库存直接爆表，形成超借问题（在电商系统中也存在同样的超卖问题）</p><p>因此，为了解决这种问题，我们就可以利用分布式锁来实现。那么Redis如何去实现分布式锁呢？</p><p>在Redis存在这样一个命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">setnx key value</span><br></code></pre></td></tr></table></figure><p>这个命令看起来和<code>set</code>命令差不多，但是它有一个机制，就是只有当指定的key不存在的时候，才能进行插入，实际上就是<code>set if not exists</code>的缩写。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h192d1jdakj214q07uab5.jpg" alt="image-20220414105646460"></p><p>可以看到，当客户端1设定a之后，客户端2使用<code>setnx</code>会直接失败。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h192f9yztfj211g08i75i.jpg" alt="image-20220414105854959"></p><p>当客户端1将a删除之后，客户端2就可以使用<code>setnx</code>成功插入了。</p><p>利用这种特性，我们就可以在不同的服务中实现分布式锁，那么问题来了，要是某个服务加了锁但是卡顿了呢，或是直接崩溃了，那这把锁岂不是永远无法释放了？因此我们还可以考虑加个过期时间：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set</span> a <span class="hljs-number">666</span> EX <span class="hljs-number">5</span> NX<br></code></pre></td></tr></table></figure><p>这里使用<code>set</code>命令，最后加一个NX表示是使用<code>setnx</code>的模式，和上面是一样的，但是可以通过EX设定过期时间，这里设置为5秒，也就是说如果5秒还没释放，那么就自动删除。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h192qy0x9pj213w09ymyq.jpg" alt="image-20220414111008456"></p><p>当然，添加了过期时间，带了的好处是显而易见的，但是同时也带来了很多的麻烦，我们来设想一下这种情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1935d9f0jj21im0cydi8.jpg" alt="image-20220414112359738"></p><p>因此，单纯只是添加过期时间，会出现这种把别人加的锁谁卸了的情况，要解决这种问题也很简单，我们现在的目标就是保证任务只能删除自己加的锁，如果是别人加的锁是没有资格删的，所以我们可以吧a的值指定为我们任务专属的值，比如可以使用UUID之类的，如果在主动删除锁的时候发现值不是我们当前任务指定的，那么说明可能是因为超时，其他任务已经加锁了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h193cc7opzj21hy0da40t.jpg" alt="image-20220414113041835"></p><p>如果你在学习本篇之前完成了JUC并发编程篇的学习，那么一定会有一个疑惑，如果在超时之前那一刹那进入到释放锁的阶段，获取到值肯定还是自己，但是在即将执行删除之前，由于超时机制导致被删除并且其他任务也加锁了，那么这时再进行删除，仍然会导致删除其他任务加的锁。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h193j2b68fj21mw0d6mzv.jpg" alt="image-20220414113709773"></p><p>实际上本质还是因为锁的超时时间不太好衡量，如果超时时间能够设定地比较恰当，那么就可以避免这种问题了。</p><p>要解决这个问题，我们可以借助一下Redisson框架，它是Redis官方推荐的Java版的Redis客户端。它提供的功能非常多，也非常强大，Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期，它为我们提供了很多种分布式锁的实现，使用起来也类似我们在JUC中学习的锁，这里我们尝试使用一下它的分布式锁功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.17.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.75.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先我们来看看不加锁的情况下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span>(<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.0.10&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;   <span class="hljs-comment">//每个客户端获取a然后增加a的值再写回去，如果不加锁那么肯定会出问题</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(jedis.get(<span class="hljs-string">&quot;a&quot;</span>)) + <span class="hljs-number">1</span>;<br>                    jedis.set(<span class="hljs-string">&quot;a&quot;</span>, a+<span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里没有直接用<code>incr</code>而是我们自己进行计算，方便模拟，可以看到运行结束之后a的值并不是我们想要的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h196vkaykrj21ce022dft.jpg" alt="image-20220414133258227"></p><p>现在我们来给它加一把锁，注意这个锁是基于Redis的，不仅仅只可以用于当前应用，是能够垮系统的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>    config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.0.10:6379&quot;</span>);   <span class="hljs-comment">//配置连接的Redis服务器，也可以指定集群</span><br>    <span class="hljs-type">RedissonClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span>  Redisson.create(config);   <span class="hljs-comment">//创建RedissonClient客户端</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span>(<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.0.10&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>                <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> client.getLock(<span class="hljs-string">&quot;testLock&quot;</span>);    <span class="hljs-comment">//指定锁的名称，拿到锁对象</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;<br>                    lock.lock();    <span class="hljs-comment">//加锁</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(jedis.get(<span class="hljs-string">&quot;a&quot;</span>)) + <span class="hljs-number">1</span>;<br>                    jedis.set(<span class="hljs-string">&quot;a&quot;</span>, a+<span class="hljs-string">&quot;&quot;</span>);<br>                    lock.unlock();   <span class="hljs-comment">//解锁</span><br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;结束！&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到结果没有问题：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h196wp13naj215202caa3.jpg" alt="image-20220414133403403"></p><p>注意，如果用于存放锁的Redis服务器挂了，那么肯定是会出问题的，这个时候我们就可以使用RedLock，它的思路是，在多个Redis服务器上保存锁，只需要超过半数的Redis服务器获取到锁，那么就真的获取到锁了，这样就算挂掉一部分节点，也能保证正常运行，这里就不做演示了。</p><hr><h2 id="MySQL与分布式"><a href="#MySQL与分布式" class="headerlink" title="MySQL与分布式"></a>MySQL与分布式</h2><p>前面我讲解了Redis在分布式场景的下的相关应用，接着我们来看看MySQL数据库在分布式场景下的应用。</p><h3 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h3><p>当我们使用MySQL的时候，也可以采取主从复制的策略，它的实现思路基本和Redis相似，也是采用增量复制的方式，MySQL会在运行的过程中，会记录二进制日志，所有的DML和DDL操作都会被记录进日志中，主库只需要将记录的操作复制给从库，让从库也运行一次，那么就可以实现主从复制。但是注意它不会在一开始进行全量复制，所以最好再开始主从之前将数据库的内容保持一致。</p><p>和之前一样，一旦我们实现了主从复制，那么就算主库出现故障，从库也能正常提供服务，并且还可以实现读写分离等操作。这里我们就使用两台主机来搭建一主一从的环境，首先确保两台服务器都安装了MySQL数据库并且都已经正常运行了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19bsu4pv1j21zq0dyn3r.jpg" alt="image-20220414162319865"></p><p>接着我们需要创建对应的账号，一会方便从库进行访问的用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> test identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><p>接着我们开启一下外网访问：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf<br></code></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># If MySQL is running as a replication slave, this should be</span><br><span class="hljs-comment"># changed. Ref https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_tmpdir</span><br><span class="hljs-comment"># tmpdir                = /tmp</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Instead of skip-networking the default is now to listen only on</span><br><span class="hljs-comment"># localhost which is more compatible and is not less secure.</span><br><span class="hljs-comment"># bind-address          = 127.0.0.1    这里注释掉就行</span><br></code></pre></td></tr></table></figure><p>现在我们重启一下MySQL服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl restart mysql.service <br></code></pre></td></tr></table></figure><p>现在我们首先来配置主库，主库只需要为我们刚刚创建好的用户分配一个主从复制的权限即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> replication slave <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> test;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><p>然后我们可以输入命令来查看主库的相关情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19ckapbrsj218206s3zi.jpg" alt="image-20220414164943974"></p><p>这样主库就搭建完成了，接着我们需要将从库进行配置，首先是配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># The following can be used as easy to replay backup logs or for replication.</span><br><span class="hljs-comment"># <span class="hljs-doctag">note:</span> if you are setting up a replication slave, see README.Debian about</span><br><span class="hljs-comment">#       other settings you may need to change.</span><br><span class="hljs-comment"># 这里需要将server-id配置为其他的值（默认是1）所有Mysql主从实例的id必须唯一，不能打架，不然一会开启会失败</span><br><span class="hljs-attr">server-id</span>               = <span class="hljs-string">2</span><br></code></pre></td></tr></table></figure><p>进入数据库，输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">change replication source <span class="hljs-keyword">to</span> SOURCE_HOST<span class="hljs-operator">=</span><span class="hljs-string">&#x27;192.168.0.8&#x27;</span>,SOURCE_USER<span class="hljs-operator">=</span><span class="hljs-string">&#x27;test&#x27;</span>,SOURCE_PASSWORD<span class="hljs-operator">=</span><span class="hljs-string">&#x27;123456&#x27;</span>,SOURCE_LOG_FILE<span class="hljs-operator">=</span><span class="hljs-string">&#x27;binlog.000004&#x27;</span>,SOURCE_LOG_POS<span class="hljs-operator">=</span><span class="hljs-number">591</span>;<br></code></pre></td></tr></table></figure><p>注意后面的logfile和pos就是我们上面从主库中显示的信息。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19cvd6eypj218m032my0.jpg" alt="image-20220414170022303"></p><p>执行完成后，显示OK表示没有问题，接着输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> replica;<br></code></pre></td></tr></table></figure><p>现在我们的从机就正式启动了，现在我们输入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> replica status\G;<br></code></pre></td></tr></table></figure><p>来查看当前从机状态，可以看到：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19gxft4iwj217i0d4jtm.jpg" alt="image-20220414192045320"></p><p>最关键的是下面的Replica_IO_Running和Replica_SQL_Running必须同时为Yes才可以，实际上从库会创建两个线程，一个线程负责与主库进行通信，获取二进制日志，暂时存放到一个中间表（Relay_Log）中，而另一个线程则是将中间表保存的二进制日志的信息进行执行，然后插入到从库中。</p><p>最后配置完成，我们来看看在主库进行操作会不会同步到从库：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19h202nr3j21e00aimyl.jpg" alt="image-20220414192508849"></p><p>可以看到在主库中创建的数据库，被同步到从库中了，我们再来试试看创建表和插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">use yyds;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test  (<br>  `id` <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NULL</span>,<br>  `passwd` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19h5hpocfj21dg0e8tbe.jpg" alt="image-20220414192829536"></p><p>现在我们随便插入一点数据：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19h6cxnxzj215c08s3zn.jpg" alt="image-20220414192920277"></p><p>这样，我们的MySQL主从就搭建完成了，那么如果主机此时挂了会怎么样？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19i41l2flj211k03oq3b.jpg" alt="image-20220414200140191"></p><p>可以看到IO线程是处于重连状态，会等待主库重新恢复运行。</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>在大型的互联网系统中，可能单台MySQL的存储容量无法满足业务的需求，这时候就需要进行扩容了。</p><p>和之前的问题一样，单台主机的硬件资源是存在瓶颈的，不可能无限制地纵向扩展，这时我们就得通过多台实例来进行容量的横向扩容，我们可以将数据分散存储，让多台主机共同来保存数据。</p><p>那么问题来了，怎么个分散法？</p><ul><li><p><strong>垂直拆分：</strong>我们的表和数据库都可以进行垂直拆分，所谓垂直拆分，就是将数据库中所有的表，按照业务功能拆分到各个数据库中（是不是感觉跟前面两章的学习的架构对应起来了）而对于一张表，也可以通过外键之类的机制，将其拆分为多个表。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19jf8adocj21e60gyacl.jpg" alt="image-20220414204703883"></p></li><li><p><strong>水平拆分：</strong>水平拆分针对的不是表，而是数据，我们可以让很多个具有相同表的数据库存放一部分数据，相当于是将数据分散存储在各个节点上。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19jkrb2pkj21g80eu76c.jpg" alt="image-20220414205222383"></p></li></ul><p>那么要实现这样的拆分操作，我们自行去编写代码工作量肯定是比较大的，因此目前实际上已经有一些解决方案了，比如我们可以使用MyCat（也是一个数据库中间件，相当于挂了一层代理，再通过MyCat进行分库分表操作数据库，只需要连接就能使用，类似的还有ShardingSphere-Proxy）或是Sharding JDBC（应用程序中直接对SQL语句进行分析，然后转换成分库分表操作，需要我们自己编写一些逻辑代码），这里我们就讲解一下Sharding JDBC。</p><h3 id="Sharding-JDBC"><a href="#Sharding-JDBC" class="headerlink" title="Sharding JDBC"></a>Sharding JDBC</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19l7msxooj21ps0iego7.jpg" alt="image-20220414214856875"></p><p><strong>官方文档（中文）：</strong><a href="https://shardingsphere.apache.org/document/5.1.0/cn/overview/#shardingsphere-jdbc">https://shardingsphere.apache.org/document/5.1.0/cn/overview/#shardingsphere-jdbc</a></p><p>定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务，它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p><ul><li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC；</li><li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, HikariCP 等；</li><li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，PostgreSQL，Oracle，SQLServer 以及任何可使用 JDBC 访问的数据库。</li></ul><p>这里我们主要演示一下水平分表方式，我们直接创建一个新的SpringBoot项目即可，依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  ShardingJDBC依赖，那必须安排最新版啊，希望你们看视频的时候还是5.X版本  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shardingsphere-jdbc-core-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>数据库我们这里直接用上节课的即可，因为只需要两个表结构一样的数据库即可，正好上节课进行了同步，所以我们直接把从库变回正常状态就可以了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">stop replica;<br></code></pre></td></tr></table></figure><p>接着我们把两个表的root用户密码改一下，一会用这个用户连接数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> authentication_string<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;root&#x27;</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> host <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> root identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><p>接着我们来看，如果直接尝试开启服务器，那肯定是开不了的，因为我们要配置数据源：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19kif2dh4j21sk08en0j.jpg" alt="image-20220414212443482"></p><p>那么数据源该怎么配置呢？现在我们是一个分库分表的状态，需要配置两个数据源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">shardingsphere:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-comment"># 有几个数据就配几个，这里是名称，按照下面的格式，名称+数字的形式</span><br>      <span class="hljs-attr">names:</span> <span class="hljs-string">db0,db1</span><br>      <span class="hljs-comment"># 为每个数据源单独进行配置</span><br>      <span class="hljs-attr">db0:</span><br>      <span class="hljs-comment"># 数据源实现类，这里使用默认的HikariDataSource</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>        <span class="hljs-comment"># 数据库驱动</span><br>        <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>        <span class="hljs-comment"># 不用我多说了吧</span><br>        <span class="hljs-attr">jdbc-url:</span> <span class="hljs-string">jdbc:mysql://192.168.0.8:3306/yyds</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>      <span class="hljs-attr">db1:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>        <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>        <span class="hljs-attr">jdbc-url:</span> <span class="hljs-string">jdbc:mysql://192.168.0.13:3306/yyds</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>如果启动没有问题，那么就是配置成功了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h19mebpqb7j21su0aqgre.jpg" alt="image-20220414222958901"></p><p>接着我们需要对项目进行一些编写，添加我们的用户实体类和Mapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    String passwd;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from test where id = #&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br><br>    <span class="hljs-meta">@Insert(&quot;insert into test(id, name, passwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;passwd&#125;)&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这些操作都是常规操作，在编写代码时关注点依然放在业务本身上，现在我们就来编写配置文件，我们需要告诉ShardingJDBC要如何进行分片，首先明确：现在是两个数据库都有test表存放用户数据，我们目标是将用户信息分别存放到这两个数据库的表中。</p><p>不废话了，直接上配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">shardingsphere:</span><br>    <span class="hljs-attr">rules:</span><br>      <span class="hljs-attr">sharding:</span><br>        <span class="hljs-attr">tables:</span><br>        <span class="hljs-comment">#这里填写表名称，程序中对这张表的所有操作，都会采用下面的路由方案</span><br>        <span class="hljs-comment">#比如我们上面Mybatis就是对test表进行操作，所以会走下面的路由方案</span><br>          <span class="hljs-attr">test:</span><br>          <span class="hljs-comment">#这里填写实际的路由节点，比如现在我们要分两个库，那么就可以把两个库都写上，以及对应的表</span><br>          <span class="hljs-comment">#也可以使用表达式，比如下面的可以简写为 db$-&gt;&#123;0..1&#125;.test</span><br>            <span class="hljs-attr">actual-data-nodes:</span> <span class="hljs-string">db0.test,db1.test</span><br>            <span class="hljs-comment">#这里是分库策略配置</span><br>            <span class="hljs-attr">database-strategy:</span><br>            <span class="hljs-comment">#这里选择标准策略，也可以配置复杂策略，基于多个键进行分片</span><br>              <span class="hljs-attr">standard:</span><br>              <span class="hljs-comment">#参与分片运算的字段，下面的算法会根据这里提供的字段进行运算</span><br>                <span class="hljs-attr">sharding-column:</span> <span class="hljs-string">id</span><br>                <span class="hljs-comment">#这里填写我们下面自定义的算法名称</span><br>                <span class="hljs-attr">sharding-algorithm-name:</span> <span class="hljs-string">my-alg</span><br>        <span class="hljs-attr">sharding-algorithms:</span><br>        <span class="hljs-comment">#自定义一个新的算法，名称随意</span><br>          <span class="hljs-attr">my-alg:</span><br>          <span class="hljs-comment">#算法类型，官方内置了很多种，这里演示最简单的一种</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">MOD</span><br>            <span class="hljs-attr">props:</span><br>              <span class="hljs-attr">sharding-count:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">props:</span><br>    <span class="hljs-comment">#开启日志，一会方便我们观察</span><br><span class="hljs-attr">sql-show:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>其中，分片算法有很多内置的，可以在这里查询：<a href="https://shardingsphere.apache.org/document/5.1.0/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/sharding/%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFMOD%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%8F%96%E6%A8%A1%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95%EF%BC%8C%E5%AE%83%E4%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%BB%E9%94%AE%E7%9A%84%E5%80%BC%E8%BF%9B%E8%A1%8C%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97%EF%BC%8C%E6%AF%94%E5%A6%82%E6%88%91%E4%BB%AC%E8%BF%99%E9%87%8C%E5%A1%AB%E5%86%99%E7%9A%84%E6%98%AF2%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E8%A1%A8%E7%A4%BA%E5%AF%B9%E4%B8%BB%E9%94%AE%E8%BF%9B%E8%A1%8C%E6%A8%A12%E8%BF%90%E7%AE%97%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%90%8D%E7%A7%B0%EF%BC%8C%E6%AF%94%E5%A6%82db0%E5%B0%B1%E6%98%AF%E5%8F%96%E6%A8%A1%E5%90%8E%E4%B8%BA0%EF%BC%8Cdb1%E5%B0%B1%E6%98%AF%E5%8F%96%E6%A8%A1%E5%90%8E%E4%B8%BA1%EF%BC%88%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%BE%88%E6%B8%85%E6%A5%9A%EF%BC%89%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%95%88%E6%9E%9C%E5%B0%B1%E6%98%AF%E5%8D%95%E6%95%B0%E6%94%BE%E5%9C%A8%60db1%60%EF%BC%8C%E5%8F%8C%E6%95%B0%E6%94%BE%E5%9C%A8%60db0%60%EF%BC%8C%E5%BD%93%E7%84%B6%E5%AE%83%E8%BF%98%E6%94%AF%E6%8C%81%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%A4%9A%E4%BB%8B%E7%BB%8D%E4%BA%86%E3%80%82">https://shardingsphere.apache.org/document/5.1.0/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/sharding/，这里我们使用的是MOD，也就是取模分片算法，它会根据主键的值进行取模运算，比如我们这里填写的是2，那么就表示对主键进行模2运算，根据数据源的名称，比如db0就是取模后为0，db1就是取模后为1（官方文档描述的并不是很清楚），也就是说，最终实现的效果就是单数放在`db1`，双数放在`db0`，当然它还支持一些其他的算法，这里就不多介绍了。</a></p><p>那么现在我们编写一个测试用例来看看，是否能够按照我们上面的规则进行路由：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingJdbcTestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-comment">//这里ID自动生成1-10，然后插入数据库</span><br>            mapper.addUser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(i, <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;ccc&quot;</span>));   <br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以开始运行了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a7m3cjm6j21qe0b6aej.jpg" alt="image-20220415104401263"></p><p>测试通过，我们来看看数据库里面是不是按照我们的规则进行数据插入的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a7mx6u30j217g0d075w.jpg" alt="image-20220415104449502"></p><p>可以看到这两张表，都成功按照我们指定的路由规则进行插入了，我们来看看详细的路由情况，通过控制台输出的SQL就可以看到：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a7vvcqsij21g20amgpd.jpg" alt="image-20220415105325917"></p><p>可以看到所有的SQL语句都有一个Logic SQL（这个就是我们在Mybatis里面写的，是什么就是什么）紧接着下面就是Actual SQL，也就是说每个逻辑SQL最终会根据我们的策略转换为实际SQL，比如第一条数据，它的id是0，那么实际转换出来的SQL会在db0这个数据源进行插入。</p><p>这样我们就很轻松地实现了分库策略。</p><p>分库完成之后，接着我们来看分表，比如现在我们的数据库中有<code>test_0</code>和<code>test_1</code>两张表，表结构一样，但是我们也是希望能够根据id取模运算的结果分别放到这两个不同的表中，实现思路其实是差不多的，这里首先需要介绍一下两种表概念：</p><ul><li><strong>逻辑表：</strong>相同结构的水平拆分数据库（表）的逻辑名称，是 SQL 中表的逻辑标识。 例：订单数据根据主键尾数拆分为 10 张表，分别是 <code>t_order_0</code> 到 <code>t_order_9</code>，他们的逻辑表名为 <code>t_order</code></li><li><strong>真实表：</strong>在水平拆分的数据库中真实存在的物理表。 即上个示例中的 <code>t_order_0</code> 到 <code>t_order_9</code></li></ul><p>现在我们就以一号数据库为例，那么我们在里面创建上面提到的两张表，之前的那个<code>test</code>表删不删都可以，就当做不存在就行了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test_0  (<br>  `id` <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NULL</span>,<br>  `passwd` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NULL</span><br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test_1  (<br>  `id` <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NULL</span>,<br>  `passwd` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a8681w2ej211608u3z0.jpg" alt="image-20220415110322981"></p><p>接着我们不要去修改任何的业务代码，Mybatis里面写的是什么依然保持原样，即使我们的表名已经变了，我们需要做的是通过路由来修改原有的SQL，配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">shardingsphere:</span><br>    <span class="hljs-attr">rules:</span><br>      <span class="hljs-attr">sharding:</span><br>        <span class="hljs-attr">tables:</span><br>          <span class="hljs-attr">test:</span><br>            <span class="hljs-attr">actual-data-nodes:</span> <span class="hljs-string">db0.test_$-&gt;&#123;0..1&#125;</span><br>            <span class="hljs-comment">#现在我们来配置一下分表策略，注意这里是table-strategy上面是database-strategy</span><br>            <span class="hljs-attr">table-strategy:</span><br>            <span class="hljs-comment">#基本都跟之前是一样的</span><br>              <span class="hljs-attr">standard:</span><br>                <span class="hljs-attr">sharding-column:</span> <span class="hljs-string">id</span><br>                <span class="hljs-attr">sharding-algorithm-name:</span> <span class="hljs-string">my-alg</span><br>        <span class="hljs-attr">sharding-algorithms:</span><br>          <span class="hljs-attr">my-alg:</span><br>          <span class="hljs-comment">#这里我们演示一下INLINE方式，我们可以自行编写表达式来决定</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">INLINE</span><br>            <span class="hljs-attr">props:</span><br>            <span class="hljs-comment">#比如我们还是希望进行模2计算得到数据该去的表</span><br>            <span class="hljs-comment">#只需要给一个最终的表名称就行了test_，后面的数字是表达式取模算出的</span><br>            <span class="hljs-comment">#实际上这样写和MOD模式一模一样</span><br>              <span class="hljs-attr">algorithm-expression:</span> <span class="hljs-string">test_$-&gt;&#123;id</span> <span class="hljs-string">%</span> <span class="hljs-number">2</span><span class="hljs-string">&#125;</span><br>              <span class="hljs-comment">#没错，查询也会根据分片策略来进行，但是如果我们使用的是范围查询，那么依然会进行全量查询</span><br>              <span class="hljs-comment">#这个我们后面紧接着会讲，这里先写上吧</span><br>              <span class="hljs-attr">allow-range-query-with-inline-sharding:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>现在我们来测试一下，看看会不会按照我们的策略进行分表插入：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a8w0j0ubj21q80bkgq4.jpg" alt="image-20220415112809843"></p><p>可以看到，根据我们的算法，原本的逻辑表被修改为了最终进行分表计算后的结果，我们来查看一下数据库：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a8x1l1coj21800lqgnj.jpg" alt="image-20220415112908760"></p><p>插入我们了解完毕了，我们来看看查询呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingJdbcTestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(mapper.getUserById(<span class="hljs-number">0</span>));<br>        System.out.println(mapper.getUserById(<span class="hljs-number">1</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a8znk6tuj21j408uacr.jpg" alt="image-20220415113139917"></p><p>可以看到，根据我们配置的策略，查询也会自动选择对应的表进行，是不是感觉有内味了。</p><p>那么如果是范围查询呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from test where id between #&#123;start&#125; and #&#123;end&#125;&quot;)</span><br>List&lt;User&gt; <span class="hljs-title function_">getUsersByIdRange</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingJdbcTestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(mapper.getUsersByIdRange(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看执行结果会怎么样：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a93ntucij21qa07wwim.jpg" alt="image-20220415113530971"></p><p>可以看到INLINE算法默认是不支持进行全量查询的，我们得将上面的配置项改成true：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">allow-range-query-with-inline-sharding:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>再次进行测试：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1a952ev2ej21rq04wwg8.jpg" alt="image-20220415113652038"></p><p>可以看到，最终出来的SQL语句是直接对两个表都进行查询，然后求出一个并集出来作为最后的结果。</p><p>当然除了分片之外，还有广播表和绑定表机制，用于多种业务场景下，这里就不多做介绍了，详细请查阅官方文档。</p><h3 id="分布式序列算法"><a href="#分布式序列算法" class="headerlink" title="分布式序列算法"></a>分布式序列算法</h3><p>前面我们讲解了如何进行分库分表，接着我们来看看分布式序列算法。</p><p>在复杂分布式系统中，特别是微服构架中，往往需要对大量的数据和消息进行唯一标识。随着系统的复杂，数据的增多，分库分表成为了常见的方案，对数据分库分表后需要有一个唯一ID来标识一条数据或消息（如订单号、交易流水、事件编号等），此时一个能够生成全局唯一ID的系统是非常必要的。</p><p>比如我们之前创建过学生信息表、图书借阅表、图书管理表，所有的信息都会有一个ID作为主键，并且这个ID有以下要求：</p><ul><li>为了区别于其他的数据，这个ID必须是全局唯一的。</li><li>主键应该尽可能的保持有序，这样会大大提升索引的查询效率。</li></ul><p>那么我们在分布式系统下，如何保证ID的生成满足上面的需求呢？</p><ol><li><p><strong>使用UUID：</strong>UUID是由一组32位数的16进制数字随机构成的，我们可以直接使用JDK为我们提供的UUID类来创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    System.out.println(uuid);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为<code>73d5219b-dc0f-4282-ac6e-8df17bcd5860</code>，生成速度非常快，可以看到确实是能够保证唯一性，因为每次都不一样，而且这么长一串那重复的概率真的是小的可怜。</p><p>但是它并不满足我们上面的第二个要求，也就是说我们需要尽可能的保证有序，而这里我们得到的都是一些无序的ID。</p></li><li><p><strong>雪花算法（Snowflake）：</strong></p><p>我们来看雪花算法，它会生成一个一个64bit大小的整型的ID，int肯定是装不下了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1af7y9xpyj213609kwf6.jpg" alt="image-20220415150713707"></p><p>可以看到它主要是三个部分组成，时间+工作机器ID+序列号，时间以毫秒为单位，41个bit位能表示约70年的时间，时间纪元从2016年11月1日零点开始，可以使用到2086年，工作机器ID其实就是节点ID，每个节点的ID都不相同，那么就可以区分出来，10个bit位可以表示最多1024个节点，最后12位就是每个节点下的序列号，因此每台机器每毫秒就可以有4096个系列号。</p><p>这样，它就兼具了上面所说的唯一性和有序性了，但是依然是有缺点的，第一个是时间问题，如果机器时间出现倒退，那么就会导致生成重复的ID，并且节点容量只有1024个，如果是超大规模集群，也是存在隐患的。</p></li></ol><p>ShardingJDBC支持以上两种算法为我们自动生成ID，文档：<a href="https://shardingsphere.apache.org/document/5.1.0/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/keygen/">https://shardingsphere.apache.org/document/5.1.0/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/keygen/</a></p><p>这里，我们就是要ShardingJDBC来让我们的主键ID以雪花算法进行生成，首先是配置数据库，因为我们默认的id是int类型，装不下64位的，改一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `yyds`.`test` MODIFY <span class="hljs-keyword">COLUMN</span> `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">FIRST</span>;<br></code></pre></td></tr></table></figure><p>接着我们需要修改一下Mybatis的插入语句，因为现在id是由ShardingJDBC自动生成，我们就不需要自己加了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Insert(&quot;insert into test(name, passwd) values(#&#123;name&#125;, #&#123;passwd&#125;)&quot;)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;<br></code></pre></td></tr></table></figure><p>接着我们在配置文件中将我们的算法写上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">shardingsphere:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">sharding:</span><br>        <span class="hljs-attr">tables:</span><br>          <span class="hljs-attr">test:</span><br>            <span class="hljs-attr">actual-data-nodes:</span> <span class="hljs-string">db0.test,db1.test</span><br>            <span class="hljs-comment">#这里还是使用分库策略</span><br>            <span class="hljs-attr">database-strategy:</span><br>              <span class="hljs-attr">standard:</span><br>                <span class="hljs-attr">sharding-column:</span> <span class="hljs-string">id</span><br>                <span class="hljs-attr">sharding-algorithm-name:</span> <span class="hljs-string">my-alg</span><br>            <span class="hljs-comment">#这里使用自定义的主键生成策略</span><br>            <span class="hljs-attr">key-generate-strategy:</span><br>              <span class="hljs-attr">column:</span> <span class="hljs-string">id</span><br>              <span class="hljs-attr">key-generator-name:</span> <span class="hljs-string">my-gen</span><br>        <span class="hljs-attr">key-generators:</span><br>        <span class="hljs-comment">#这里写我们自定义的主键生成算法</span><br>          <span class="hljs-attr">my-gen:</span><br>          <span class="hljs-comment">#使用雪花算法</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">SNOWFLAKE</span><br>            <span class="hljs-attr">props:</span><br>            <span class="hljs-comment">#工作机器ID，保证唯一就行</span><br>              <span class="hljs-attr">worker-id:</span> <span class="hljs-number">666</span><br>        <span class="hljs-attr">sharding-algorithms:</span><br>          <span class="hljs-attr">my-alg:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">MOD</span><br>            <span class="hljs-attr">props:</span><br>              <span class="hljs-attr">sharding-count:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>接着我们来编写一下测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingJdbcTestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            mapper.addUser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>));<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到日志：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1agbo7cqhj21fi0ein3c.jpg" alt="image-20220415154524545"></p><p>在插入的时候，将我们的SQL语句自行添加了一个id字段，并且使用的是雪花算法生成的值，并且也是根据我们的分库策略在进行插入操作。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>最后我们来看看读写分离，我们之前实现了MySQL的主从，那么我们就可以将主库作为读，从库作为写：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1agpivkf5j21og0ge76c.jpg" alt="image-20220415155842834"></p><p>这里我们还是将数据库变回主从状态，直接删除当前的表，我们重新来过：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> test;<br></code></pre></td></tr></table></figure><p>我们需要将从库开启只读模式，在MySQL配置中进行修改：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">read-only</span>    = <span class="hljs-string">1</span><br></code></pre></td></tr></table></figure><p>这样从库就只能读数据了（但是root账号还是可以写数据），接着我们重启服务器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl restart mysql.service<br></code></pre></td></tr></table></figure><p>然后进入主库，看看状态：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1agtsg7urj217k07s0tx.jpg" alt="image-20220415160249024"></p><p>现在我们配置一下从库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">change replication source <span class="hljs-keyword">to</span> SOURCE_HOST<span class="hljs-operator">=</span><span class="hljs-string">&#x27;192.168.0.13&#x27;</span>,SOURCE_USER<span class="hljs-operator">=</span><span class="hljs-string">&#x27;test&#x27;</span>,SOURCE_PASSWORD<span class="hljs-operator">=</span><span class="hljs-string">&#x27;123456&#x27;</span>,SOURCE_LOG_FILE<span class="hljs-operator">=</span><span class="hljs-string">&#x27;binlog.000007&#x27;</span>,SOURCE_LOG_POS<span class="hljs-operator">=</span><span class="hljs-number">19845</span>;<br><span class="hljs-keyword">start</span> replica;<br></code></pre></td></tr></table></figure><p>现在我们在主库创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test  (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">primary</span> key,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NULL</span>,<br>  `passwd` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure><p>然后我们就可以配置ShardingJDBC了，打开配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">shardingsphere:</span><br>    <span class="hljs-attr">rules:</span><br>    <span class="hljs-comment">#配置读写分离</span><br>      <span class="hljs-attr">readwrite-splitting:</span><br>        <span class="hljs-attr">data-sources:</span><br>        <span class="hljs-comment">#名称随便写</span><br>          <span class="hljs-attr">user-db:</span><br>          <span class="hljs-comment">#使用静态类型，动态Dynamic类型可以自动发现auto-aware-data-source-name，这里不演示</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">Static</span><br>            <span class="hljs-attr">props:</span><br>            <span class="hljs-comment">#配置写库（只能一个）</span><br>              <span class="hljs-attr">write-data-source-name:</span> <span class="hljs-string">db0</span><br>              <span class="hljs-comment">#配置从库（多个，逗号隔开）</span><br>              <span class="hljs-attr">read-data-source-names:</span> <span class="hljs-string">db1</span><br>              <span class="hljs-comment">#负载均衡策略，可以自定义</span><br>              <span class="hljs-attr">load-balancer-name:</span> <span class="hljs-string">my-load</span><br>        <span class="hljs-attr">load-balancers:</span><br>        <span class="hljs-comment">#自定义的负载均衡策略</span><br>          <span class="hljs-attr">my-load:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">ROUND_ROBIN</span><br></code></pre></td></tr></table></figure><p>注意把之前改的用户实体类和Mapper改回去，这里我们就不用自动生成ID的了。所有的负载均衡算法地址：<a href="https://shardingsphere.apache.org/document/5.1.0/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/load-balance/">https://shardingsphere.apache.org/document/5.1.0/cn/user-manual/shardingsphere-jdbc/builtin-algorithm/load-balance/</a></p><p>现在我们就来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingJdbcTestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        mapper.addUser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>));<br>        System.out.println(mapper.getUserById(<span class="hljs-number">10</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行看看SQL日志：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ahjo682tj21je07udik.jpg" alt="image-20220415162741466"></p><p>可以看到，当我们执行插入操作时，会直接向db0进行操作，而读取操作是会根据我们的配置，选择db1进行操作。</p><p>至此，微服务应用章节到此结束。</p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务进阶</title>
    <link href="/2022/10/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/10/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ml18j1h6j21v40lkgob.jpg" alt="image-20220326001448808"></p><h1 id="微服务进阶"><a href="#微服务进阶" class="headerlink" title="微服务进阶"></a>微服务进阶</h1><p>前面我们了解了微服务的一套解决方案，但是它是基于Netflix的解决方案，实际上我们发现，很多框架都已经停止维护了，来看看目前我们所认识到的SpringCloud各大组件的维护情况：</p><ul><li><strong>注册中心：</strong>Eureka（属于<em>Netflix</em>，2.x版本不再开源，1.x版本仍在更新）</li><li><strong>服务调用：</strong>Ribbon（属于<em>Netflix</em>，停止更新，已经彻底被移除）、SpringCloud Loadbalancer（属于<em>SpringCloud</em>官方，目前的默认方案）</li><li><strong>服务降级：</strong>Hystrix（属于<em>Netflix</em>，停止更新，已经彻底被移除）</li><li><strong>路由网关：</strong>Zuul（属于<em>Netflix</em>，停止更新，已经彻底被移除）、Gateway（属于<em>SpringCloud</em>官方，推荐方案）</li><li><strong>配置中心：</strong>Config（属于<em>SpringCloud</em>官方）</li></ul><p>可见，我们之前使用的整套解决方案中，超过半数的组件都已经处于不可用状态，并且部分组件都是SpringCloud官方出手提供框架进行解决，因此，寻找一套更好的解决方案势在必行，也就引出了我们本章的主角：<strong>SpringCloud Alibaba</strong></p><p>阿里巴巴作为业界的互联网大厂，给出了一套全新的解决方案，官方网站（中文）：<a href="https://spring-cloud-alibaba-group.github.io/github-pages/2021/zh-cn/index.html">https://spring-cloud-alibaba-group.github.io/github-pages/2021/zh-cn/index.html</a></p><blockquote><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p></blockquote><p>目前 Spring Cloud Alibaba 提供了如下功能:</p><ol><li><strong>服务限流降级</strong>：支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Dubbo 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>Rpc服务</strong>：扩展 Spring Cloud 客户端 RestTemplate 和 OpenFeign，支持调用 Dubbo RPC 服务</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li><li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li><li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ol><p>可以看到，SpringCloudAlibaba实际上是对我们的SpringCloud组件增强功能，是SpringCloud的增强框架，可以兼容SpringCloud原生组件和SpringCloudAlibaba的组件。</p><p>开始学习之前，把我们之前打包好的拆分项目解压，我们将基于它进行讲解。</p><hr><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n3ym3j2sj20pg02qa9x.jpg" alt="image-20220326110940692"></p><h2 id="Nacos-更加全能的注册中心"><a href="#Nacos-更加全能的注册中心" class="headerlink" title="Nacos 更加全能的注册中心"></a>Nacos 更加全能的注册中心</h2><p>Nacos（<strong>Na</strong>ming <strong>Co</strong>nfiguration <strong>S</strong>ervice）是一款阿里巴巴开源的服务注册与发现、配置管理的组件，相当于是Eureka+Config的组合形态。</p><h3 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h3><p>Nacos服务器是独立安装部署的，因此我们需要下载最新的Nacos服务端程序，下载地址：<a href="https://github.com/alibaba/nacos%EF%BC%8C%E8%BF%9E%E4%B8%8D%E4%B8%8A%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%A7%86%E9%A2%91%E4%B8%8B%E6%96%B9%E4%BA%91%E7%9B%98%E4%B8%AD%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/alibaba/nacos，连不上可以到视频下方云盘中下载。</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0n6x7gxp1j22qs0ms0x0.jpg" alt="image-20220326125206549"></p><p>可以看到目前最新的版本是<code>1.4.3</code>版本（2022年2月27日发布的），我们直接下载<code>zip</code>文件即可。</p><p>接着我们将文件进行解压，得到以下内容：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n749lottj215a08swfh.jpg" alt="image-20220326125854416"></p><p>我们直接将其拖入到项目文件夹下，便于我们一会在IDEA内部启动，接着添加运行配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n798coaxj226a0i279d.jpg" alt="image-20220326130340573"></p><p>其中<code>-m standalone</code>表示单节点模式，Mac和Linux下记得将解释器设定为<code>/bin/bash</code>，由于Nacos在Mac&#x2F;Linux默认是后台启动模式，我们修改一下它的bash文件，让它变成前台启动，这样IDEA关闭了Nacos就自动关闭了，否则开发环境下很容易忘记关：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注释掉 nohup $JAVA $&#123;JAVA_OPT&#125; nacos.nacos &gt;&gt; $&#123;BASE_DIR&#125;/logs/start.out 2&gt;&amp;1 &amp;</span><br><span class="hljs-comment"># 替换成下面的</span><br><span class="hljs-variable">$JAVA</span> <span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> nacos.nacos<br></code></pre></td></tr></table></figure><p>接着我们点击启动：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n7r3rhzqj22o80jw0wb.jpg" alt="image-20220326132051779"></p><p>OK，启动成功，可以看到它的管理页面地址也是给我们贴出来了： <a href="http://localhost:8848/nacos/index.html%EF%BC%8C%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%9A">http://localhost:8848/nacos/index.html，访问这个地址：</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n7s92e4jj21lh0u0whw.jpg" alt="image-20220326132157126"></p><p>默认的用户名和管理员密码都是<code>nacos</code>，直接登陆即可，可以看到进入管理页面之后功能也是相当丰富：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n7vcjn7oj22mg0p6dj0.jpg" alt="image-20220326132455674"></p><p>至此，Nacos的安装与部署完成。</p><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>现在我们要实现基于Nacos的服务注册与发现，那么就需要导入SpringCloudAlibaba相关的依赖，我们在父工程将依赖进行管理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <br>      <span class="hljs-comment">&lt;!-- 这里引入最新的SpringCloud依赖 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>       <span class="hljs-comment">&lt;!-- 这里引入最新的SpringCloudAlibaba依赖，2021.0.1.0版本支持SpringBoot2.6.X --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们就可以在子项目中添加服务发现依赖了，比如我们以图书服务为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>和注册到Eureka一样，我们也需要在配置文件中配置Nacos注册中心的地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br><span class="hljs-comment"># 之后所有的图书服务节点就81XX端口</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8101</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://cloudstudy.mysql.cn-chengdu.rds.aliyuncs.com:3306/cloudstudy</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>  <span class="hljs-comment"># 应用名称 bookservice</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">bookservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># 配置Nacos注册中心地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure><p>接着启动我们的图书服务，可以在Nacos的服务列表中找到：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0n8xfhqcaj22lw0egdih.jpg" alt="image-20220326140130226"></p><p>按照同样的方法，我们接着将另外两个服务也注册到Nacos中：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0n92f2wthj22d00ckdi1.jpg" alt="image-20220326140618708"></p><p>接着我们使用OpenFeign，实现服务发现远程调用以及负载均衡，导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这里需要单独导入LoadBalancer依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;bookservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookClient</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; bookClient.getBookById(b.getBid()))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(BorrowApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们进行测试：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n9kaxje1j228c074q4h.jpg" alt="image-20220326142331199"></p><p>测试正常，可以自动发现服务，接着我们来多配置几个实例，去掉图书服务和用户服务的端口配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n9otepuuj21lk0lin0g.jpg" alt="image-20220326142751398"></p><p>然后我们在图书服务和用户服务中添加一句打印方便之后查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;调用用户服务&quot;</span>);<br>    <span class="hljs-keyword">return</span> service.getUserById(uid);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在将全部服务启动：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n9qxup53j223g0eqaix.jpg" alt="image-20220326142953904"></p><p>可以看到Nacos中的实例数量已经显示为<code>2</code>：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n9rc8v0wj22cg0g6goj.jpg" alt="image-20220326143017054"></p><p>接着我们调用借阅服务，看看能否负载均衡远程调用：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n9s2ioeqj225o07ytaa.jpg" alt="image-20220326143058939"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0n9sh0wr0j21x20gswne.jpg" alt="image-20220326143122333"></p><p>OK，负载均衡远程调用没有问题，这样我们就实现了基于Nacos的服务的注册与发现，实际上大致流程与Eureka一致。</p><p>值得注意的是，Nacos区分了临时实例和非临时实例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nc2h4gy2j22ay072q44.jpg" alt="image-20220326155010841"></p><p>那么临时和非临时有什么区别呢？</p><ul><li>临时实例：和Eureka一样，采用心跳机制向Nacos发送请求保持在线状态，一旦心跳停止，代表实例下线，不保留实例信息。</li><li>非临时实例：由Nacos主动进行联系，如果连接失败，那么不会移除实例信息，而是将健康状态设定为false，相当于会对某个实例状态持续地进行监控。</li></ul><p>我们可以通过配置文件进行修改临时实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 将ephemeral修改为false，表示非临时实例</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>接着我们在Nacos中查看，可以发现实例已经不是临时的了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nc8g1llrj22be06iq3y.jpg" alt="image-20220326155554821"></p><p>如果这时我们关闭此实例，那么会变成这样：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nc93w8zlj22bq06mmy5.jpg" alt="image-20220326155633190"></p><p>只是将健康状态变为false，而不会删除实例的信息。</p><h3 id="集群分区"><a href="#集群分区" class="headerlink" title="集群分区"></a>集群分区</h3><p>实际上集群分区概念在之前的Eureka中也有出现，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br><span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8888/eureka</span><br>      <span class="hljs-comment"># 这个defaultZone是个啥玩意，为什么要用这个名称？为什么要要用这样的形式来声明注册中心？</span><br></code></pre></td></tr></table></figure><p>在一个分布式应用中，相同服务的实例可能会在不同的机器、位置上启动，比如我们的用户管理服务，可能在成都有1台服务器部署、重庆有一台服务器部署，而这时，我们在成都的服务器上启动了借阅服务，那么如果我们的借阅服务现在要调用用户服务，就应该优先选择同一个区域的用户服务进行调用，这样会使得响应速度更快。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0namonso5j21em0bcgnr.jpg" alt="image-20220326150024118"></p><p>因此，我们可以对部署在不同机房的服务进行分区，可以看到实例的分区是默认：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nanxl0kkj22cm0hawh5.jpg" alt="image-20220326150136538"></p><p>我们可以直接在配置文件中进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 修改为重庆地区的集群</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">Chongqing</span><br></code></pre></td></tr></table></figure><p>当然由于我们这里使用的是不同的启动配置，直接在启动配置中添加环境变量<code>spring.cloud.nacos.discovery.cluster-name</code>也行，这里我们将用户服务和图书服务两个区域都分配一个，借阅服务就配置为成都地区：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nars805bj216c08ot9x.jpg" alt="image-20220326150518357"></p><p>修改完成之后，我们来尝试重新启动一下（Nacos也要重启），观察Nacos中集群分布情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nawm1jraj22ck0u0wij.jpg" alt="image-20220326150956937"></p><p>可以看到现在有两个集群，并且都有一个实例正在运行。我们接着去调用借阅服务，但是发现并没有按照区域进行优先调用，而依然使用的是轮询模式的负载均衡调用。</p><p>我们必须要提供Nacos的负载均衡实现才能开启区域优先调用机制，只需要在配制文件中进行修改即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">Chengdu</span><br>    <span class="hljs-comment"># 将loadbalancer的nacos支持开启，集成Nacos负载均衡</span><br>    <span class="hljs-attr">loadbalancer:</span><br>      <span class="hljs-attr">nacos:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>现在我们重启借阅服务，会发现优先调用的是同区域的用户和图书服务，现在我们可以将成都地区的服务下线：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nbhisubdj22d20ekjtk.jpg" alt="image-20220326153002500"></p><p>可以看到，在下线之后，由于本区域内没有可用服务了，借阅服务将会调用重庆区域的用户服务。</p><p>除了根据区域优先调用之外，同一个区域内的实例也可以单独设置权重，Nacos会优先选择权重更大的实例进行调用，我们可以直接在管理页面中进行配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nbecloluj22co0n841e.jpg" alt="image-20220326152659294"></p><p>或是在配置文件中进行配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">Chengdu</span><br>        <span class="hljs-comment"># 权重大小，越大越优先调用，默认为1</span><br>        <span class="hljs-attr">weight:</span> <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure><p>通过配置权重，某些性能不太好的机器就能够更少地被使用，而更多的使用那些网络良好性能更高的主机上的实例。</p><h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>前面我们学习了SpringCloud Config，我们可以通过配置服务来加载远程配置，这样我们就可以在远端集中管理配置文件。</p><p>实际上我们可以在<code>bootstrap.yml</code>中配置远程配置文件获取，然后再进入到配置文件加载环节，而Nacos也支持这样的操作，使用方式也比较类似，比如我们现在想要将借阅服务的配置文件放到Nacos进行管理，那么这个时候就需要在Nacos中创建配置文件：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ncoc8fwqj22mq0gidi8.jpg" alt="image-20220326161111523"></p><p>将借阅服务的配置文件全部（当然正常情况下是不会全部CV的，只会复制那些需要经常修改的部分，这里为了省事就直接全部CV了）复制过来，注意<strong>Data ID</strong>的格式跟我们之前一样，<code>应用名称-环境.yml</code>，如果只编写应用名称，那么代表此配置文件无论在什么环境下都会使用，然后每个配置文件都可以进行分组，也算是一种分类方式：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ncyoyq7ij21sw0u0n0o.jpg" alt="image-20220326162108899"></p><p>完成之后点击发布即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ncyx3tjnj22cs0bedhs.jpg" alt="image-20220326162122134"></p><p>然后在项目中导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们在借阅服务中添加<code>bootstrap.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>  <span class="hljs-comment"># 服务名称和配置文件保持一致</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">profiles:</span><br>  <span class="hljs-comment"># 环境也是和配置文件保持一致</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 配置文件后缀名</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yml</span><br>        <span class="hljs-comment"># 配置中心服务器地址，也就是Nacos地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure><p>现在我们启动服务试试看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ndcx7e8sj22lw0eiwlz.jpg" alt="image-20220326163449032"></p><p>可以看到成功读取配置文件并启动了，实际上使用上来说跟之前的Config是基本一致的。</p><p>Nacos还支持配置文件的热更新，比如我们在配置文件中添加了一个属性，而这个时候可能需要实时修改，并在后端实时更新，那么这种该怎么实现呢？我们创建一个新的Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;test.txt&#125;&quot;)</span>  <span class="hljs-comment">//我们从配置文件中读取test.txt的字符串值，作为test接口的返回值</span><br>    String txt;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> txt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们修改一下配置文件，然后重启服务器：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ndkk16naj22bs0lstc8.jpg" alt="image-20220326164209154"></p><p>可以看到已经可以正常读取了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ndljhdc8j217e06it93.jpg" alt="image-20220326164306032"></p><p>现在我们将配置文件的值进行修改：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ndo2g2ouj210e04mmxb.jpg" alt="image-20220326164531412"></p><p>再次访问接口，会发现没有发生变化：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ndodjuhkj2126068jrq.jpg" alt="image-20220326164549862"></p><p>但是后台是成功检测到值更新了，但是值却没改变：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ndpco63fj222e03cq4n.jpg" alt="image-20220326164645791"></p><p>那么如何才能实现配置热更新呢？我们可以像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span>   <span class="hljs-comment">//添加此注解就能实现自动刷新了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;test.txt&#125;&quot;)</span><br>    String txt;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> txt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启服务器，再次重复上述实验，成功。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>我们还可以将配置文件或是服务实例划分到不同的命名空间中，其实就是区分开发、生产环境或是引用归属之类的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0new72nlcj22ci0bat9o.jpg" alt="image-20220326172756819"></p><p>这里我们创建一个新的命名空间：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nf6e5ml4j22aa0j875n.jpg" alt="image-20220326173744551"></p><p>可以看到在dev命名空间下，没有任何配置文件和服务：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nfmz4j3gj22mq0j6gom.jpg" alt="image-20220326175340892"></p><p>我们在不同的命名空间下，实例和配置都是相互之间隔离的，我们也可以在配置文件中指定当前的命名空间。</p><h3 id="实现高可用"><a href="#实现高可用" class="headerlink" title="实现高可用"></a>实现高可用</h3><p>由于Nacos暂不支持Arm架构芯片的Mac集群搭建，本小节用Linxu云主机（Nacos比较吃内存，2个Nacos服务器集群，至少2G内存）环境演示。</p><p>通过前面的学习，我们已经了解了如何使用Nacos以及Nacos的功能等，最后我们来看看，如果像之前Eureka一样，搭建Nacos集群，实现高可用。</p><p>官方方案：<a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p><p><img src="https://nacos.io/img/deployDnsVipMode.jpg" alt="deployDnsVipMode.jpg"></p><blockquote><p><a href="http://ip1:port/openAPI">http://ip1:port/openAPI</a> 直连ip模式，机器挂则需要修改ip才可以使用。</p><p><a href="http://SLB:port/openAPI">http://SLB:port/openAPI</a> 挂载SLB模式(内网SLB，不可暴露到公网，以免带来安全风险)，直连SLB即可，下面挂server真实ip，可读性不好。</p><p><a href="http://nacos.com:port/openAPI">http://nacos.com:port/openAPI</a> 域名 + SLB模式(内网SLB，不可暴露到公网，以免带来安全风险)，可读性好，而且换ip方便，推荐模式</p></blockquote><p>我们来看看它的架构设计，它推荐我们在所有的Nacos服务端之前建立一个负载均衡，我们通过访问负载均衡服务器来间接访问到各个Nacos服务器。实际上就，是比如有三个Nacos服务器做集群，但是每个服务不可能把每个Nacos都去访问一次进行注册，实际上只需要在任意一台Nacos服务器上注册即可，Nacos服务器之间会自动同步信息，但是如果我们随便指定一台Nacos服务器进行注册，如果这台Nacos服务器挂了，但是其他Nacos服务器没挂，这样就没办法完成注册了，但是实际上整个集群还是可用的状态。</p><p>所以这里就需要在所有Nacos服务器之前搭建一个SLB（服务器负载均衡），这样就可以避免上面的问题了。但是我们知道，如果要实现外界对服务访问的负载均衡，我们就得用比如之前说到的Gateway来实现，而这里实际上我们可以用一个更加方便的工具：Nginx，来实现（之前我们没讲过，但是使用起来很简单，放心后面会带着大家使用）</p><p>关于SLB最上方还有一个DNS（我们在<code>计算机网络</code>这门课程中学习过），这个是因为SLB是裸IP，如果SLB服务器修改了地址，那么所有微服务注册的地址也得改，所以这里是通过加域名，通过域名来访问，让DNS去解析真实IP，这样就算改变IP，只需要修改域名解析记录即可，域名地址是不会变化的。</p><p>最后就是Nacos的数据存储模式，在单节点的情况下，Nacos实际上是将数据存放在自带的一个嵌入式数据库中：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nng0ithgj215i0b875m.jpg" alt="image-20220326222343802"></p><p>而这种模式只适用于单节点，在多节点集群模式下，肯定是不能各存各的，所以，Nacos提供了MySQL统一存储支持，我们只需要让所有的Nacos服务器连接MySQL进行数据存储即可，官方也提供好了SQL文件。</p><p>现在就可以开始了，第一步，我们直接导入数据库即可，文件在conf目录中：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0nnjw4980j2154090jtf.jpg" alt="image-20220326222728745"></p><p>我们来将其导入到数据库，可以看到生成了很多的表：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0nnmgm3g0j21580cqgod.jpg" alt="image-20220326222957239"></p><p>然后我们来创建两个Nacos服务器，做一个迷你的集群，这里使用<code>scp</code>命令将nacos服务端上传到Linux服务器（注意需要提前安装好JRE 8或更高版本的环境）：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ob09uny0j21880303z6.jpg" alt="image-20220327115901662"></p><p>解压之后，我们对其配置文件进行修改，首先是<code>application.properties</code>配置文件，修改以下内容，包括MySQL服务器的信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">### Default web server port:</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8801</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#*************** Config Module Related Configurations ***************#</span><br><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://cloudstudy.mysql.cn-chengdu.rds.aliyuncs.com:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">nacos</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">nacos</span><br></code></pre></td></tr></table></figure><p>然后修改集群配置，这里需要重命名一下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ob3otjt5j20yc01iglw.jpg" alt="image-20220327120219022"></p><p>端口记得使用内网IP地址：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0of8v91lzj211y05mjrr.jpg" alt="image-20220327142541523"></p><p>最后我们修改一下Nacos的内存分配以及前台启动，直接修改<code>startup.sh</code>文件（内存有限，玩不起高的）：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oci5kyrzj218m0acn0i.jpg" alt="image-20220327125049013"></p><p>保存之后，将nacos复制一份，并将端口修改为8802，接着启动这两个Nacos服务器。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ocjew7soj218408ktb8.jpg" alt="image-20220327125201913"></p><p>然后我们打开管理面板，可以看到两个节点都已经启动了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ocjy2a7dj22mo0j6jtq.jpg" alt="image-20220327125232238"></p><p>这样，我们第二步就完成了，接着我们需要添加一个SLB，这里我们用Nginx做反向代理：</p><blockquote><p><em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。它相当于在内网与外网之间形成一个网关，所有的请求都可以由Nginx服务器转交给内网的其他服务器。</p></blockquote><p>这里我们直接安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install nginx<br></code></pre></td></tr></table></figure><p>可以看到直接请求80端口之后得到，表示安装成功：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ocrv94q3j22mi0eidi8.jpg" alt="image-20220327130009391"></p><p>现在我们需要让其代理我们刚刚启动的两个Nacos服务器，我们需要对其进行一些配置。配置文件位于<code>/etc/nginx/nginx.conf</code>，添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs conf">#添加我们在上游刚刚创建好的两个nacos服务器<br>upstream nacos-server &#123;<br>        server 10.0.0.12:8801;<br>        server 10.0.0.12:8802;<br>&#125;<br><br>server &#123;<br>        listen   80;<br>        server_name  1.14.121.107;<br><br>        location /nacos &#123;<br>                proxy_pass http://nacos-server;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启Nginx服务器，成功连接：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ofsnlufwj21wa0u0wis.jpg" alt="image-20220327144441878"></p><p>然后我们将所有的服务全部修改为云服务器上Nacos的地址，启动试试看。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0og0j7z8dj22mg0l0gpk.jpg" alt="image-20220327145216771"></p><p>这样，我们就搭建好了Nacos集群。</p><hr><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oh42qki6j21ns0aw0th.jpg" alt="image-20220327153016414"></p><h2 id="Sentinel-流量防卫兵"><a href="#Sentinel-流量防卫兵" class="headerlink" title="Sentinel 流量防卫兵"></a>Sentinel 流量防卫兵</h2><p><strong>注意：</strong>这一章有点小绕，思路理清。</p><p>经过之前的学习，我们了解了微服务存在的雪崩问题，也就是说一个微服务出现问题，有可能导致整个链路直接不可用，这种时候我们就需要进行及时的熔断和降级，这些策略，我们之前通过使用Hystrix来实现。</p><p>SpringCloud Alibaba也有自己的微服务容错组件，但是它相比Hystrix更加的强大。</p><blockquote><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p></blockquote><p>Sentinel 具有以下特征:</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java&#x2F;Go&#x2F;C++ 等多语言的原生实现。</li><li><strong>完善的 SPI 扩展机制</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="安装与部署-1"><a href="#安装与部署-1" class="headerlink" title="安装与部署"></a>安装与部署</h3><p>和Nacos一样，它是独立安装和部署的，下载地址：<a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ohkq2u65j22qy0nogpw.jpg" alt="image-20220327154616456"></p><p>注意下载下来之后是一个<code>jar</code>文件（其实就是个SpringBoot项目），我们需要在IDEA中添加一些运行配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oiu9a58tj22ae0dgdjy.jpg" alt="image-20220327163002399"></p><p>接着就可以直接启动啦，当然默认端口占用8080，如果需要修改，可以添加环境变量：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oivfso85j218e04cmxt.jpg" alt="image-20220327163110733"></p><p>启动之后，就可以访问到Sentinel的监控页面了，用户名和密码都是<code>sentinel</code>，地址：<a href="http://localhost:8858/#/dashboard">http://localhost:8858/#/dashboard</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oiweerr4j22mg0dwwfm.jpg" alt="image-20220327163206117"></p><p>这样就成功开启监控页面了，接着我们需要让我们的服务连接到Sentinel控制台，老规矩，导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在配置文件中添加Sentinel相关信息（实际上Sentinel是本地在进行管理，但是我们可以连接到监控页面，这样就可以图形化操作了）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>      <span class="hljs-comment"># 添加监控页面地址即可</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8858</span><br></code></pre></td></tr></table></figure><p>现在启动我们的服务，然后访问一次服务，这样Sentinel中就会存在信息了（懒加载机制，不会一上来就加载）：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oj5uuyfwj21ny074js0.jpg" alt="image-20220327164111325"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oj8drp9hj223m0u00wi.jpg" alt="image-20220327164336877"></p><p>现在我们就可以在Sentinel控制台中对我们的服务运行情况进行实时监控了，可以看到监控的内容非常的多，包括时间点、QPS(每秒查询率)、响应时间等数据。</p><p>按照上面的方式，我们将所有的服务全部连接到Sentinel管理面板中。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>前面我们完成了对Sentinel的搭建与连接，接着我们来看看Sentinel的第一个功能，流量控制。</p><p>我们的机器不可能无限制的接受和处理客户端的请求，如果不加以限制，当发生高并发情况时，系统资源将很快被耗尽。为了避免这种情况，我们就可以添加流量控制（也可以说是限流）当一段时间内的流量到达一定的阈值的时候，新的请求将不再进行处理，这样不仅可以合理地应对高并发请求，同时也能在一定程度上保护服务器不受到外界的恶意攻击。</p><p>那么要实现限流，正常情况下，我们该采取什么样的策略呢？</p><ul><li>方案一：<strong>快速拒绝</strong>，既然不再接受新的请求，那么我们可以直接返回一个拒绝信息，告诉用户访问频率过高。</li><li>方案二：<strong>预热</strong>，依然基于方案一，但是由于某些情况下高并发请求是在某一时刻突然到来，我们可以缓慢地将阈值提高到指定阈值，形成一个缓冲保护。</li><li>方案三：<strong>排队等待</strong>，不接受新的请求，但是也不直接拒绝，而是进队列先等一下，如果规定时间内能够执行，那么就执行，要是超时就算了。</li></ul><p>针对于是否超过流量阈值的判断，这里我们提4种算法：</p><ol><li><p><strong>漏桶算法</strong></p><p>顾名思义，就像一个桶开了一个小孔，水流进桶中的速度肯定是远大于水流出桶的速度的，这也是最简单的一种限流思路：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0okai0crij21om08kgmz.jpg" alt="image-20220327172014949"></p><p>我们知道，桶是有容量的，所以当桶的容量已满时，就装不下水了，这时就只有丢弃请求了。</p><p>利用这种思想，我们就可以写出一个简单的限流算法。</p></li><li><p><strong>令牌桶算法</strong></p><p>只能说有点像信号量机制。现在有一个令牌桶，这个桶是专门存放令牌的，每隔一段时间就向桶中丢入一个令牌（速度由我们指定）当新的请求到达时，将从桶中删除令牌，接着请求就可以通过并给到服务，但是如果桶中的令牌数量不足，那么不会删除令牌，而是让此数据包等待。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0okow2vd5j21lg0gkdid.jpg" alt="image-20220327173323339"></p><p>可以试想一下，当流量下降时，令牌桶中的令牌会逐渐积累，这样如果突然出现高并发，那么就能在短时间内拿到大量的令牌。</p></li><li><p><strong>固定时间窗口算法</strong></p><p>我们可以对某一个时间段内的请求进行统计和计数，比如在<code>14:15</code>到<code>14:16</code>这一分钟内，请求量不能超过<code>100</code>，也就是一分钟之内不能超过<code>100</code>次请求，那么就可以像下面这样进行划分：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0okvim48fj219404274n.jpg" alt="image-20220327174027199"></p><p>虽然这种模式看似比较合理，但是试想一下这种情况：</p><ul><li>14:15:59的时候来了100个请求</li><li>14:16:01的时候又来了100个请求</li></ul><p>出现上面这种情况，符合固定时间窗口算法的规则，所以这200个请求都能正常接受，但是，如果你反应比较快，应该发现了，我们其实希望的是60秒内只有100个请求，但是这种情况却是在3秒内出现了200个请求，很明显已经违背了我们的初衷。</p><p>因此，当遇到临界点时，固定时间窗口算法存在安全隐患。</p></li><li><p><strong>滑动时间窗口算法</strong></p><p>相对于固定窗口算法，滑动时间窗口算法更加灵活，它会动态移动窗口，重新进行计算：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ol4irdckj21fs0jggnr.jpg" alt="image-20220327174906227"></p><p>虽然这样能够避免固定时间窗口的临界问题，但是这样显然是比固定窗口更加耗时的。</p></li></ol><p>好了，了解完了我们的限流策略和判定方法之后，我们在Sentinel中进行实际测试一下，打开管理页面的簇点链路模块：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ol71o173j229j0u0444.jpg" alt="image-20220327175131519"></p><p>这里演示对我们的借阅接口进行限流，点击<code>流控</code>，会看到让我们添加流控规则：</p><ul><li>阈值类型：QPS就是每秒钟的请求数量，并发线程数是按服务当前使用的线程数据进行统计的。</li><li>流控模式：当达到阈值时，流控的对象，这里暂时只用直接。</li><li>流控效果：就是我们上面所说的三种方案。</li></ul><p>这里我们选择<code>QPS</code>、阈值设定为<code>1</code>，流控模式选择<code>直接</code>、流控效果选择<code>快速失败</code>，可以看到，当我们快速地进行请求时，会直接返回失败信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ole5mz4jj21d406it9b.jpg" alt="image-20220327175821941"></p><p>这里各位最好自行尝试一下其他的流控效果，熟悉和加深印象。</p><p>最后我们来看看这些流控模式有什么区别：</p><ul><li>直接：只针对于当前接口。</li><li>关联：当其他接口超过阈值时，会导致当前接口被限流。</li><li>链路：更细粒度的限流，能精确到具体的方法。</li></ul><p>我们首先来看看关联，比如现在我们对自带的<code>/error</code>接口进行限流：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0om9w2tq0j224r0u0gq3.jpg" alt="image-20220327182851278"></p><p>注意限流是作用于关联资源的，一旦发现关联资源超过阈值，那么就会对当前的资源进行限流，我们现在来测试一下，这里使用PostMan的Runner连续对关联资源发起请求：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0omdvnxbxj21c00u0goi.jpg" alt="image-20220327183241316"></p><p>开启Postman，然后我们会发现借阅服务已经凉凉：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0omeqzhpij215o06c3z3.jpg" alt="image-20220327183331595"></p><p>当我们关闭掉Postman的任务后，恢复正常。</p><p>最后我们来讲解一下链路模式，它能够更加精准的进行流量控制，链路流控模式指的是，当从指定接口过来的资源请求达到限流条件时，开启限流，这里得先讲解一下<code>@SentinelResource</code>的使用。</p><p>我们可以对某一个方法进行限流控制，无论是谁在何处调用了它，这里需要使用到<code>@SentinelResource</code>，一旦方法被标注，那么就会进行监控，比如我们这里创建两个请求映射，都来调用Service的被监控方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow2/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SentinelResource(&quot;getBorrow&quot;)</span>   <span class="hljs-comment">//监控此方法，无论被谁执行都在监控范围内，这里给的value是自定义名称，这个注解可以加在任何方法上，包括Controller中的请求映射方法，跟HystrixCommand贼像</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; bookClient.getBookById(b.getBid()))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8858</span><br>      <span class="hljs-comment"># 关闭Context收敛，这样被监控方法可以进行不同链路的单独控制</span><br>      <span class="hljs-attr">web-context-unify:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>然后我们在Sentinel控制台中添加流控规则，注意是针对此方法，可以看到已经自动识别到borrow接口下调用了这个方法：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pfp1fhrcj22bh0u00yg.jpg" alt="image-20220328112645048"></p><p>最后我们在浏览器中对这两个接口都进行测试，会发现，无论请求哪个接口，只要调用了Service中的<code>getUserBorrowDetailByUid</code>这个方法，都会被限流。注意限流的形式是后台直接抛出异常，至于怎么处理我们后面再说。</p><p>那么这个链路选项实际上就是决定只限流从哪个方向来的调用，比如我们只对<code>borrow2</code>这个接口对<code>getUserBorrowDetailByUid</code>方法的调用进行限流，那么我们就可以为其指定链路：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pfs7hqj4j224s0u0dkb.jpg" alt="image-20220328112949894"></p><p>然后我们会发现，限流效果只对我们配置的链路接口有效，而其他链路是不会被限流的。</p><p>除了直接对接口进行限流规则控制之外，我们也可以根据当前系统的资源使用情况，决定是否进行限流：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0q18q6t5vj22dk0u0q72.jpg" alt="image-20220328235217680"></p><p>系统规则支持以下的模式：</p><ul><li><strong>Load 自适应</strong>（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li><li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li><li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li></ul><p>这里就不进行演示了。</p><h3 id="限流和异常处理"><a href="#限流和异常处理" class="headerlink" title="限流和异常处理"></a>限流和异常处理</h3><p>现在我们已经了解了如何进行限流操作，那么限流状态下的返回结果该怎么修改呢，我们看到被限流之后返回的是Sentinel默认的数据，现在我们希望自定义改如何操作？</p><p>这里我们先创建好被限流状态下需要返回的内容，定义一个请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/blocked&quot;)</span><br>JSONObject <span class="hljs-title function_">blocked</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    object.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">403</span>);<br>    object.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>    object.put(<span class="hljs-string">&quot;massage&quot;</span>, <span class="hljs-string">&quot;您的请求频率过快，请稍后再试！&quot;</span>);<br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在配置文件中将此页面设定为限流页面：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8858</span><br>      <span class="hljs-comment"># 将刚刚编写的请求映射设定为限流页面</span><br>      <span class="hljs-attr">block-page:</span> <span class="hljs-string">/blocked</span><br></code></pre></td></tr></table></figure><p>这样，当被限流时，就会被重定向到指定页面：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pmyc5o1uj21gi06m3zc.jpg" alt="image-20220328153755461"></p><p>那么，对于方法级别的限流呢？经过前面的学习我们知道，当某个方法被限流时，会直接在后台抛出异常，那么这种情况我们该怎么处理呢，比如我们之前在Hystrix中可以直接添加一个替代方案，这样当出现异常时会直接执行我们的替代方法并返回，Sentinel也可以。</p><p>比如我们还是在<code>getUserBorrowDetailByUid</code>方法上进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SentinelResource(value = &quot;getBorrow&quot;, blockHandler = &quot;blocked&quot;)</span>   <span class="hljs-comment">//指定blockHandler，也就是被限流之后的替代解决方案，这样就不会使用默认的抛出异常的形式了</span><br><span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>    List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>    List&lt;Book&gt; bookList = borrow<br>            .stream()<br>            .map(b -&gt; bookClient.getBookById(b.getBid()))<br>            .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>&#125;<br><br><span class="hljs-comment">//替代方案，注意参数和返回值需要保持一致，并且参数最后还需要额外添加一个BlockException</span><br><span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">blocked</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, BlockException e)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(<span class="hljs-literal">null</span>, Collections.emptyList());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，一旦被限流将执行替代方案，最后返回的结果就是：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pn56vzirj217y06kaai.jpg" alt="image-20220328154430549"></p><p>注意<code>blockHandler</code>只能处理限流情况下抛出的异常，包括下面即将要介绍的热点参数限流也是同理，如果是方法本身抛出的其他类型异常，不在管控范围内，但是可以通过其他参数进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@SentinelResource(value = &quot;test&quot;,</span><br><span class="hljs-meta">        fallback = &quot;except&quot;,    //fallback指定出现异常时的替代方案</span><br><span class="hljs-meta">        exceptionsToIgnore = IOException.class)</span>  <span class="hljs-comment">//忽略那些异常，也就是说这些异常出现时不使用替代方案</span><br>String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;HelloWorld！&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//替代方法必须和原方法返回值和参数一致，最后可以添加一个Throwable作为参数接受异常</span><br>String <span class="hljs-title function_">except</span><span class="hljs-params">(Throwable t)</span>&#123;<br>    <span class="hljs-keyword">return</span> t.getMessage();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，其他的异常也可以有替代方案了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0po5s15rej218u06uwev.jpg" alt="image-20220328161940219"></p><p>特别注意这种方式会在没有配置<code>blockHandler</code>的情况下，将Sentinel机制内（也就是限流的异常）的异常也一并处理了，如果配置了<code>blockHandler</code>，那么在出现限流时，依然只会执行<code>blockHandler</code>指定的替代方案（因为限流是在方法执行之前进行的）</p><h3 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>我们还可以对某一热点数据进行精准限流，比如在某一时刻，不同参数被携带访问的频率是不一样的：</p><ul><li><a href="http://localhost:8301/test?a=10">http://localhost:8301/test?a=10</a>  访问100次</li><li><a href="http://localhost:8301/test?b=10">http://localhost:8301/test?b=10</a>  访问0次</li><li><a href="http://localhost:8301/test?c=10">http://localhost:8301/test?c=10</a>  访问3次</li></ul><p>由于携带参数<code>a</code>的请求比较多，我们就可以只对携带参数<code>a</code>的请求进行限流。</p><p>这里我们创建一个新的测试请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@SentinelResource(&quot;test&quot;)</span>   <span class="hljs-comment">//注意这里需要添加@SentinelResource才可以，用户资源名称就使用这里定义的资源名称</span><br>String <span class="hljs-title function_">findUserBorrows2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;a&quot;, required = false)</span> <span class="hljs-type">int</span> a,</span><br><span class="hljs-params">                        <span class="hljs-meta">@RequestParam(value = &quot;b&quot;, required = false)</span> <span class="hljs-type">int</span> b,</span><br><span class="hljs-params">                        <span class="hljs-meta">@RequestParam(value = &quot;c&quot;,required = false)</span> <span class="hljs-type">int</span> c)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求成功！a = &quot;</span>+a+<span class="hljs-string">&quot;, b = &quot;</span>+b+<span class="hljs-string">&quot;, c = &quot;</span>+c;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动之后，我们在Sentinel里面进行热点配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0plrnnjlqj22fh0u0aec.jpg" alt="image-20220328145654180"></p><p>然后开始访问我们的测试接口，可以看到在携带参数a时，当访问频率超过设定值，就会直接被限流，这里是直接在后台抛出异常：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pls7lm97j21j20d6q4z.jpg" alt="image-20220328145726479"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0plto9gujj222e07imyn.jpg" alt="image-20220328145851133"></p><p>而我们使用其他参数或是不带<code>a</code>参数，那么就不会出现这种问题了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pltgil5hj214w07mwf3.jpg" alt="image-20220328145838378"></p><p>除了直接对某个参数精准限流外，我们还可以对参数携带的指定值单独设定阈值，比如我们现在不仅希望对参数<code>a</code>限流，而且还希望当参数<code>a</code>的值为10时，QPS达到5再进行限流，那么就可以设定例外：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0plwl48w0j220a0u0gp0.jpg" alt="image-20220328150138096"></p><p>这样，当请求携带参数<code>a</code>，且参数<code>a</code>的值为10时，阈值将按照我们指定的特例进行计算。</p><h3 id="服务熔断和降级"><a href="#服务熔断和降级" class="headerlink" title="服务熔断和降级"></a>服务熔断和降级</h3><p>还记得我们前所说的服务降级吗，也就是说我们需要在整个微服务调用链路出现问题的时候，及时对服务进行降级，以防止问题进一步恶化。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ky50sw4jj219s07yabg.jpg" alt="image-20220324141706946"></p><p>那么，各位是否有思考过，如果在某一时刻，服务B出现故障（可能就卡在那里了），而这时服务A依然有大量的请求，在调用服务B，那么，由于服务A没办法再短时间内完成处理，新来的请求就会导致线程数不断地增加，这样，CPU的资源很快就会被耗尽。</p><p>那么要防止这种情况，就只能进行隔离了，这里我们提两种隔离方案：</p><ol><li><p><strong>线程池隔离</strong></p><p>线程池隔离实际上就是对每个服务的远程调用单独开放线程池，比如服务A要调用服务B，那么只基于固定数量的线程池，这样即使在短时间内出现大量请求，由于没有线程可以分配，所以就不会导致资源耗尽了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ph7xi5qbj21fo09y404.jpg" alt="image-20220328121932455"></p></li><li><p><strong>信号量隔离</strong></p><p>信号量隔离是使用<code>Semaphore</code>类实现的（如果不了解，可以观看本系列 并发编程篇 视频教程），思想基本上与上面是相同的，也是限定指定的线程数量能够同时进行服务调用，但是它相对于线程池隔离，开销会更小一些，使用效果同样优秀，也支持超时等。</p><p>Sentinel也正是采用的这种方案实现隔离的。</p></li></ol><p>好了，说回我们的熔断和降级，当下游服务因为某种原因变得不可用或响应过慢时，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务而是快速返回或是执行自己的替代方案，这便是服务降级。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0phzsecsij20ig0i274r.jpg" alt="image-20220328124619289"></p><p>整个过程分为三个状态：</p><ul><li>关闭：熔断器不工作，所有请求全部该干嘛干嘛。</li><li>打开：熔断器工作，所有请求一律降级处理。</li><li>半开：尝试进行一下下正常流程，要是还不行继续保持打开状态，否则关闭。</li></ul><p>那么我们来看看Sentinel中如何进行熔断和降级操作，打开管理页面，我们可以自由新增熔断规则：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pi4xii37j22mo0t4dku.jpg" alt="image-20220328125115760"></p><p>其中，熔断策略有三种模式：</p><ol><li><p><strong>慢调用比例：</strong>如果出现那种半天都处理不完的调用，有可能就是服务出现故障，导致卡顿，这个选项是按照最大响应时间（RT）进行判定，如果一次请求的处理时间超过了指定的RT，那么就被判定为<code>慢调用</code>，在一个统计时长内，如果请求数目大于最小请求数目，并且被判定为<code>慢调用</code>的请求比例已经超过阈值，将触发熔断。经过熔断时长之后，将会进入到半开状态进行试探（这里和Hystrix一致）</p><p>然后修改一下接口的执行，我们模拟一下慢调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/borrow2/&#123;uid&#125;&quot;)</span><br>UserBorrowDetail <span class="hljs-title function_">findUserBorrows2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启，然后我们创建一个新的熔断规则：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pipk23g6j227a0o0tbt.jpg" alt="image-20220328131105084"></p><p>可以看到，超时直接触发了熔断，进入到阻止页面：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pior2olsj21nm088wf8.jpg" alt="image-20220328131018951"></p></li><li><p><strong>异常比例：</strong>这个与慢调用比例类似，不过这里判断的是出现异常的次数，与上面一样，我们也来进行一些小测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/borrow2/&#123;uid&#125;&quot;)</span><br>UserBorrowDetail <span class="hljs-title function_">findUserBorrows2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>启动服务器，接着添加我们的熔断规则：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pj3qutgtj225o0noju9.jpg" alt="image-20220328132443315"></p><p>现在我们进行访问，会发现后台疯狂报错，然后就熔断了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pj7f4fgbj22180cswjm.jpg" alt="image-20220328132815856"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pj78bdkgj21a606i3z5.jpg" alt="image-20220328132804164"></p></li><li><p><strong>异常数：</strong>这个和上面的唯一区别就是，只要达到指定的异常数量，就熔断，这里我们修改一下熔断规则：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pj8oajy0j221u0nk419.jpg" alt="image-20220328132927745"></p><p>现在我们再次不断访问此接口，可以发现，效果跟之前其实是差不多的，只是判断的策略稍微不同罢了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pj78bdkgj21a606i3z5.jpg" alt="image-20220328132804164"></p></li></ol><p>那么熔断规则如何设定我们了解了，那么，如何自定义服务降级呢？之前在使用Hystrix的时候，如果出现异常，可以执行我们的替代方案，Sentinel也是可以的。</p><p>同样的，我们只需要在<code>@SentinelResource</code>中配置<code>blockHandler</code>参数（那这里跟前面那个方法限流的配置不是一毛一样吗？没错，因为如果添加了<code>@SentinelResource</code>注解，那么这里会进行方法级别细粒度的限制，和之前方法级别限流一样，会在降级之后直接抛出异常，如果不添加则返回默认的限流页面，<code>blockHandler</code>的目的就是处理这种Sentinel机制上的异常，所以这里其实和之前的限流配置是一个道理，因此下面熔断配置也应该对<code>value</code>自定义名称的资源进行配置，才能作用到此方法上）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/borrow2/&#123;uid&#125;&quot;)</span><br><span class="hljs-meta">@SentinelResource(value = &quot;findUserBorrows2&quot;, blockHandler = &quot;test&quot;)</span><br>UserBorrowDetail <span class="hljs-title function_">findUserBorrows2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br><br>UserBorrowDetail <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, BlockException e)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(), Collections.emptyList());<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们对进行熔断配置，注意是对我们添加的<code>@SentinelResource</code>中指定名称的<code>findUserBorrows2</code>进行配置：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pno8hcvoj22le0nuafl.jpg" alt="image-20220328160248977"></p><p>OK，可以看到熔断之后，服务降级之后的效果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pnmjycafj21ci06o3z9.jpg" alt="image-20220328160112038"></p><p>最后我们来看一下如何让Feign的也支持Sentinel，前面我们使用Hystrix的时候，就可以直接对Feign的每个接口调用单独进行服务降级，而使用Sentinel，也是可以的，首先我们需要在配置文件中开启支持：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>之后的步骤其实和之前是一模一样的，首先创建实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserClient</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;我是替代方案&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后直接启动就可以了，中途的时候我们吧用户服务全部下掉，可以看到正常使用替代方案：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0pp7oe8yuj228k06iwfy.jpg" alt="image-20220328165606119"></p><p>这样Feign的配置就OK了，那么传统的RestTemplate呢？我们可以使用<code>@SentinelRestTemplate</code>注解实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@SentinelRestTemplate(blockHandler = &quot;handleException&quot;, blockHandlerClass = ExceptionUtil.class,</span><br><span class="hljs-meta">    fallback = &quot;fallback&quot;, fallbackClass = ExceptionUtil.class)</span> <span class="hljs-comment">//这里同样可以设定fallback等参数</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就不多做赘述了。</p><hr><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0qla4zlihj21m0064glz.jpg" alt="image-20220329112537891"></p><h2 id="Seata与分布式事务"><a href="#Seata与分布式事务" class="headerlink" title="Seata与分布式事务"></a>Seata与分布式事务</h2><p>重难点内容，坑也多得离谱，最好保持跟UP一样的版本，<strong>官方文档：</strong><a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p><p>在前面的阶段中，我们学习过事务，还记得我们之前谈到的数据库事务的特性吗？</p><ul><li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>那么各位试想一下，在分布式环境下，有可能出现这样一个问题，比如我们下单购物，那么整个流程可能是这样的：先调用库存服务对库存进行减扣 -&gt; 然后订单服务开始下单 -&gt; 最后用户账户服务进行扣款，虽然看似是一个很简单的一个流程，但是如果没有事务的加持，很有可能会由于中途出错，比如整个流程中订单服务出现问题，那么就会导致库存扣了，但是实际上这个订单并没有生成，用户也没有付款。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0qkx2w3olj21jo0763zr.jpg" alt="image-20220329111304542"></p><p>上面这种情况时间就是一种多服务多数据源的分布式事务模型（比较常见），因此，为了解决这种情况，我们就得实现分布式事务，让这整个流程保证原子性。</p><p>SpringCloud Alibaba为我们提供了用于处理分布式事务的组件Seata。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0qlfjws7cj21da0qkmzw.jpg" alt="image-20220329113049408"></p><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><p>实际上，就是多了一个中间人来协调所有服务的事务。</p><h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a>项目环境搭建</h3><p>这里我们对我们之前的图书管理系统进行升级：</p><ul><li>每个用户最多只能同时借阅2本不同的书。</li><li>图书馆中所有的书都有3本。</li><li>用户借书流程：先调用图书服务书籍数量-1 -&gt;  添加借阅记录  -&gt;  调用用户服务用户可借阅数量-1</li></ul><p>那么首先我们对数据库进行修改，这里为了简便，就直接在用户表中添加一个字段用于存储用户能够借阅的书籍数量：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0qph7expaj21io07e0tt.jpg" alt="image-20220329135048063"></p><p>然后修改书籍信息，也是直接添加一个字段用于记录剩余数量：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0qpjm6mlaj21i006k3ze.jpg" alt="image-20220329135307659"></p><p>接着我们去编写一下对应的服务吧，首先是用户服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from DB_USER where uid = #&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;select book_count from DB_USER where uid = #&#123;uid&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getUserBookRemain</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br><br>    <span class="hljs-meta">@Update(&quot;update DB_USER set book_count = #&#123;count&#125; where uid = #&#123;uid&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateBookCount</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getUserById(uid);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRemain</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getUserBookRemain(uid);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setRemain</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.updateBookCount(uid, count) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserById(uid);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/remain/&#123;uid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">userRemain</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getRemain(uid);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/borrow/&#123;uid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">userBorrow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remain</span> <span class="hljs-operator">=</span> service.getRemain(uid);<br>        <span class="hljs-keyword">return</span> service.setRemain(uid, remain - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是图书服务，其实跟用户服务差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from DB_BOOK where bid = #&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;select count from DB_BOOK  where bid = #&#123;bid&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getRemain</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br><br>    <span class="hljs-meta">@Update(&quot;update DB_BOOK set count = #&#123;count&#125;  where bid = #&#123;bid&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">setRemain</span><span class="hljs-params">(<span class="hljs-type">int</span> bid, <span class="hljs-type">int</span> count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getBookById(bid);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setRemain</span><span class="hljs-params">(<span class="hljs-type">int</span> bid, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.setRemain(bid, count) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRemain</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getRemain(bid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">findBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getBookById(bid);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/remain/&#123;bid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bookRemain</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getRemain(uid);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/borrow/&#123;bid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bookBorrow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remain</span> <span class="hljs-operator">=</span> service.getRemain(uid);<br>        <span class="hljs-keyword">return</span> service.setRemain(uid, remain - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后完善我们的借阅服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/borrow/&#123;uid&#125;&quot;)</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">userBorrow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/remain/&#123;uid&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">userRemain</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;bookservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookClient</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/borrow/&#123;bid&#125;&quot;)</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">bookBorrow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/remain/&#123;bid&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">bookRemain</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/take/&#123;uid&#125;/&#123;bid&#125;&quot;)</span><br>    JSONObject <span class="hljs-title function_">borrow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid,</span><br><span class="hljs-params">                      <span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>&#123;<br>        service.doBorrow(uid, bid);<br><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        object.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>);<br>        object.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>        object.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;借阅成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; bookClient.getBookById(b.getBid()))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doBorrow</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> bid)</span> &#123;<br>      <span class="hljs-comment">//1. 判断图书和用户是否都支持借阅</span><br>        <span class="hljs-keyword">if</span>(bookClient.bookRemain(bid) &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;图书数量不足&quot;</span>);<br>        <span class="hljs-keyword">if</span>(userClient.userRemain(uid) &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户借阅量不足&quot;</span>);<br>      <span class="hljs-comment">//2. 首先将图书的数量-1</span><br>        <span class="hljs-keyword">if</span>(!bookClient.bookBorrow(bid))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;在借阅图书时出现错误！&quot;</span>);<br>      <span class="hljs-comment">//3. 添加借阅信息</span><br>        <span class="hljs-keyword">if</span>(mapper.getBorrow(uid, bid) != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;此书籍已经被此用户借阅了！&quot;</span>);<br>        <span class="hljs-keyword">if</span>(mapper.addBorrow(uid, bid) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;在录入借阅信息时出现错误！&quot;</span>);<br>      <span class="hljs-comment">//4. 用户可借阅-1</span><br>        <span class="hljs-keyword">if</span>(!userClient.userBorrow(uid))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;在借阅时出现错误！&quot;</span>);<br>      <span class="hljs-comment">//完成</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，只要我们的图书借阅过程中任何一步出现问题，都会抛出异常。</p><p>我们来测试一下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0qrwk3pc6j21fo070aav.jpg" alt="image-20220329151445740"></p><p>再次尝试借阅，后台会直接报错：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0qrx0lrghj21oi06umzv.jpg" alt="image-20220329151512871"></p><p>抛出异常，但是我们发现一个问题，借阅信息添加失败了，但是图书的数量依然被-1，也就是说正常情况下，我们是希望中途出现异常之后，之前的操作全部回滚的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0qry46lk7j214o05s3z9.jpg" alt="image-20220329151615894"></p><p>而这里由于是在另一个服务中进行的数据库操作，所以传统的<code>@Transactional</code>注解无效，这时就得借助Seata提供分布式事务了。</p><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p>要开始实现分布式事务，我们得先从理论上开始下手，我们来了解一下常用的分布式事务解决方案。</p><ol><li><p><strong>XA分布式事务协议 - 2PC（两阶段提交实现）</strong></p><p>这里的PC实际上指的是Prepare和Commit，也就是说它分为两个阶段，一个是准备一个是提交，整个过程的参与者一共有两个角色，一个是事务的执行者，一个是事务的协调者，实际上整个分布式事务的运作都需要依靠协调者来维持：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0teawzsnnj21hc0duabp.jpg" alt="image-20220331214050440"></p><p>在准备和提交阶段，会进行：</p><ul><li><p><strong>准备阶段：</strong></p><p>一个分布式事务是由协调者来开启的，首先协调者会向所有的事务执行者发送事务内容，等待所有的事务执行者答复。</p><p>各个事务执行者开始执行事务操作，但是不进行提交，并将undo和redo信息记录到事务日志中。</p><p>如果事务执行者执行事务成功，那么就告诉协调者成功Yes，否则告诉协调者失败No，不能提交事务。</p></li><li><p><strong>提交阶段：</strong></p><p>当所有的执行者都反馈完成之后，进入第二阶段。</p><p>协调者会检查各个执行者的反馈内容，如果所有的执行者都返回成功，那么就告诉所有的执行者可以提交事务了，最后再释放锁资源。</p><p>如果有至少一个执行者返回失败或是超时，那么就让所有的执行者都回滚，分布式事务执行失败。</p></li></ul><p>虽然这种方式看起来比较简单，但是存在以下几个问题：</p><ul><li>事务协调者是非常核心的角色，一旦出现问题，将导致整个分布式事务不能正常运行。</li><li>如果提交阶段发生网络问题，导致某些事务执行者没有收到协调者发来的提交命令，将导致某些执行者提交某些执行者没提交，这样肯定是不行的。</li></ul></li><li><p><strong>XA分布式事务协议 - 3PC（三阶段提交实现）</strong></p><p>三阶段提交是在二阶段提交基础上的改进版本，主要是加入了超时机制，同时在协调者和执行者中都引入了超时机制。</p><p>三个阶段分别进行：</p><ul><li><p><strong>CanCommit阶段：</strong></p><p>协调者向执行者发送CanCommit请求，询问是否可以执行事务提交操作，然后开始等待执行者的响应。</p><p>执行者接收到请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态，否则返回No</p></li><li><p><strong>PreCommit阶段：</strong></p><p>协调者根据执行者的反应情况来决定是否可以进入第二阶段事务的PreCommit操作。</p><p>如果所有的执行者都返回Yes，则协调者向所有执行者发送PreCommit请求，并进入Prepared阶段，执行者接收到请求后，会执行事务操作，并将undo和redo信息记录到事务日志中，如果成功执行，则返回成功响应。</p><p>如果所有的执行者至少有一个返回No，则协调者向所有执行者发送abort请求，所有的执行者在收到请求或是超过一段时间没有收到任何请求时，会直接中断事务。</p></li><li><p><strong>DoCommit阶段：</strong></p><p>该阶段进行真正的事务提交。</p><p>协调者接收到所有执行者发送的成功响应，那么他将从PreCommit状态进入到DoCommit状态，并向所有执行者发送doCommit请求，执行者接收到doCommit请求之后，开始执行事务提交，并在完成事务提交之后释放所有事务资源，并最后向协调者发送确认响应，协调者接收到所有执行者的确认响应之后，完成事务（如果因为网络问题导致执行者没有收到doCommit请求，执行者会在超时之后直接提交事务，虽然执行者只是猜测协调者返回的是doCommit请求，但是因为前面的两个流程都正常执行，所以能够在一定程度上认为本次事务是成功的，因此会直接提交）</p><p>协调者没有接收至少一个执行者发送的成功响应（也可能是响应超时），那么就会执行中断事务，协调者会向所有执行者发送abort请求，执行者接收到abort请求之后，利用其在PreCommit阶段记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源，执行者完成事务回滚之后，向协调者发送确认消息， 协调者接收到参与者反馈的确认消息之后，执行事务的中断。</p></li></ul><p>相比两阶段提交，三阶段提交的优势是显而易见的，当然也有缺点：</p><ul><li>3PC在2PC的第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。</li><li>一旦参与者无法及时收到来自协调者的信息之后，会默认执行Commit，这样就不会因为协调者单方面的故障导致全局出现问题。</li><li>但是我们知道，实际上超时之后的Commit决策本质上就是一个赌注罢了，如果此时协调者发送的是abort请求但是超时未接收，那么就会直接导致数据一致性问题。</li></ul></li><li><p><strong>TCC（补偿事务）</strong></p><p>补偿事务TCC就是Try、Confirm、Cancel，它对业务有侵入性，一共分为三个阶段，我们依次来解读一下。</p><ul><li><p><strong>Try阶段：</strong></p><p>比如我们需要在借书时，将书籍的库存<code>-1</code>，并且用户的借阅量也<code>-1</code>，但是这个操作，除了直接对库存和借阅量进行修改之外，还需要将减去的值，单独存放到冻结表中，但是此时不会创建借阅信息，也就是说只是预先把关键的东西给处理了，预留业务资源出来。</p></li><li><p><strong>Confirm阶段：</strong></p><p>如果Try执行成功无误，那么就进入到Confirm阶段，接着之前，我们就该创建借阅信息了，只能使用Try阶段预留的业务资源，如果创建成功，那么就对Try阶段冻结的值，进行解冻，整个流程就完成了。当然，如果失败了，那么进入到Cancel阶段。</p></li><li><p><strong>Cancel阶段：</strong></p><p>不用猜了，那肯定是把冻结的东西还给人家，因为整个借阅操作压根就没成功。就像你付了款买了东西但是网络问题，导致交易失败，钱不可能不还给你吧。</p></li></ul><p>跟XA协议相比，TCC就没有协调者这一角色的参与了，而是自主通过上一阶段的执行情况来确保正常，充分利用了集群的优势，性能也是有很大的提升。但是缺点也很明显，它与业务具有一定的关联性，需要开发者去编写更多的补偿代码，同时并不一定所有的业务流程都适用于这种形式。</p></li></ol><h3 id="Seata机制简介"><a href="#Seata机制简介" class="headerlink" title="Seata机制简介"></a>Seata机制简介</h3><p>前面我们了解了一些分布式事务的解决方案，那么我们来看一下Seata是如何进行分布式事务的处理的。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0u80yrhjkj21tq0ok77i.jpg" alt="image-20220401144916943"></p><p>官网给出的是这样的一个架构图，那么图中的RM、TM、TC代表着什么意思呢？</p><ul><li>RM（Resource Manager）：用于直接执行本地事务的提交和回滚。</li><li>TM（Transaction Manager）：TM是分布式事务的核心管理者。比如现在我们需要在借阅服务中开启全局事务，来让其自身、图书服务、用户服务都参与进来，也就是说一般全局事务发起者就是TM。</li><li>TC（Transaction Manager）这个就是我们的Seata服务器，用于全局控制，比如在XA模式下就是一个协调者的角色，而一个分布式事务的启动就是由TM向TC发起请求，TC再来与其他的RM进行协调操作。</li></ul><blockquote><p>TM请求TC开启一个全局事务，TC会生成一个XID作为该全局事务的编号，XID会在微服务的调用链路中传播，保证将多个微服务的子事务关联在一起；RM请求TC将本地事务注册为全局事务的分支事务，通过全局事务的XID进行关联；TM请求TC告诉XID对应的全局事务是进行提交还是回滚；TC驱动RM将XID对应的自己的本地事务进行提交还是回滚；</p></blockquote><p>Seata支持4种事务模式，官网文档：<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p><ul><li><p>AT：本质上就是2PC的升级版，在 AT 模式下，用户只需关心自己的 “业务SQL”</p><ol><li>一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</li><li>二阶段如果确认提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可，当然如果需要回滚，那么就用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。</li></ol></li><li><p>TCC：和我们上面讲解的思路是一样的。</p></li><li><p>XA：同上，但是要求数据库本身支持这种模式才可以。</p></li><li><p>Saga：用于处理长事务，每个执行者需要实现事务的正向操作和补偿操作：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0u8i381g0j22au0p0gnt.jpg" alt="image-20220401150544921"></p></li></ul><p>那么，以AT模式为例，我们的程序如何才能做到不对业务进行侵入的情况下实现分布式事务呢？实际上，Seata客户端，是通过对数据源进行代理实现的，使用的是DataSourceProxy类，所以在程序这边，我们只需要将对应的代理类注册为Bean即可（0.9版本之后支持自动进行代理，不用我们手动操作）</p><p>接下来，我们就以AT模式为例进行讲解。</p><h3 id="使用file模式部署"><a href="#使用file模式部署" class="headerlink" title="使用file模式部署"></a>使用file模式部署</h3><p>Seata也是以服务端形式进行部署的，然后每个服务都是客户端，服务端下载地址：<a href="https://github.com/seata/seata/releases/download/v1.4.2/seata-server-1.4.2.zip">https://github.com/seata/seata/releases/download/v1.4.2/seata-server-1.4.2.zip</a></p><p>把源码也下载一下：<a href="https://github.com/seata/seata/archive/refs/heads/develop.zip">https://github.com/seata/seata/archive/refs/heads/develop.zip</a></p><p>下载完成之后，放入到IDEA项目目录中，添加启动配置，这里端口使用8868：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t2uouvdmj227k0fu429.jpg" alt="image-20220331150441431"></p><p>Seata服务端支持本地部署或是基于注册发现中心部署（比如Nacos、Eureka等），这里我们首先演示一下最简单的本地部署，不需要对Seata的配置文件做任何修改。</p><p>Seata存在着事务分组机制：</p><ul><li>事务分组：seata的资源逻辑，可以按微服务的需要，在应用程序（客户端）对自行定义事务分组，每组取一个名字。</li><li>集群：seata-server服务端一个或多个节点组成的集群cluster。 应用程序（客户端）使用时需要指定事务逻辑分组与Seata服务端集群（默认为default）的映射关系。</li></ul><p>为啥要设计成通过事务分组再直接映射到集群？干嘛不直接指定集群呢？获取事务分组到映射集群的配置。这样设计后，事务分组可以作为资源的逻辑隔离单位，出现某集群故障时可以快速failover，只切换对应分组，可以把故障缩减到服务级别，但前提也是你有足够server集群。</p><p>接着我们需要将我们的各个服务作为Seate的客户端，只需要导入依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">vgroup-mapping:</span><br>    <span class="hljs-comment"># 这里需要对事务组做映射，默认的分组名为 应用名称-seata-service-group，将其映射到default集群</span><br>    <span class="hljs-comment"># 这个很关键，一定要配置对，不然会找不到服务</span><br>      <span class="hljs-attr">bookservice-seata-service-group:</span> <span class="hljs-string">default</span><br>    <span class="hljs-attr">grouplist:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-string">localhost:8868</span><br></code></pre></td></tr></table></figure><p>这样就可以直接启动了，但是注意现在只是单纯地连接上，并没有开启任何的分布式事务。</p><p>现在我们接着来配置开启分布式事务，首先在启动类添加注解，此注解会添加一个后置处理器将数据源封装为支持分布式事务的代理数据源（虽然官方表示配置文件中已经默认开启了自动代理，但是UP主实测1.4.2版本下只能打注解的方式才能生效）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAutoDataSourceProxy</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(BookApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要在开启分布式事务的方法上添加<code>@GlobalTransactional</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GlobalTransactional</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doBorrow</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> bid)</span> &#123;<br>  <span class="hljs-comment">//这里打印一下XID看看，其他的服务业添加这样一个打印，如果一会都打印的是同一个XID，表示使用的就是同一个事务</span><br>    System.out.println(RootContext.getXID());<br>    <span class="hljs-keyword">if</span>(bookClient.bookRemain(bid) &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;图书数量不足&quot;</span>);<br>    <span class="hljs-keyword">if</span>(userClient.userRemain(uid) &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户借阅量不足&quot;</span>);<br>    <span class="hljs-keyword">if</span>(!bookClient.bookBorrow(bid))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;在借阅图书时出现错误！&quot;</span>);<br>    <span class="hljs-keyword">if</span>(mapper.getBorrow(uid, bid) != <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;此书籍已经被此用户借阅了！&quot;</span>);<br>    <span class="hljs-keyword">if</span>(mapper.addBorrow(uid, bid) &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;在录入借阅信息时出现错误！&quot;</span>);<br>    <span class="hljs-keyword">if</span>(!userClient.userBorrow(uid))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;在借阅时出现错误！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还没结束，我们前面说了，Seata会分析修改数据的sql，同时生成对应的反向回滚SQL，这个回滚记录会存放在undo_log 表中。所以要求每一个Client 都有一个对应的undo_log表（也就是说每个服务连接的数据库都需要创建这样一个表，这里由于我们三个服务都用的同一个数据库，所以说就只用在这个数据库中创建undo_log表即可），表SQL定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `undo_log`<br>(<br>  `id`            <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `branch_id`     <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `xid`           <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `context`       <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `rollback_info` LONGBLOB     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `log_status`    <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `log_created`   DATETIME     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `log_modified`  DATETIME     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `ext`           <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br></code></pre></td></tr></table></figure><p>创建完成之后，我们现在就可以启动三个服务了，我们来测试一下当出现异常的时候是不是会正常回滚：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t3rj1lyqj21kq06gwfc.jpg" alt="image-20220331153615187"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t3tr1a3ej214i05idgj.jpg" alt="image-20220331153823961"></p><p>首先第一次肯定是正常完成借阅操作的，接着我们再次进行请求，肯定会出现异常：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t3s88j4oj21rm0cwmze.jpg" alt="image-20220331153655710"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t3stb2oaj221g0a6jwj.jpg" alt="image-20220331153729453"></p><p>如果能在栈追踪信息中看到seata相关的包，那么说明分布式事务已经开始工作了，通过日志我们可以看到，出现了回滚操作：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t3ul16g8j222403c40z.jpg" alt="image-20220331153911759"></p><p>并且数据库中确实是回滚了扣除操作：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t3u8rckaj214i05idgj.jpg" alt="image-20220331153852374"></p><p>这样，我们就通过Seata简单地实现了分布式事务。</p><h3 id="使用nacos模式部署"><a href="#使用nacos模式部署" class="headerlink" title="使用nacos模式部署"></a>使用nacos模式部署</h3><p>前面我们实现了本地Seata服务的file模式部署，现在我们来看看如何让其配合Nacos进行部署，利用Nacos的配置管理和服务发现机制，Seata能够更好地工作。</p><p>我们先单独为Seata配置一个命名空间：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t4ejq5rlj22cu0ca3zx.jpg" alt="image-20220331155823306"></p><p>我们打开<code>conf</code>目录中的<code>registry.conf</code>配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">registry</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment"># 注册配置</span><br><span class="hljs-comment"># 可以看到这里可以选择类型，默认情况下是普通的file类型，也就是本地文件的形式进行注册配置</span><br><span class="hljs-comment"># 支持的类型如下，对应的类型在下面都有对应的配置</span><br><span class="hljs-comment">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 采用nacos方式会将seata服务端也注册到nacos中，这样客户端就可以利用服务发现自动找到seata服务</span><br><span class="hljs-comment"># 就不需要我们手动指定IP和端口了，不过看似方便，坑倒是不少，后面再说</span><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 应用名称，这里默认就行</span><br>    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;seata-server&quot;</span><br><span class="hljs-comment">    # Nacos服务器地址</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:8848&quot;</span><br><span class="hljs-comment">    # 这里使用的是SEATA_GROUP组，一会注册到Nacos中就是这个组</span><br>    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br><span class="hljs-comment">    # 这里就使用我们上面单独为seata配置的命名空间，注意填的是ID</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;89fc2145-4676-48b8-9edd-29e867879bcb&quot;</span><br><span class="hljs-comment">    # 集群名称，这里还是使用default</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br><span class="hljs-comment">    # Nacos的用户名和密码</span><br>    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-comment">  #...</span><br></code></pre></td></tr></table></figure><p>注册信息配置完成之后，接着我们需要将配置文件也放到Nacos中，让Nacos管理配置，这样我们就可以对配置进行热更新了，一旦环境需要变化，只需要直接在Nacos中修改即可。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">config</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment"># 这里我们也使用nacos</span><br><span class="hljs-comment">  # file、nacos 、apollo、zk、consul、etcd3</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 跟上面一样的配法</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8848&quot;</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;89fc2145-4676-48b8-9edd-29e867879bcb&quot;</span><br>    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br>    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><span class="hljs-comment">    # 这个不用改，默认就行</span><br>    <span class="hljs-attr">dataId</span> = <span class="hljs-string">&quot;seataServer.properties&quot;</span><br>  <span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p>接着，我们需要将配置导入到Nacos中，我们打开一开始下载的源码<code>script/config-center/nacos</code>目录，这是官方提供的上传脚本，我们直接运行即可（windows下没对应的bat就很蛋疼，可以使用git命令行来运行一下），这里我们使用这个可交互的版本：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t4ocvxg8j218k0fi0uu.jpg" alt="image-20220331160748379"></p><p>按照提示输入就可以了，不输入就使用的默认值，不知道为啥最新版本有四个因为参数过长还导入失败了，就离谱，不过不影响。</p><p>导入成功之后，可以在对应的命名空间下看到对应的配置（为啥非要一个一个配置项单独搞，就不能写一起吗）：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t4px1ddhj21ue0u0jwp.jpg" alt="image-20220331160918380"></p><p>注意，还没完，我们还需要将对应的事务组映射配置也添加上，DataId格式为<code>service.vgroupMapping.事务组名称</code>，比如我们就使用默认的名称，值全部依然使用default即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t4s0ehpxj22cc0detbd.jpg" alt="image-20220331161119169"></p><p>现在我们就完成了服务端的Nacos配置，接着我们需要对客户端也进行Nacos配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br><span class="hljs-comment"># 注册</span><br>  <span class="hljs-attr">registry:</span><br>  <span class="hljs-comment"># 使用Nacos</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>    <span class="hljs-comment"># 使用Seata的命名空间，这样才能正确找到Seata服务，由于组使用的是SEATA_GROUP，配置默认值就是，就不用配了</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">89fc2145-4676-48b8-9edd-29e867879bcb</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>  <span class="hljs-comment"># 配置</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">89fc2145-4676-48b8-9edd-29e867879bcb</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br></code></pre></td></tr></table></figure><p>现在我们就可以启动这三个服务了，可以在Nacos中看到Seata以及三个服务都正常注册了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t53eig40j22cq0asac4.jpg" alt="image-20220331162215864"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t53udw2dj22cm05mt9k.jpg" alt="image-20220331162241748"></p><p>接着我们就可以访问一下服务试试看了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t57awz7nj21kg06qt9j.jpg" alt="image-20220331162601073"></p><p>可以看到效果和上面是一样的，不过现在我们的注册和配置都继承在Nacos中进行了。</p><p>我们还可以配置一下事务会话信息的存储方式，默认是file类型，那么就会在运行目录下创建<code>file_store</code>目录，我们可以将其搬到数据库中存储，只需要修改一下配置即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t5a2q6itj22ca0aywgc.jpg" alt="image-20220331162840368"></p><p>将<code>store.session.mode</code>和<code>store.mode</code>的值修改为<code>db</code></p><p>接着我们对数据库信息进行一下配置：</p><ul><li>数据库驱动</li><li>数据库URL</li><li>数据库用户名密码</li></ul><p>其他的默认即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t5chy3tmj226y0u00yl.jpg" alt="image-20220331163100436"></p><p>接着我们需要将对应的数据库进行创建，创建seata数据库，然后直接CV以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- -------------------------------- The script used when storeMode is &#x27;db&#x27; --------------------------------</span><br><span class="hljs-comment">-- the table to store GlobalSession data</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `global_table`<br>(<br>    `xid`                       <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `transaction_id`            <span class="hljs-type">BIGINT</span>,<br>    `status`                    TINYINT      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `application_id`            <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>    `transaction_service_group` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>    `transaction_name`          <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">128</span>),<br>    `timeout`                   <span class="hljs-type">INT</span>,<br>    `begin_time`                <span class="hljs-type">BIGINT</span>,<br>    `application_data`          <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">2000</span>),<br>    `gmt_create`                DATETIME,<br>    `gmt_modified`              DATETIME,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`xid`),<br>    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),<br>    KEY `idx_transaction_id` (`transaction_id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4;<br><br><span class="hljs-comment">-- the table to store BranchSession data</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `branch_table`<br>(<br>    `branch_id`         <span class="hljs-type">BIGINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `xid`               <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `transaction_id`    <span class="hljs-type">BIGINT</span>,<br>    `resource_group_id` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>    `resource_id`       <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">256</span>),<br>    `branch_type`       <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">8</span>),<br>    `status`            TINYINT,<br>    `client_id`         <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>),<br>    `application_data`  <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">2000</span>),<br>    `gmt_create`        DATETIME(<span class="hljs-number">6</span>),<br>    `gmt_modified`      DATETIME(<span class="hljs-number">6</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`branch_id`),<br>    KEY `idx_xid` (`xid`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4;<br><br><span class="hljs-comment">-- the table to store lock data</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `lock_table`<br>(<br>    `row_key`        <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `xid`            <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">128</span>),<br>    `transaction_id` <span class="hljs-type">BIGINT</span>,<br>    `branch_id`      <span class="hljs-type">BIGINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `resource_id`    <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">256</span>),<br>    `table_name`     <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>    `pk`             <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">36</span>),<br>    `status`         TINYINT      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;0:locked ,1:rollbacking&#x27;</span>,<br>    `gmt_create`     DATETIME,<br>    `gmt_modified`   DATETIME,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`row_key`),<br>    KEY `idx_status` (`status`),<br>    KEY `idx_branch_id` (`branch_id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `distributed_lock`<br>(<br>    `lock_key`       <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `lock_value`     <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `expire`         <span class="hljs-type">BIGINT</span>,<br>    <span class="hljs-keyword">primary</span> key (`lock_key`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;HandleAllSession&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t5k6ifdbj21ga07yjro.jpg" alt="image-20220331163823920"></p><p>完成之后，重启Seata服务端即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t5qvps8pj21vi04kgo7.jpg" alt="image-20220331164449635"></p><p>看到了数据源初始化成功，现在已经在使用数据库进行会话存储了。</p><p>如果Seata服务端出现报错，可能是我们自定义事务组的名称太长了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t5wm6n02j22ee0bkagp.jpg" alt="image-20220331165020756"></p><p>将<code>globle_table</code>表的字段<code>transaction_server_group</code>长度适当增加一下即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0t5xcvn5kj214s0f4760.jpg" alt="image-20220331165103414"></p><p>到此，关于基于nacos模式下的Seata部署，就完成了。</p><p>虽然我们这里实现了分布式事务，但是还是给各位同学提出一个问题（可以把自己所认为的结果打在弹幕上），就我们目前这样的程序设计，在高并发下，真的安全吗？比如同一时间100个同学抢同一个书，但是我们知道同一个书就只有3本，如果这时真的同时来了100个请求要借书，会正常地只借出3本书吗？如果不正常，该如何处理？</p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务基础</title>
    <link href="/2022/10/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/10/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0d0lfurfij21o40d275h.jpg" alt="image-20220317173734208"></p><h1 id="微服务基础"><a href="#微服务基础" class="headerlink" title="微服务基础"></a>微服务基础</h1><h2 id="传统项目转型"><a href="#传统项目转型" class="headerlink" title="传统项目转型"></a>传统项目转型</h2><p>要说近几年最火热的话题，那还得是微服务，那么什么是微服务呢？</p><p>我们可以先从技术的演变开始看起，在我们学习JavaWeb之后，一般的网站开发模式为Servlet+JSP，但是实际上我们在学习了SSM之后，会发现这种模式已经远远落后了，第一，一个公司不可能去招那么多同时会前端+后端的开发人员，就算招到，也并不一定能保证两个方面都比较擅长，相比前后端分开学习的开发人员，显然后者的学习成本更低，专注度更高。因此前后端分离成为了一种新的趋势。通过使用SpringBoot，我们几乎可以很快速地开发一个高性能的单体应用，只需要启动一个服务端，我们整个项目就开始运行了，各项功能融于一体，开发起来也更加轻松。</p><p>但是随着我们项目的不断扩大，单体应用似乎显得有点乏力了。</p><p>随着越来越多的功能不断地加入到一个SpringBoot项目中，随着接口不断增加，整个系统就要在同一时间内响应更多类型的请求，显然，这种扩展方式是不可能无限使用下去的，总有一天，这个SpringBoot项目会庞大到运行缓慢。并且所有的功能如果都集成在单端上，那么所有的请求都会全部汇集到一台服务器上，对此服务器造成巨大压力。</p><p>可以试想一下，如果我们的电脑已经升级到i9-12900K，但是依然在运行项目的时候缓慢，无法同一时间响应成千上万的请求，那么这个问题就已经不是单纯升级机器配置可以解决的了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ghpknvdvj21zg0go78r.jpg" alt="image-20220320174622739"></p><p>传统单体架构应用随着项目规模的扩大，实际上会暴露越来越多的问题，尤其是一台服务器无法承受庞大的单体应用部署，并且单体应用的维护也会越来越困难，我们得寻找一种新的开发架构来解决这些问题了。</p><blockquote><p> In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p></blockquote><p>Martin Fowler在2014年提出了“微服务”架构，它是一种全新的架构风格。</p><ul><li>微服务把一个庞大的单体应用拆分为一个个的小型服务，比如我们原来的图书管理项目中，有登录、注册、添加、删除、搜索等功能，那么我们可以将这些功能单独做成一个个小型的SpringBoot项目，独立运行。</li><li>每个小型的微服务，都可以独立部署和升级，这样，就算整个系统崩溃，那么也只会影响一个服务的运行。</li><li>微服务之间使用HTTP进行数据交互，不再是单体应用内部交互了，虽然这样会显得更麻烦，但是带来的好处也是很直接的，甚至能突破语言限制，使用不同的编程语言进行微服务开发，只需要使用HTTP进行数据交互即可。</li><li>我们可以同时购买多台主机来分别部署这些微服务，这样，单机的压力就被分散到多台机器，并且每台机器的配置不一定需要太高，这样就能节省大量的成本，同时安全性也得到很大的保证。</li><li>甚至同一个微服务可以同时存在多个，这样当其中一个服务器出现问题时，其他服务器也在运行同样的微服务，这样就可以保证一个微服务的高可用。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0idyqgp12j21m00im0wa.jpg" alt="image-20220322090754438"></p><p>当然，这里只是简单的演示一下微服务架构，实际开发中肯定是比这个复杂得多的。</p><p>可见，采用微服务架构，更加能够应对当今时代下的种种考验，传统项目的开发模式，需要进行架构上的升级。</p><h2 id="走进SpringCloud"><a href="#走进SpringCloud" class="headerlink" title="走进SpringCloud"></a>走进SpringCloud</h2><p>前面我们介绍了微服务架构的优点，那么同样的，这些优点的背后也存在着诸多的问题：</p><ul><li>要实现微服务并不是说只需要简单地将项目进行拆分，我们还需要考虑对各个微服务进行管理、监控等，这样我们才能够及时地寻找和排查问题。因此微服务往往需要的是一整套解决方案，包括服务注册和发现、容灾处理、负载均衡、配置管理等。</li><li>它不像单体架构那种方便维护，由于部署在多个服务器，我们不得不去保证各个微服务能够稳定运行，在管理难度上肯定是高于传统单体应用的。</li><li>在分布式的环境下，单体应用的某些功能可能会变得比较麻烦，比如分布式事务。</li></ul><p>所以，为了更好地解决这些问题，SpringCloud正式登场。</p><p>SpringCloud是Spring提供的一套分布式解决方案，集合了一些大型互联网公司的开源产品，包括诸多组件，共同组成SpringCloud框架。并且，它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、熔断机制、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><p>由于中小型公司没有独立开发自己的分布式基础设施的能力，使用SpringCloud解决方案能够以最低的成本应对当前时代的业务发展。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ig93rk52j21ss0nytbj.jpg" alt="image-20220322102706256"></p><p>可以看到，SpringCloud整体架构的亮点是非常明显的，分布式架构下的各个场景，都有对应的组件来处理，比如基于Netflix（奈飞）的开源分布式解决方案提供的组件：</p><ul><li>Eureka  -  实现服务治理（服务注册与发现），我们可以对所有的微服务进行集中管理，包括他们的运行状态、信息等。</li><li>Ribbon  -  为服务之间相互调用提供负载均衡算法（现在被SpringCloudLoadBalancer取代）</li><li>Hystrix  -  断路器，保护系统，控制故障范围。暂时可以跟家里电闸的保险丝类比，当触电危险发生时能够防止进一步的发展。</li><li>Zuul   -     api网关，路由，负载均衡等多种作用，就像我们的路由器，可能有很多个设备都连接了路由器，但是数据包要转发给谁则是由路由器在进行（已经被SpringCloudGateway取代）</li><li>Config  -  配置管理，可以实现配置文件集中管理</li></ul><p>当然，这里只是进行简单的了解即可，实际上微服务的玩法非常多，我们后面的学习中将会逐步进行探索。</p><p>那么首先，我们就从注册中心开始说起。</p><hr><h2 id="Eureka-注册中心"><a href="#Eureka-注册中心" class="headerlink" title="Eureka 注册中心"></a>Eureka 注册中心</h2><p>官方文档：<a href="https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/">https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/</a></p><p><strong>小贴士：</strong>各位小伙伴在学习的过程中觉得有什么疑惑的可以直接查阅官方文档，我们会在每一个技术开始之前贴上官方文档的地址，方便各位进行查阅，同时在我们的课程中并不一定会完完整整地讲完整个框架的内容，有关详细的功能和使用方法文档中也是写的非常清楚的，感兴趣的可以深入学习哦。</p><h3 id="微服务项目结构"><a href="#微服务项目结构" class="headerlink" title="微服务项目结构"></a>微服务项目结构</h3><p>现在我们重新设计一下之前的图书管理系统项目，将原有的大型（也许 项目进行拆分，注意项目拆分一定要尽可能保证单一职责，相同的业务不要在多个微服务中重复出现，如果出现需要借助其他业务完成的服务，那么可以使用服务之间相互调用的形式来实现（之后会介绍）：</p><ul><li>登录验证服务：用于处理用户注册、登录、密码重置等，反正就是一切与账户相关的内容，包括用户信息获取等。</li><li>图书管理服务：用于进行图书添加、删除、更新等操作，图书管理相关的服务，包括图书的存储等和信息获取。</li><li>图书借阅服务：交互性比较强的服务，需要和登陆验证服务和图书管理服务进行交互。</li></ul><p>那么既然要将单体应用拆分为多个小型服务，我们就需要重新设计一下整个项目目录结构，这里我们就创建多个子项目，每一个子项目都是一个服务，这样由父项目统一管理依赖，就无需每个子项目都去单独管理依赖了，也更方便一点。</p><p>我们首先创建一个普通的SpringBoot项目：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jmp0yg1lj21zh0u0q8t.jpg" alt="image-20220323105531867"></p><p>然后不需要勾选任何依赖，直接创建即可，项目创建完成并初始化后，我们删除父工程的无用文件，只保留必要文件，像下面这样：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jmsk8wcrj21rw0lojt4.jpg" alt="image-20220323105859454"></p><p>接着我们就可以按照我们划分的服务，进行子工程创建了，创建一个新的Maven项目，注意父项目要指定为我们一开始创建的的项目，子项目命名随意：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jmv8tewij21rc0f640q.jpg" alt="image-20220323110133466"></p><p>子项目创建好之后，接着我们在子项目中创建SpringBoot的启动主类：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jn1w0ru4j21ra0kedkk.jpg" alt="image-20220323110756722"></p><p>接着我们点击运行，即可启动子项目了，实际上这个子项目就一个最简单的SpringBoot web项目，注意启动之后最下方有弹窗，我们点击”使用 服务”，这样我们就可以实时查看当前整个大项目中有哪些微服务了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jn3ah2t1j21by078t9h.jpg" alt="image-20220323110917997"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jn50f7aqj22po0kygus.jpg" alt="image-20220323111056940"></p><p>接着我们以同样的方法，创建其他的子项目，注意我们最好将其他子项目的端口设置得不一样，不然会导致端口占用，我们分别为它们创建<code>application.yml</code>文件：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jnbw1wi8j22ci0i2778.jpg" alt="image-20220323111733605"></p><p>接着我们来尝试启动一下这三个服务，正常情况下都是可以直接启动的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jnd7uz99j22q40ks7dw.jpg" alt="image-20220323111849846"></p><p>可以看到它们分别运行在不同的端口上，这样，就方便不同的程序员编写不同的服务了，提交当前项目代码时的冲突率也会降低。</p><p>接着我们来创建一下数据库，这里还是老样子，创建三个表即可，当然实际上每个微服务单独使用一个数据库服务器也是可以的，因为按照单一职责服务只会操作自己对应的表，这里UP主比较穷，就只用一个数据库演示了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jni9lpt1j214w09w3zd.jpg" alt="image-20220323112340995"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jnkydk2mj214y090t9h.jpg" alt="image-20220323112616538"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jnnhmt9vj214a072t99.jpg" alt="image-20220323112842758"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jnmlc81qj214806a0th.jpg" alt="image-20220323112750936"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jnn6v8jrj214o04y3yw.jpg" alt="image-20220323112825430"></p><p>创建好之后，结果如下，一共三张表，各位可以自行添加一些数据到里面，这就不贴出来了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0jno6ge9hj21go07mab1.jpg" alt="image-20220323112922396"></p><p>如果各位嫌麻烦的话可以下载<code>.sql</code>文件自行导入。</p><p>接着我们来稍微写一点业务，比如用户信息查询业务，我们先把数据库相关的依赖进行导入，这里依然使用Mybatis框架，首先在父项目中添加MySQL驱动和Lombok依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于不是所有的子项目都需要用到Mybatis，我们在父项目中只进行版本管理即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们就可以在用户服务子项目中添加此依赖了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着添加数据源信息（UP用到是阿里云的MySQL云数据库，各位注意修改一下数据库地址）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://cloudstudy.mysql.cn-chengdu.rds.aliyuncs.com:3306/cloudstudy</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>接着我们来写用户查询相关的业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> uid;<br>    String name;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from DB_USER where uid = #&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getUserById(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserService service;<br><br>    <span class="hljs-comment">//这里以RESTFul风格为例</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserById(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们访问即可拿到数据：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jredurecj213m06s74p.jpg" alt="image-20220323133820304"></p><p>同样的方式，我们完成一下图书查询业务，注意现在是在图书管理微服务中编写（别忘了导入Mybatis依赖以及配置数据源）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-type">int</span> bid;<br>    String title;<br>    String desc;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from DB_BOOK where bid = #&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookService</span> &#123;<br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getBookById(bid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">findBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getBookById(bid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样进行一下测试：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jro4g42vj215006sdgg.jpg" alt="image-20220323134742618"></p><p>这样，我们一个完整项目的就拆分成了多个微服务，不同微服务之间是独立进行开发和部署的。</p><h3 id="服务间调用"><a href="#服务间调用" class="headerlink" title="服务间调用"></a>服务间调用</h3><p>前面我们完成了用户信息查询和图书信息查询，现在我们来接着完成借阅服务。</p><p>借阅服务是一个关联性比较强的服务，它不仅仅需要查询借阅信息，同时可能还需要获取借阅信息下的详细信息，比如具体那个用户借阅了哪本书，并且用户和书籍的详情也需要同时出现，那么这种情况下，我们就需要去访问除了借阅表以外的用户表和图书表。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0js1udjp6j21oa0aw40q.jpg" alt="image-20220323140053749"></p><p>但是这显然是违反我们之前所说的单一职责的，相同的业务功能不应该重复出现，但是现在由需要在此服务中查询用户的信息和图书信息，那怎么办呢？我们可以让一个服务去调用另一个服务来获取信息。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0js4et40uj21q20agq52.jpg" alt="image-20220323140322502"></p><p>这样，图书管理微服务和用户管理微服务相对于借阅记录，就形成了一个生产者和消费者的关系，前者是生产者，后者便是消费者。</p><p>现在我们先将借阅关联信息查询完善了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Borrow</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> uid;<br>    <span class="hljs-type">int</span> bid;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BorrowMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from DB_BORROW where uid = #&#123;uid&#125;&quot;)</span><br>    List&lt;Borrow&gt; <span class="hljs-title function_">getBorrowsByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;select * from DB_BORROW where bid = #&#123;bid&#125;&quot;)</span><br>    List&lt;Borrow&gt; <span class="hljs-title function_">getBorrowsByBid</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;select * from DB_BORROW where bid = #&#123;bid&#125; and uid = #&#123;uid&#125;&quot;)</span><br>    Borrow <span class="hljs-title function_">getBorrow</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在有一个需求，需要查询用户的借阅详细信息，也就是说需要查询某个用户具体借了那些书，并且需要此用户的信息和所有已借阅的书籍信息一起返回，那么我们先来设计一下返回实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBorrowDetail</span> &#123;<br>    User user;<br>    List&lt;Book&gt; bookList;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是有一个问题，我们发现User和Book实体实际上是在另外两个微服务中定义的，相当于当前项目并没有定义这些实体类，那么怎么解决呢？</p><p>因此，我们可以将所有服务需要用到的实体类单独放入另一个一个项目中，然后让这些项目引用集中存放实体类的那个项目，这样就可以保证每个微服务的实体类信息都可以共用了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jsl18z1fj221e0bi0w1.jpg" alt="image-20220323141919836"></p><p>然后只需要在对应的类中引用此项目作为依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后新的公共实体类都可以在<code>commons</code>项目中进行定义了，现在我们接着来完成刚刚的需求，先定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BorrowService</span> &#123;<br><br>    UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-comment">//那么问题来了，现在拿到借阅关联信息了，怎么调用其他服务获取信息呢？</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要进行服务远程调用我们需要用到<code>RestTemplate</code>来进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-comment">//RestTemplate支持多种方式的远程调用</span><br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>        <span class="hljs-comment">//这里通过调用getForObject来请求其他服务，并将结果自动进行封装</span><br>        <span class="hljs-comment">//获取User信息</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.getForObject(<span class="hljs-string">&quot;http://localhost:8082/user/&quot;</span>+uid, User.class);<br>        <span class="hljs-comment">//获取每一本书的详细信息</span><br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; template.getForObject(<span class="hljs-string">&quot;http://localhost:8080/book/&quot;</span>+b.getBid(), Book.class))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们再最后完善一下Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在数据库中添加一点借阅信息，测试看看能不能正常获取（注意一定要保证三个服务都处于开启状态，否则远程调用会失败）：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jt4ccuywj226i06wdh5.jpg" alt="image-20220323143753567"></p><p>可以看到，结果正常，没有问题，远程调用成功。</p><p>这样，一个简易的图书管理系统的分布式项目就搭建完成了，<strong>这里记得把整个项目压缩打包备份一下</strong>，下一章学习SpringCloud Alibaba也需要进行配置。</p><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>前面我们了解了如何对单体应用进行拆分，并且也学习了如何进行服务之间的相互调用，但是存在一个问题，就是虽然服务拆分完成，但是没有一个比较合理的管理机制，如果单纯只是这样编写，在部署和维护起来，肯定是很麻烦的。可以想象一下，如果某一天这些微服务的端口或是地址大规模地发生改变，我们就不得不将服务之间的调用路径大规模的同步进行修改，这是多么可怕的事情。我们需要削弱这种服务之间的强关联性，因此我们需要一个集中管理微服务的平台，这时就要借助我们这一部分的主角了。</p><p>Eureka能够自动注册并发现微服务，然后对服务的状态、信息进行集中管理，这样当我们需要获取其他服务的信息时，我们只需要向Eureka进行查询就可以了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jthur4u0j21lu0dytam.jpg" alt="image-20220323145051821"></p><p>像这样的话，服务之间的强关联性就会被进一步削弱。</p><p>那么现在我们就来搭建一个Eureka服务器，只需要创建一个新的Maven项目即可，然后我们需要在父工程中添加一下SpringCloud的依赖，这里选用<code>2021.0.1</code>版本（Spring Cloud 最新的版本命名方式变更了，现在是 <em><strong>YEAR.x</strong></em> 这种命名方式，具体可以在官网查看：<a href="https://spring.io/projects/spring-cloud#learn%EF%BC%89%EF%BC%9A">https://spring.io/projects/spring-cloud#learn）：</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们为新创建的项目添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下载内容有点多，首次导入请耐心等待一下。</p><p>接着我们来创建主类，还是一样的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaServerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别着急启动！！！接着我们需要修改一下配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8888</span><br><span class="hljs-attr">eureka:</span><br><span class="hljs-comment"># 开启之前需要修改一下客户端设置（虽然是服务端</span><br>  <span class="hljs-attr">client:</span><br>  <span class="hljs-comment"># 由于我们是作为服务端角色，所以不需要获取服务端，改为false，默认为true</span><br><span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 暂时不需要将自己也注册到Eureka</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 将eureka服务端指向自己</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8888/eureka</span><br></code></pre></td></tr></table></figure><p>好了，现在差不多可以启动了，启动完成后，直接输入地址+端口即可访问Eureka的管理后台：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jui0bzpvj21l60u0wi1.jpg" alt="image-20220323152537322"></p><p>可以看到目前还没有任何的服务注册到Eureka，我们接着来配置一下我们的三个微服务，首先还是需要导入Eureka依赖（注意别导错了，名称里面有个starter的才是）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>  <span class="hljs-comment"># 跟上面一样，需要指向Eureka服务端地址，这样才能进行注册</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8888/eureka</span><br></code></pre></td></tr></table></figure><p>OK，无需在启动类添加注解，直接启动就可以了，然后打开Eureka的服务管理页面，可以看到我们刚刚开启的服务：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jv4mtugqj22lm0ec40f.jpg" alt="image-20220323154722373"></p><p>可以看到<code>8082</code>端口上的服务器，已经成功注册到Eureka了，但是这个服务名称怎么会显示为UNKNOWN，我们需要修改一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jval83b7j22ls0c60ul.jpg" alt="image-20220323155305545"></p><p>当我们的服务启动之后，会每隔一段时间跟Eureka发送一次心跳包，这样Eureka就能够感知到我们的服务是否处于正常运行状态。</p><p>现在我们用同样的方法，将另外两个微服务也注册进来：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jvhkpma7j22m80c2mzo.jpg" alt="image-20220323155948425"></p><p>那么，现在我们怎么实现服务发现呢？</p><p>也就是说，我们之前如果需要对其他微服务进行远程调用，那么就必须要知道其他服务的地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.getForObject(<span class="hljs-string">&quot;http://localhost:8082/user/&quot;</span>+uid, User.class);<br></code></pre></td></tr></table></figure><p>而现在有了Eureka之后，我们可以直接向其进行查询，得到对应的微服务地址，这里直接将服务名称替换即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Resource</span><br>    RestTemplate template;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br><br>        <span class="hljs-comment">//这里不用再写IP，直接写服务名称userservice</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.getForObject(<span class="hljs-string">&quot;http://userservice/user/&quot;</span>+uid, User.class);<br>        <span class="hljs-comment">//这里不用再写IP，直接写服务名称bookservice</span><br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; template.getForObject(<span class="hljs-string">&quot;http://bookservice/book/&quot;</span>+b.getBid(), Book.class))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们手动将RestTemplate声明为一个Bean，然后添加<code>@LoadBalanced</code>注解，这样Eureka就会对服务的调用进行自动发现，并提供负载均衡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    RestTemplate <span class="hljs-title function_">template</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以正常调用了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jw0nxoykj22720bqjsw.jpg" alt="image-20220323161809122"></p><p>不对啊，不是说有负载均衡的能力吗，怎么个负载均衡呢？</p><p>我们先来看看，同一个服务器实际上是可以注册很多个的，但是它们的端口不同，比如我们这里创建多个用户查询服务，我们现在将原有的端口配置修改一下，由IDEA中设定启动参数来决定，这样就可以多创建几个不同端口的启动项了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jwbxq00pj21ue0rcgqf.jpg" alt="image-20220323162858616"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jwch1eb2j21ng08ead5.jpg" alt="image-20220323162926482"></p><p>可以看到，在Eureka中，同一个服务出现了两个实例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jwd5r9bgj21w00c8mz4.jpg" alt="image-20220323163010052"></p><p>现在我们稍微修改一下用户查询，然后进行远程调用，看看请求是不是均匀地分配到这两个服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserService service;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我被调用拉！&quot;</span>);<br>        <span class="hljs-keyword">return</span> service.getUserById(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jwgqas0qj22ci0batb0.jpg" alt="image-20220323163335257"></p><p>可以看到，两个实例都能够均匀地被分配请求：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jwi0a3yhj21tk0gqq9l.jpg" alt="image-20220323163448765"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0jwi5kezyj21me0hmq83.jpg" alt="image-20220323163457877"></p><p>这样，服务自动发现以及简单的负载均衡就实现完成了，并且，如果某个微服务挂掉了，只要存在其他同样的微服务实例在运行，那么就不会导致整个微服务不可用，极大地保证了安全性。</p><h3 id="注册中心高可用"><a href="#注册中心高可用" class="headerlink" title="注册中心高可用"></a>注册中心高可用</h3><p>各位可否想过这样的一个问题？虽然Eureka能够实现服务注册和发现，但是如果Eureka服务器崩溃了，岂不是所有需要用到服务发现的微服务就GG了？</p><p>为了避免，这种问题，我们也可以像上面那样，搭建Eureka集群，存在多个Eureka服务器，这样就算挂掉其中一个，其他的也还在正常运行，就不会使得服务注册与发现不可用。当然，要是物理黑客直接炸了整个机房，那还是算了吧。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0k41ady28j21jy0iwmzt.jpg" alt="image-20220323205531185"></p><p>我们来看看如何搭建Eureka集群，这里由于机器配置不高，就搭建两个Eureka服务器组成集群。</p><p>首先我们需要修改一下Eureka服务端的配置文件，这里我们创建两个配置文件，：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8801</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eurekaserver</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>  <span class="hljs-comment"># 由于不支持多个localhost的Eureka服务器，但是又只有本地测试环境，所以就只能自定义主机名称了</span><br>  <span class="hljs-comment"># 主机名称改为eureka01</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka01</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 去掉register-with-eureka选项，让Eureka服务器自己注册到其他Eureka服务器，这样才能相互启用</span><br>    <span class="hljs-attr">service-url:</span><br>    <span class="hljs-comment"># 注意这里填写其他Eureka服务器的地址，不用写自己的</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka01:8801/eureka</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8802</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eurekaserver</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka02</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka01:8801/eureka</span><br></code></pre></td></tr></table></figure><p>这里由于我们修改成自定义的地址，需要在hosts文件中将其解析到172.0.0.1才能回到localhost，Mac下文件路径为<code>/etc/hosts</code>，Windows下为<code>C:\Windows\system32\drivers\etc\hosts</code>：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0k48bkgyoj212q07a0te.jpg" alt="image-20220323210218653"></p><p>对创建的两个配置文件分别添加启动配置，直接使用<code>spring.profiles.active</code>指定启用的配置文件即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0k4u09lpxj22aw0py0y5.jpg" alt="image-20220323212308857"></p><p>接着启动这两个注册中心，这两个Eureka管理页面都可以被访问，我们访问其中一个：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0k4fxnlxtj21yk0cytao.jpg" alt="image-20220323210937341"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0k4chvjv8j21rq07it9k.jpg" alt="image-20220323210619533"></p><p>可以看到下方<code>replicas</code>中已经包含了另一个Eureka服务器的地址，并且是可用状态。</p><p>接着我们需要将我们的微服务配置也进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>    <span class="hljs-comment"># 将两个Eureka的地址都加入，这样就算有一个Eureka挂掉，也能完成注册</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8801/eureka,</span> <span class="hljs-string">http://localhost:8802/eureka</span><br></code></pre></td></tr></table></figure><p>可以看到，服务全部成功注册，并且两个Eureka服务端都显示为已注册：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0k4gvpxdtj21vc0dm41j.jpg" alt="image-20220323211032311"></p><p>接着我们模拟一下，将其中一个Eureka服务器关闭掉，可以看到它会直接变成不可用状态：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0k4ke207fj21rm06w75k.jpg" alt="image-20220323211354516"></p><p>当然，如果这个时候我们重启刚刚关闭的Eureka服务器，会自动同步其他Eureka服务器的数据。</p><hr><h2 id="LoadBalancer-负载均衡"><a href="#LoadBalancer-负载均衡" class="headerlink" title="LoadBalancer 负载均衡"></a>LoadBalancer 负载均衡</h2><p>前面我们讲解了如何对服务进行拆分、如何通过Eureka服务器进行服务注册与发现，那么现在我们来看看，它的负载均衡到底是如何实现的，实际上之前演示的负载均衡是依靠LoadBalancer实现的。</p><p>在2020年前的SpringCloud版本是采用Ribbon作为负载均衡实现，但是2020年的版本之后SpringCloud把Ribbon移除了，进而用自己编写的LoadBalancer替代。</p><p>那么，负载均衡是如何进行的呢？</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>实际上，在添加<code>@LoadBalanced</code>注解之后，会启用拦截器对我们发起的服务调用请求进行拦截（注意这里是针对我们发起的请求进行拦截），叫做<code>LoadBalancerInterceptor</code>，它实现<code>ClientHttpRequestInterceptor</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClientHttpRequestInterceptor</span> &#123;<br>    ClientHttpResponse <span class="hljs-title function_">intercept</span><span class="hljs-params">(HttpRequest request, <span class="hljs-type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是对<code>intercept</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title function_">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] body, <span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">URI</span> <span class="hljs-variable">originalUri</span> <span class="hljs-operator">=</span> request.getURI();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> originalUri.getHost();<br>    Assert.state(serviceName != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Request URI does not contain a valid hostname: &quot;</span> + originalUri);<br>    <span class="hljs-keyword">return</span> (ClientHttpResponse)<span class="hljs-built_in">this</span>.loadBalancer.execute(serviceName, <span class="hljs-built_in">this</span>.requestFactory.createRequest(request, body, execution));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以打个断点看看实际是怎么在执行的，可以看到：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0k61wb6pxj222y0cm77n.jpg" alt="image-20220323220519463"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0k62dm3knj21yi0fgwiz.jpg" alt="image-20220323220548051"></p><p>服务端会在发起请求时执行这些拦截器。</p><p>那么这个拦截器做了什么事情呢，首先我们要明确，我们给过来的请求地址，并不是一个有效的主机名称，而是服务名称，那么怎么才能得到真正需要访问的主机名称呢，肯定是得找Eureka获取的。</p><p>我们来看看<code>loadBalancer.execute()</code>做了什么，它的具体实现为<code>BlockingLoadBalancerClient</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从上面给进来了服务的名称和具体的请求实体</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">hint</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getHint(serviceId);<br>    LoadBalancerRequestAdapter&lt;T, DefaultRequestContext&gt; lbRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBalancerRequestAdapter</span>(request, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRequestContext</span>(request, hint));<br>    Set&lt;LoadBalancerLifecycle&gt; supportedLifecycleProcessors = <span class="hljs-built_in">this</span>.getSupportedLifecycleProcessors(serviceId);<br>    supportedLifecycleProcessors.forEach((lifecycle) -&gt; &#123;<br>        lifecycle.onStart(lbRequest);<br>    &#125;);<br>  <span class="hljs-comment">//可以看到在这里会调用choose方法自动获取对应的服务实例信息</span><br>    <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.choose(serviceId, lbRequest);<br>    <span class="hljs-keyword">if</span> (serviceInstance == <span class="hljs-literal">null</span>) &#123;<br>        supportedLifecycleProcessors.forEach((lifecycle) -&gt; &#123;<br>            lifecycle.onComplete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionContext</span>(Status.DISCARD, lbRequest, <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyResponse</span>()));<br>        &#125;);<br>      <span class="hljs-comment">//没有发现任何此服务的实例就抛异常（之前的测试中可能已经遇到了）</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No instances available for &quot;</span> + serviceId);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//成功获取到对应服务的实例，这时就可以发起HTTP请求获取信息了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.execute(serviceId, serviceInstance, lbRequest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，实际上在进行负载均衡的时候，会向Eureka发起请求，选择一个可用的对应服务，然后会返回此服务的主机地址等信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0kuedkhinj221e0jin2y.jpg" alt="image-20220324120741736"></p><h3 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h3><p>LoadBalancer默认提供了两种负载均衡策略：</p><ul><li>RandomLoadBalancer  -  随机分配策略</li><li><strong>(默认)</strong> RoundRobinLoadBalancer  -  轮询分配策略</li></ul><p>现在我们希望修改默认的负载均衡策略，可以进行指定，比如我们现在希望用户服务采用随机分配策略，我们需要先创建随机分配策略的配置类（不用加<code>@Configuration</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadBalancerConfig</span> &#123;<br>  <span class="hljs-comment">//将官方提供的 RandomLoadBalancer 注册为Bean</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="hljs-title function_">randomLoadBalancer</span><span class="hljs-params">(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要为对应的服务指定负载均衡策略，直接使用注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@LoadBalancerClient(value = &quot;userservice&quot;,      //指定为 userservice 服务，只要是调用此服务都会使用我们指定的策略</span><br><span class="hljs-meta">                    configuration = LoadBalancerConfig.class)</span>   <span class="hljs-comment">//指定我们刚刚定义好的配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    RestTemplate <span class="hljs-title function_">template</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在<code>BlockingLoadBalancerClient</code>中添加断点，观察是否采用我们指定的策略进行请求：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0lc17or9aj221y07swhq.jpg" alt="image-20220324221750289"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0lc0mbsmqj21ye07yjuh.jpg" alt="image-20220324221713964"></p><p>发现访问userservice服务的策略已经更改为我们指定的策略了。</p><h3 id="OpenFeign实现负载均衡"><a href="#OpenFeign实现负载均衡" class="headerlink" title="OpenFeign实现负载均衡"></a>OpenFeign实现负载均衡</h3><p>官方文档：<a href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/</a></p><p>Feign和RestTemplate一样，也是HTTP客户端请求工具，但是它的使用方式更加便捷。首先是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着在启动类添加<code>@EnableFeignClients</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(BorrowApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在我们需要调用其他微服务提供的接口，该怎么做呢？我们直接创建一个对应服务的接口类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span>   <span class="hljs-comment">//声明为userservice服务的HTTP请求客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们直接创建所需类型的方法，比如我们之前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RestTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.getForObject(<span class="hljs-string">&quot;http://userservice/user/&quot;</span>+uid, User.class);<br></code></pre></td></tr></table></figure><p>现在可以直接写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br><br>  <span class="hljs-comment">//路径保证和其他微服务提供的一致即可</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;  <span class="hljs-comment">//参数和返回值也保持一致</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们直接注入使用（有Mybatis那味了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>UserClient userClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>    List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>    <span class="hljs-comment">//这里不用再写IP，直接写服务名称bookservice</span><br>    List&lt;Book&gt; bookList = borrow<br>            .stream()<br>            .map(b -&gt; template.getForObject(<span class="hljs-string">&quot;http://bookservice/book/&quot;</span>+b.getBid(), Book.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>&#125;<br></code></pre></td></tr></table></figure><p>访问，可以看到结果依然是正确的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l51tto72j229e080dhe.jpg" alt="image-20220324181614387"></p><p>并且我们可以观察一下两个用户微服务的调用情况，也是以负载均衡的形式进行的。</p><p>按照同样的方法，我们接着将图书管理服务的调用也改成接口形式：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l53boxmlj21j60bgq51.jpg" alt="image-20220324181740566"></p><p>最后我们的Service代码就变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; bookClient.getBookById(b.getBid()))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续访问进行测试：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l54vuecvj226206igmz.jpg" alt="image-20220324181910173"></p><p>OK，正常。</p><p>当然，Feign也有很多的其他配置选项，这里就不多做介绍了，详细请查阅官方文档。</p><hr><h2 id="Hystrix-服务熔断"><a href="#Hystrix-服务熔断" class="headerlink" title="Hystrix 服务熔断"></a>Hystrix 服务熔断</h2><p>官方文档：<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.5.RELEASE/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients">https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.5.RELEASE/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients</a></p><p>我们知道，微服务之间是可以进行相互调用的，那么如果出现了下面的情况会导致什么问题？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ky07zn6tj219g07adgz.jpg" alt="image-20220324141230070"></p><p>由于位于最底端的服务提供者E发生故障，那么此时会直接导致服务ABCD全线崩溃，就像雪崩了一样。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ky50sw4jj219s07yabg.jpg" alt="image-20220324141706946"></p><p>这种问题实际上是不可避免的，由于多种因素，比如网络卡顿、系统故障、硬件问题等，都存在一定可能，会导致这种极端的情况发生。因此，我们需要寻找一个应对这种极端情况的解决方案。</p><p>为了解决分布式系统的雪崩问题，SpringCloud提供了Hystrix熔断器组件，他就像我们家中的保险丝一样，当电流过载就会直接熔断，防止危险进一步发生，从而保证家庭用电安全。可以想象一下，如果整条链路上的服务已经全线崩溃，这时还在不断地有大量的请求到达，需要各个服务进行处理，肯定是会使得情况越来越糟糕的。</p><p>我们来详细看看它的工作机制。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>首先我们来看看服务降级，注意一定要区分开服务降级和服务熔断的区别，服务降级并不会直接返回错误，而是可以提供一个补救措施，正常响应给请求者。这样相当于服务依然可用，但是服务能力肯定是下降了的。</p><p>我们就基于借阅管理服务来进行讲解，我们不开启用户服务和图书服务，表示用户服务和图书服务已经挂掉了。</p><p>这里我们导入Hystrix的依赖（此项目已经停止维护，SpringCloud依赖中已经不自带了，所以说需要自己单独导入）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们需要在启动类添加注解开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableHystrix</span>   <span class="hljs-comment">//启用Hystrix</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(BorrowApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在，由于用户服务和图书服务不可用，所以查询借阅信息的请求肯定是没办法正常响应的，这时我们可以提供一个备选方案，也就是说当服务出现异常时，返回我们的备选方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;onError&quot;)</span>    <span class="hljs-comment">//使用@HystrixCommand来指定备选方案</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br><br>  <span class="hljs-comment">//备选方案，这里直接返回空列表了</span><br>  <span class="hljs-comment">//注意参数和返回值要和上面的一致</span><br>    UserBorrowDetail <span class="hljs-title function_">onError</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(<span class="hljs-literal">null</span>, Collections.emptyList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，虽然我们的服务无法正常运行了，但是依然可以给浏览器正常返回响应数据：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0kzgnuv0ej21x406ujvb.jpg" alt="image-20220324150253610"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0kzgygdd3j218s06qjru.jpg" alt="image-20220324150310955"></p><p>服务降级是一种比较温柔的解决方案，虽然服务本身的不可用，但是能够保证正常响应数据。</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>熔断机制是应对雪崩效应的一种微服务链路保护机制，当检测出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务响应正常后恢复调用链路。</p><p>实际上，熔断就是在降级的基础上进一步升级形成的，也就是说，在一段时间内多次调用失败，那么就直接升级为熔断。</p><p>我们可以添加两条输出语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;onError&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始向其他服务获取信息&quot;</span>);<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br><br>    UserBorrowDetail <span class="hljs-title function_">onError</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务错误，进入备选方法！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(<span class="hljs-literal">null</span>, Collections.emptyList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们在浏览器中疯狂点击刷新按钮，对此服务疯狂发起请求，可以看到后台：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0kzz87azgj21960hwwhz.jpg" alt="image-20220324152044551"></p><p>一开始的时候，会正常地去调用Controller对应的方法<code>findUserBorrows</code>，发现失败然后进入备选方法，但是我们发现在持续请求一段时间之后，没有再调用这个方法，而是直接调用备选方案，这便是升级到了熔断状态。</p><p>我们可以继续不断点击，继续不断地发起请求：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l06mgm5yj21uy0b0gns.jpg" alt="image-20220324152750797"></p><p>可以看到，过了一段时间之后，会尝试正常执行一次<code>findUserBorrows</code>，但是依然是失败状态，所以继续保持熔断状态。</p><p>所以得到结论，它能够对一段时间内出现的错误进行侦测，当侦测到出错次数过多时，熔断器会打开，所有的请求会直接响应失败，一段时间后，只执行一定数量的请求，如果还是出现错误，那么则继续保持打开状态，否则说明服务恢复正常运行，关闭熔断器。</p><p>我们可以测试一下，开启另外两个服务之后，继续点击：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l09mmg95j21ue0eatb5.jpg" alt="image-20220324153044583"></p><p>可以看到，当另外两个服务正常运行之后，当再次尝试调用<code>findUserBorrows</code>之后会成功，于是熔断机制就关闭了，服务恢复运行。</p><p>总结一下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l0iulmatj21rc0ba0vj.jpg" alt="image-20220324153935858"></p><h3 id="OpenFeign实现降级"><a href="#OpenFeign实现降级" class="headerlink" title="OpenFeign实现降级"></a>OpenFeign实现降级</h3><p>Hystrix也可以配合Feign进行降级，我们可以对应接口中定义的远程调用单独进行降级操作。</p><p>比如我们还是以用户服务挂掉为例，那么这个时候肯定是会远程调用失败的，也就是说我们的Controller中的方法在执行过程中会直接抛出异常，进而被Hystrix监控到并进行服务降级。</p><p>而实际上导致方法执行异常的根源就是远程调用失败，所以我们换个思路，既然用户服务调用失败，那么我就给这个远程调用添加一个替代方案，如果此远程调用失败，那么就直接上替代方案。那么怎么实现替代方案呢？我们知道Feign都是以接口的形式来声明远程调用，那么既然远程调用已经失效，我们就自行对其进行实现，创建一个实现类，对原有的接口方法进行替代方案实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>   <span class="hljs-comment">//注意，需要将其注册为Bean，Feign才能自动注入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFallbackClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserClient</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;   <span class="hljs-comment">//这里我们自行对其进行实现，并返回我们的替代方案</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;我是替代方案&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现完成后，我们只需要在原有的接口中指定失败替代实现即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//fallback参数指定为我们刚刚编写的实现类</span><br><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, fallback = UserFallbackClient.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在去掉<code>BorrowController</code>的<code>@HystrixCommand</code>注解和备选方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们在配置文件中开启熔断支持：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">circuitbreaker:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>启动服务，调用接口试试看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m0k7jve9j21zq03kdi6.jpg" alt="image-20220325122629016"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m0gmj8ayj229c07q75v.jpg" alt="image-20220325122301779"></p><p>可以看到，现在已经采用我们的替代方案作为结果。</p><h3 id="监控页面部署"><a href="#监控页面部署" class="headerlink" title="监控页面部署"></a>监控页面部署</h3><p>除了对服务的降级和熔断处理，我们也可以对其进行实时监控，只需要安装监控页面即可，这里我们创建一个新的项目，导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着添加配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8900</span><br><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">dashboard:</span><br>    <span class="hljs-comment"># 将localhost添加到白名单，默认是不允许的</span><br>    <span class="hljs-attr">proxy-stream-allow-list:</span> <span class="hljs-string">&quot;localhost&quot;</span><br></code></pre></td></tr></table></figure><p>接着创建主类，注意需要添加<code>@EnableHystrixDashboard</code>注解开启管理页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableHystrixDashboard</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HystrixDashBoardApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(HystrixDashBoardApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动Hystrix管理页面服务，然后我们需要在要进行监控的服务中添加Actuator依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>Actuator是SpringBoot程序的监控系统，可以实现健康检查，记录信息等。在使用之前需要引入spring-boot-starter-actuator，并做简单的配置即可。</p></blockquote><p>添加此依赖后，我们可以在IDEA中查看运行情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ld5ia0z8j21uw0e6god.jpg" alt="image-20220324225633805"></p><p>然后在配置文件中配置Actuator添加暴露：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure><p>接着我们打开刚刚启动的管理页面，地址为：<a href="http://localhost:8900/hystrix/">http://localhost:8900/hystrix/</a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ld6jtiijj22ij0u042v.jpg" alt="image-20220324225733550"></p><p>在中间填写要监控的服务：比如借阅服务：<a href="http://localhost:8301/actuator/hystrix.stream%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%90%8E%E9%9D%A2%E8%A6%81%E6%B7%BB%E5%8A%A0%60/actuator/hystrix.stream%60%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BBMonitor">http://localhost:8301/actuator/hystrix.stream，注意后面要添加`/actuator/hystrix.stream`，然后点击Monitor</a> Stream即可进入监控页面：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ldejq3n0j22ly0puwhu.jpg" alt="image-20220324230515009"></p><p>可以看到现在都是Loading状态，这是因为还没有开始统计，我们现在尝试调用几次我们的服务：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ldfbaoi5j22660bqgnc.jpg" alt="image-20220324230559068"></p><p>可以看到，在调用之后，监控页面出现了信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ldgfihczj21wq0ksn03.jpg" alt="image-20220324230703600"></p><p>可以看到5次访问都是正常的，所以显示为绿色，接着我们来尝试将图书服务关闭，这样就会导致服务降级甚至熔断，然后再多次访问此服务看看监控会如何变化：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ldiuq9naj222a0l2whx.jpg" alt="image-20220324230923472"></p><p>可以看到，错误率直接飙升到100%，并且一段时间内持续出现错误，中心的圆圈也变成了红色，我们继续进行访问：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ldjvo0ppj21j20iy0v3.jpg" alt="image-20220324231022133"></p><p>在出现大量错误的情况下保持持续访问，可以看到此时已经将服务熔断，<code>Circuit</code>更改为Open状态，并且图中的圆圈也变得更大，表示压力在持续上升。</p><hr><h2 id="Gateway-路由网关"><a href="#Gateway-路由网关" class="headerlink" title="Gateway 路由网关"></a>Gateway 路由网关</h2><p>官网地址：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a></p><p>说到路由，想必各位一定最先想到的就是家里的路由器了，那么我们家里的路由器充当的是一个什么角色呢？</p><p>我们知道，如果我们需要连接互联网，那么就需要将手机或是电脑连接到家里的路由器才可以，而路由器则连接光猫，光猫再通过光纤连接到互联网，也就是说，互联网方向发送过来的数据，需要经过路由器才能到达我们的设备。而路由器充当的就是数据包中转站，所有的局域网设备都无法直接与互联网连接，而是需要经过路由器进行中转，我们一般说路由器下的网络是内网，而互联网那一端是外网。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l2ejn70ej21di0b4wfr.jpg" alt="image-20220324164439809"></p><p>我们的局域网设备，无法被互联网上的其他设备直接访问，肯定是能够保证到安全性的。并互联网发送过来的数据，需要经过路由器进行解析，识别到底是哪一个设备的数据包，然后再发送给对应的设备。</p><p>而我们的微服务也是这样，一般情况下，可能并不是所有的微服务都需要直接暴露给外部调用，这时我们就可以使用路由机制，添加一层防护，让所有的请求全部通过路由来转发到各个微服务，并且转发给多个相同微服务实例也可以实现负载均衡。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m1kz3kycj21iq0huwhb.jpg" alt="image-20220325130147758"></p><p>在之前，路由的实现一般使用Zuul，但是已经停更，而现在新出现了由SpringCloud官方开发的Gateway路由，它相比Zuul不仅性能上得到了一定的提升，并且是官方推出，契合性也会更好，所以我们这里就主要讲解Gateway。</p><h3 id="部署网关"><a href="#部署网关" class="headerlink" title="部署网关"></a>部署网关</h3><p>现在我们来创建一个新的项目，作为我们的网关，这里需要添加两个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一个依赖就是网关的依赖，而第二个则跟其他微服务一样，需要注册到Eureka才能生效，注意别添加Web依赖，使用的是WebFlux框架。</p><p>然后我们来完善一下配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8801/eureka,</span> <span class="hljs-string">http://localhost:8802/eureka</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br></code></pre></td></tr></table></figure><p>现在就可以启动了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l34rlri8j22dw0b80ve.jpg" alt="image-20220324170951878"></p><p>但是现在还没有配置任何的路由功能，我们接着将路由功能进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>    <span class="hljs-comment"># 配置路由，注意这里是个列表，每一项都包含了很多信息</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">borrow-service</span>   <span class="hljs-comment"># 路由名称</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://borrowservice</span>  <span class="hljs-comment"># 路由的地址，lb表示使用负载均衡到微服务，也可以使用http正常转发</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由规则，断言什么请求会被路由</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/borrow/**</span>  <span class="hljs-comment"># 只要是访问的这个路径，一律都被路由到上面指定的服务</span><br></code></pre></td></tr></table></figure><p>路由规则的详细列表（断言工厂列表）在这里：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E6%AE%B5%E3%80%81Cookie%E6%90%BA%E5%B8%A6%E6%83%85%E5%86%B5%E3%80%81Header%E6%90%BA%E5%B8%A6%E6%83%85%E5%86%B5%E3%80%81%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9F%9F%E5%90%8D%E5%9C%B0%E5%9D%80%E3%80%81%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E8%B7%AF%E5%BE%84%E3%80%81%E5%8F%82%E6%95%B0%E3%80%81%E8%AE%BF%E9%97%AE%E8%80%85IP%E7%AD%89%E3%80%82%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%98%E6%98%AF%E6%8E%A8%E8%8D%90%E7%9B%B4%E6%8E%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E7%9C%81%E4%BA%8B%E3%80%82">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories，可以指定多种类型，包括指定时间段、Cookie携带情况、Header携带情况、访问的域名地址、访问的方法、路径、参数、访问者IP等。也可以使用配置类进行配置，但是还是推荐直接配置文件，省事。</a></p><p>接着启动网关，搭载Arm架构芯片的Mac电脑可能会遇到这个问题：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m59qpakvj21og074q5a.jpg" alt="image-20220325150924472"></p><p>这是因为没有找到适用于此架构的动态链接库，不影响使用，无视即可，希望以后的版本能修复吧。</p><p>可以看到，我们现在可以直接通过路由来访问我们的服务了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l3cme88qj226g0a6abq.jpg" alt="image-20220324171724493"></p><p>注意此时依然可以通过原有的服务地址进行访问：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0l3efx1npj225c070400.jpg" alt="image-20220324171909828"></p><p>这样我们就可以将不需要外网直接访问的微服务全部放到内网环境下，而只依靠网关来对外进行交涉。</p><h3 id="路由过滤器"><a href="#路由过滤器" class="headerlink" title="路由过滤器"></a>路由过滤器</h3><p>路由过滤器支持以某种方式修改传入的 HTTP 请求或传出的 HTTP 响应，路由过滤器的范围是某一个路由，跟之前的断言一样，Spring Cloud Gateway 也包含许多内置的路由过滤器工厂，详细列表：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p><p>比如我们现在希望在请求到达时，在请求头中添加一些信息再转发给我们的服务，那么这个时候就可以使用路由过滤器来完成，我们只需要对配置文件进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">borrow-service</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://borrowservice</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/borrow/**</span><br>      <span class="hljs-comment"># 继续添加新的路由配置，这里就以书籍管理服务为例</span><br>      <span class="hljs-comment"># 注意-要对齐routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">book-service</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://bookservice</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/book/**</span><br>        <span class="hljs-attr">filters:</span>   <span class="hljs-comment"># 添加过滤器</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Test,</span> <span class="hljs-string">HelloWorld!</span><br>        <span class="hljs-comment"># AddRequestHeader 就是添加请求头信息，其他工厂请查阅官网</span><br></code></pre></td></tr></table></figure><p>接着我们在BookController中获取并输出一下，看看是不是成功添加了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">findBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid,</span><br><span class="hljs-params">                      HttpServletRequest request)</span>&#123;<br>        System.out.println(request.getHeader(<span class="hljs-string">&quot;Test&quot;</span>));<br>        <span class="hljs-keyword">return</span> service.getBookById(bid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们通过Gateway访问我们的图书管理服务：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m57rm7t4j21bq07kt9c.jpg" alt="image-20220325150730814"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m5cstkq3j21v403q0ud.jpg" alt="image-20220325151220776"></p><p>可以看到这里成功获取到由网关添加的请求头信息了。</p><p>除了针对于某一个路由配置过滤器之外，我们也可以自定义全局过滤器，它能够作用于全局。但是我们需要通过代码的方式进行编写，比如我们要实现拦截没有携带指定请求参数的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>   <span class="hljs-comment">//需要注册为Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;   <span class="hljs-comment">//只需要实现此方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们编写判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>    <span class="hljs-comment">//先获取ServerHttpRequest对象，注意不是HttpServletRequest</span><br>    <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>    <span class="hljs-comment">//打印一下所有的请求参数</span><br>    System.out.println(request.getQueryParams());<br>    <span class="hljs-comment">//判断是否包含test参数，且参数值为1</span><br>    List&lt;String&gt; value = request.getQueryParams().get(<span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span> &amp;&amp; value.contains(<span class="hljs-string">&quot;1&quot;</span>)) &#123;<br>        <span class="hljs-comment">//将ServerWebExchange向过滤链的下一级传递（跟JavaWeb中介绍的过滤器其实是差不多的）</span><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//直接在这里不再向下传递，然后返回响应</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到结果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m6ahb0zvj21ak07qaah.jpg" alt="image-20220325154443063"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m6axjl3oj21ai072t9h.jpg" alt="image-20220325154508853"></p><p>成功实现规则判断和拦截操作。</p><p>当然，过滤器肯定是可以存在很多个的，所以我们可以手动指定过滤器之间的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;   <span class="hljs-comment">//实现Ordered接口</span><br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>注意Order的值越小优先级越高，并且无论是在配置文件中编写的单个路由过滤器还是全局路由过滤器，都会受到Order值影响（单个路由的过滤器Order值按从上往下的顺序从1开始递增），最终是按照Order值决定哪个过滤器优先执行，当Order值一样时 全局路由过滤器执行 <code>优于</code> 单独的路由过滤器执行。</p><hr><h2 id="Config-配置中心"><a href="#Config-配置中心" class="headerlink" title="Config 配置中心"></a>Config 配置中心</h2><p><strong>官方文档：</strong><a href="https://docs.spring.io/spring-cloud-config/docs/current/reference/html/">https://docs.spring.io/spring-cloud-config/docs/current/reference/html/</a></p><p>经过前面的学习，我们对于一个分布式应用的技术选型和搭建已经了解得比较多了，但是各位有没有发现一个问题，如果我们的微服务项目需要部署很多个实例，那么配置文件我们岂不是得一个一个去改，可能十几个实例还好，要是有几十个上百个呢？那我们一个一个去配置，岂不直接猝死在工位上。</p><p>所以，我们需要一种更加高级的集中化地配置文件管理工具，集中地对配置文件进行配置。</p><blockquote><p>Spring Cloud Config 为分布式系统中的外部配置提供服务器端和客户端支持。使用 Config Server，您可以集中管理所有环境中应用程序的外部配置。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m8zggbzyj21ha0csjt5.jpg" alt="image-20220325171754862"></p><p>实际上Spring Cloud Config就是一个配置中心，所有的服务都可以从配置中心取出配置，而配置中心又可以从GitHub远程仓库中获取云端的配置文件，这样我们只需要修改GitHub中的配置即可对所有的服务进行配置管理了。</p><h3 id="部署配置中心"><a href="#部署配置中心" class="headerlink" title="部署配置中心"></a>部署配置中心</h3><p>这里我们接着创建一个新的项目，并导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>老规矩，启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ConfigApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就是配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8700</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">configserver</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8801/eureka,</span> <span class="hljs-string">http://localhost:8802/eureka</span><br></code></pre></td></tr></table></figure><p>先启动一次看看，能不能成功：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0m9lyfoz2j226409uabs.jpg" alt="image-20220325173932623"></p><p>这里我们以本地仓库为例（就不用GitHub了，卡到怀疑人生了），首先在项目目录下创建一个本地Git仓库，打开终端，在桌面上创建一个新的本地仓库：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0mhe24rhjj211q05cabb.jpg" alt="image-20220325220843990"></p><p>然后我们在文件夹中随便创建一些配置文件，注意名称最好是{服务名称}-{环境}.yml：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0mhjqi2o6j216205gaan.jpg" alt="image-20220325221411834"></p><p>然后我们在配置文件中，添加本地仓库的一些信息（远程仓库同理），详细使用教程：<a href="https://docs.spring.io/spring-cloud-config/docs/current/reference/html/#_git_backend">https://docs.spring.io/spring-cloud-config/docs/current/reference/html/#_git_backend</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">server:</span><br>        <span class="hljs-attr">git:</span><br>        <span class="hljs-comment"># 这里填写的是本地仓库地址，远程仓库直接填写远程仓库地址 http://git...</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">file://$&#123;user.home&#125;/Desktop/config-repo</span><br>          <span class="hljs-comment"># 默认分支设定为你自己本地或是远程分支的名称</span><br>          <span class="hljs-attr">default-label:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>然后启动我们的配置服务器，通过以下格式进行访问：</p><ul><li><a href="http://localhost:8700/%7B%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%A7%B0%7D/%7B%E7%8E%AF%E5%A2%83%7D/%7BGit%E5%88%86%E6%94%AF%7D">http://localhost:8700/{服务名称}/{环境}/{Git分支}</a></li><li><a href="http://localhost:8700/%7BGit%E5%88%86%E6%94%AF%7D/%7B%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%A7%B0%7D-%7B%E7%8E%AF%E5%A2%83%7D.yml">http://localhost:8700/{Git分支}/{服务名称}-{环境}.yml</a></li></ul><p>比如我们要访问图书服务的生产环境代码，可以使用 <a href="http://localhost:8700/bookservice/prod/main">http://localhost:8700/bookservice/prod/main</a> 链接，它会显示详细信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0mhpjeaiyj22is0cadjs.jpg" alt="image-20220325221946363"></p><p>也可以使用 <a href="http://localhost:8700/main/bookservice-prod.yml">http://localhost:8700/main/bookservice-prod.yml</a> 链接，它仅显示配置文件原文：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0mht1siqdj21ro0hu41a.jpg" alt="image-20220325222309095"></p><p>当然，除了使用Git来保存之外，还支持一些其他的方式，详细情况请查阅官网。</p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>服务端配置完成之后，我们接着来配置一下客户端，那么现在我们的服务既然需要从服务器读取配置文件，那么就需要进行一些配置，我们删除原来的<code>application.yml</code>文件（也可以保留，最后无论是远端配置还是本地配置都会被加载），改用<code>bootstrap.yml</code>（在application.yml之前加载，可以实现配置文件远程获取）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>    <span class="hljs-comment"># 名称，其实就是文件名称</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">bookservice</span><br>      <span class="hljs-comment"># 配置服务器的地址</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8700</span><br>      <span class="hljs-comment"># 环境</span><br>      <span class="hljs-attr">profile:</span> <span class="hljs-string">prod</span><br>      <span class="hljs-comment"># 分支</span><br>      <span class="hljs-attr">label:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>配置完成之后，启动图书服务：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0mii0tbegj22l208k43a.jpg" alt="image-20220325224708591"></p><p>可以看到已经从远端获取到了配置，并进行启动。</p><hr><h2 id="微服务CAP原则"><a href="#微服务CAP原则" class="headerlink" title="微服务CAP原则"></a>微服务CAP原则</h2><p>经过前面的学习，我们对SpringCloud Netflix以及SpringCloud官方整个生态下的组件认识也差不多了，入门教学就到此为止，下一章将开启真正精彩的正片部分，本章的最后我们还是来了解一些理论上的知识。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0mj50oc1zj212e0jw756.jpg" alt="image-20220325230915356"></p><blockquote><p>CAP原则又称CAP定理，指的是在一个分布式系统中，存在Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），三者不可同时保证，最多只能保证其中的两者。   </p><p>一致性（C）：在分布式系统中的所有数据备份，在同一时刻都是同样的值（所有的节点无论何时访问都能拿到最新的值）</p><p>可用性（A）：系统中非故障节点收到的每个请求都必须得到响应（比如我们之前使用的服务降级和熔断，其实就是一种维持可用性的措施，虽然服务返回的是没有什么意义的数据，但是不至于用户的请求会被服务器忽略）</p><p>分区容错性（P）：一个分布式系统里面，节点之间组成的网络本来应该是连通的，然而可能因为一些故障（比如网络丢包等，这是很难避免的），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中（这样就可能出现某些被分区节点存放的数据访问失败，我们需要来容忍这些不可靠的情况）</p></blockquote><p>总的来说，数据存放的节点数越多，分区容忍性就越高，但是要复制更新的次数就越多，一致性就越难保证。同时为了保证一致性，更新所有节点数据所需要的时间就越长，那么可用性就会降低。</p><p>所以说，只能存在以下三种方案：</p><h3 id="AC-可用性-一致性"><a href="#AC-可用性-一致性" class="headerlink" title="AC 可用性+一致性"></a>AC 可用性+一致性</h3><p>要同时保证可用性和一致性，代表着某个节点数据更新之后，需要立即将结果通知给其他节点，并且要尽可能的快，这样才能及时响应保证可用性，这就对网络的稳定性要求非常高，但是实际情况下，网络很容易出现丢包等情况，并不是一个可靠的传输，如果需要避免这种问题，就只能将节点全部放在一起，但是这显然违背了分布式系统的概念，所以对于我们的分布式系统来说，很难接受。</p><h3 id="CP-一致性-分区容错性"><a href="#CP-一致性-分区容错性" class="headerlink" title="CP 一致性+分区容错性"></a>CP 一致性+分区容错性</h3><p>为了保证一致性，那么就得将某个节点的最新数据发送给其他节点，并且需要等到所有节点都得到数据才能进行响应，同时有了分区容错性，那么代表我们可以容忍网络的不可靠问题，所以就算网络出现卡顿，那么也必须等待所有节点完成数据同步，才能进行响应，因此就会导致服务在一段时间内完全失效，所以可用性是无法得到保证的。</p><h3 id="AP-可用性-分区容错性"><a href="#AP-可用性-分区容错性" class="headerlink" title="AP 可用性+分区容错性"></a>AP 可用性+分区容错性</h3><p>既然CP可能会导致一段时间内服务得不到任何响应，那么要保证可用性，就只能放弃节点之间数据的高度统一，也就是说可以在数据不统一的情况下，进行响应，因此就无法保证一致性了。虽然这样会导致拿不到最新的数据，但是只要数据同步操作在后台继续运行，一定能够在某一时刻完成所有节点数据的同步，那么就能实现<strong>最终一致性</strong>，所以AP实际上是最能接受的一种方案。</p><p>比如我们实现的Eureka集群，它使用的就是AP方案，Eureka各个节点都是平等的，少数节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka客户端在向某个Eureka服务端注册时如果发现连接失败，则会自动切换至其他节点。只要有一台Eureka服务器正常运行，那么就能保证服务可用<strong>（A）</strong>，只不过查询到的信息可能不是最新的<strong>（C）</strong></p><p>在之后的章节，我们还会继续了解这些理论的其他实际应用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMq</title>
    <link href="/2022/10/02/RabbitMq/"/>
    <url>/2022/10/02/RabbitMq/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ahsb4tmsj21sk09iwfi.jpg" alt="image-20220415163559986"></p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>经过前面的学习，我们已经了解了我们之前的技术在分布式环境下的应用，接着我们来看最后一章的内容。</p><p>那么，什么是消息队列呢？</p><p>我们之前如果需要进行远程调用，那么一般可以通过发送HTTP请求来完成，而现在，我们可以使用第二种方式，就是消息队列，它能够将发送方发送的信息放入队列中，当新的消息入队时，会通知接收方进行处理，一般消息发送方称为生产者，接收方称为消费者。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1aifat4bgj21qy0g6abi.jpg" alt="image-20220415165805716"></p><p>这样我们所有的请求，都可以直接丢到消息队列中，再由消费者取出，不再是直接连接消费者的形式了，而是加了一个中间商，这也是一种很好的解耦方案，并且在高并发的情况下，由于消费者能力有限，消息队列也能起到一个削峰填谷的作用，堆积一部分的请求，再由消费者来慢慢处理，而不会像直接调用那样请求蜂拥而至。</p><p>那么，消息队列具体实现有哪些呢：</p><ul><li>RabbitMQ  -  性能很强，吞吐量很高，支持多种协议，集群化，消息的可靠执行特性等优势，很适合企业的开发。</li><li>Kafka - 提供了超高的吞吐量，ms级别的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。</li><li>RocketMQ  -  阿里巴巴推出的消息队列，经历过双十一的考验，单机吞吐量高，消息的高可靠性，扩展性强，支持事务等，但是功能不够完整，语言支持性较差。</li></ul><p>我们这里，主要讲解的是RabbitMQ消息队列。</p><h2 id="RabbitMQ-消息队列"><a href="#RabbitMQ-消息队列" class="headerlink" title="RabbitMQ 消息队列"></a>RabbitMQ 消息队列</h2><p><strong>官方网站：</strong><a href="https://www.rabbitmq.com/">https://www.rabbitmq.com</a></p><blockquote><p>RabbitMQ拥有数万计的用户，是最受欢迎的开源消息队列之一，从<a href="https://www.youtube.com/watch?v=1qcTu2QUtrU">T-Mobile</a>到<a href="https://medium.com/@runtastic/messagebus-handling-dead-letters-in-rabbitmq-using-a-dead-letter-exchange-f070699b952b">Runtastic</a>，RabbitMQ在全球范围内用于小型初创企业和大型企业。</p><p>RabbitMQ轻量级，易于在本地和云端部署，它支持多种消息协议。RabbitMQ可以部署在分布式和联合配置中，以满足大规模、高可用性要求。</p><p>RabbitMQ在许多操作系统和云环境中运行，并为<a href="https://www.rabbitmq.com/devtools.html">大多数流行语言</a>提供了<a href="https://www.rabbitmq.com/devtools.html">广泛的开发者工具</a>。</p></blockquote><p>我们首先还是来看看如何进行安装。</p><h3 id="安装消息队列"><a href="#安装消息队列" class="headerlink" title="安装消息队列"></a>安装消息队列</h3><p><strong>下载地址：</strong><a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p><p>由于除了消息队列本身之外还需要Erlang环境（RabbitMQ就是这个语言开发的）所以我们就在我们的Ubuntu服务器上进行安装。</p><p>首先是Erlang，比较大，1GB左右：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install erlang<br></code></pre></td></tr></table></figure><p>接着安装RabbitMQ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install rabbitmq-server<br></code></pre></td></tr></table></figure><p>安装完成后，可以输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl status<br></code></pre></td></tr></table></figure><p>来查看当前的RabbitMQ运行状态，包括运行环境、内存占用、日志文件等信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Runtime</span><br><br><span class="hljs-attribute">OS</span> PID: <span class="hljs-number">13718</span><br><span class="hljs-attribute">OS</span>: Linux<br><span class="hljs-attribute">Uptime</span> (seconds): <span class="hljs-number">65</span><br><span class="hljs-attribute">Is</span> under maintenance?: false<br><span class="hljs-attribute">RabbitMQ</span> version: <span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">Node</span> name: rabbit@ubuntu-server-<span class="hljs-number">2</span><br><span class="hljs-attribute">Erlang</span> configuration: Erlang/OTP <span class="hljs-number">23</span><span class="hljs-meta"> [erts-11.1.8] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:64]</span><br><span class="hljs-attribute">Erlang</span> processes: <span class="hljs-number">280</span> used, <span class="hljs-number">1048576</span> limit<br><span class="hljs-attribute">Scheduler</span> run queue: <span class="hljs-number">1</span><br><span class="hljs-attribute">Cluster</span> heartbeat timeout (net_ticktime): <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>这样我们的RabbitMQ服务器就安装完成了，要省事还得是Ubuntu啊。</p><p>可以看到默认有两个端口名被使用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Listeners</span><br><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">25672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">clustering,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">inter-node</span> <span class="hljs-string">and</span> <span class="hljs-string">CLI</span> <span class="hljs-string">tool</span> <span class="hljs-string">communication</span><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">amqp,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">AMQP</span> <span class="hljs-number">0</span><span class="hljs-number">-9</span><span class="hljs-number">-1</span> <span class="hljs-string">and</span> <span class="hljs-string">AMQP</span> <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>我们一会主要使用的就是amqp协议的那个端口<code>5672</code>来进行连接，25672是集群化端口，之后我们也会用到。</p><p>接着我们还可以将RabbitMQ的管理面板开启，这样话就可以在浏览器上进行实时访问和监控了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure><p>再次查看状态，可以看到多了一个管理面板，使用的是HTTP协议：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Listeners</span><br><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">25672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">clustering,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">inter-node</span> <span class="hljs-string">and</span> <span class="hljs-string">CLI</span> <span class="hljs-string">tool</span> <span class="hljs-string">communication</span><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">amqp,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">AMQP</span> <span class="hljs-number">0</span><span class="hljs-number">-9</span><span class="hljs-number">-1</span> <span class="hljs-string">and</span> <span class="hljs-string">AMQP</span> <span class="hljs-number">1.0</span><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">15672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">http,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">HTTP</span> <span class="hljs-string">API</span><br></code></pre></td></tr></table></figure><p>我们打开浏览器直接访问一下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1aooi1nvwj21q20ea75e.jpg" alt="image-20220415203431587"></p><p>可以看到需要我们进行登录才可以进入，我们这里还需要创建一个用户才可以，这里就都用admin：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl add_user 用户名 密码<br></code></pre></td></tr></table></figure><p>将管理员权限给予我们刚刚创建好的用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl set_user_tags admin administrator<br></code></pre></td></tr></table></figure><p>创建完成之后，我们登录一下页面：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1aorkpn72j225s0u0wj3.jpg" alt="image-20220415203728664"></p><p>进入了之后会显示当前的消息队列情况，包括版本号、Erlang版本等，这里需要介绍一下RabbitMQ的设计架构，这样我们就知道各个模块管理的是什么内容了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1bcul1hzzj21r40iogq3.jpg" alt="image-20220416103043845"></p><ul><li><strong>生产者（Publisher）和消费者（Consumer）：</strong>不用多说了吧。</li><li><strong>Channel：</strong>我们的客户端连接都会使用一个Channel，再通过Channel去访问到RabbitMQ服务器，注意通信协议不是http，而是amqp协议。</li><li><strong>Exchange：</strong>类似于交换机一样的存在，会根据我们的请求，转发给相应的消息队列，每个队列都可以绑定到Exchange上，这样Exchange就可以将数据转发给队列了，可以存在很多个，不同的Exchange类型可以用于实现不同消息的模式。</li><li><strong>Queue：</strong>消息队列本体，生产者所有的消息都存放在消息队列中，等待消费者取出。</li><li><strong>Virtual Host：</strong>有点类似于环境隔离，不同环境都可以单独配置一个Virtual Host，每个Virtual Host可以包含很多个Exchange和Queue，每个Virtual Host相互之间不影响。</li></ul><h3 id="使用消息队列"><a href="#使用消息队列" class="headerlink" title="使用消息队列"></a>使用消息队列</h3><p>我们就从最简的的模型开始讲起：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1cin640c8j21fg06ajrh.jpg" alt="image-20220417103647609"></p><p>（一个生产者 -&gt; 消息队列 -&gt; 一个消费者）</p><p>生产者只需要将数据丢进消息队列，而消费者只需要将数据从消息队列中取出，这样就实现了生产者和消费者的消息交互。我们现在来演示一下，首先进入到我们的管理页面，这里我们创建一个新的实验环境，只需要新建一个Virtual Host即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f0mpm7o2j22cw0kaq5s.jpg" alt="image-20220419143014974"></p><p>添加新的虚拟主机之后，我们可以看到，当前admin用户的主机访问权限中新增了我们刚刚添加的环境：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f0nrhztlj22cu0eqjt5.jpg" alt="image-20220419143115507"></p><p>现在我们来看看交换机：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f0q92geqj21x70u0wix.jpg" alt="image-20220419143338487"></p><p>交换机列表中自动为我们新增了刚刚创建好的虚拟主机相关的预设交换机，一共7个，这里我们首先介绍一下前面两个<code>direct</code>类型的交换机，一个是<code>（AMQP default）</code>还有一个是<code>amq.direct</code>，它们都是直连模式的交换机，我们来看看第一个：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f0sx1l24j22cm0j80v9.jpg" alt="image-20220419143612318"></p><p>第一个交换机是所有虚拟主机都会自带的一个默认交换机，并且此交换机不可删除，此交换机默认绑定到所有的消息队列，如果是通过默认交换机发送消息，那么会根据消息的<code>routingKey</code>（之后我们发消息都会指定）决定发送给哪个同名的消息队列，同时也不能显示地将消息队列绑定或解绑到此交换机。</p><p>我们可以看到，详细信息中，当前交换机特性是持久化的，也就是说就算机器重启，那么此交换机也会保留，如果不是持久化，那么一旦重启就会消失。实际上我们在列表中看到<code>D</code>的字样，就表示此交换机是持久化的，包含一会我们要讲解的消息队列列表也是这样，所有自动生成的交换机都是持久化的。</p><p>我们接着来看第二个交换机，这个交换机是一个普通的直连交换机：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f0yya0xgj22810u0412.jpg" alt="image-20220419144200533"></p><p>这个交换机和我们刚刚介绍的默认交换机类型一致，并且也是持久化的，但是我们可以看到它是具有绑定关系的，如果没有指定的消息队列绑定到此交换机上，那么这个交换机无法正常将信息存放到指定的消息队列中，也是根据<code>routingKey</code>寻找消息队列（但是可以自定义）</p><p>我们可以在下面直接操作，让某个队列绑定，这里我们先不进行操作。</p><p>介绍完了两个最基本的交换机之后（其他类型的交换机我们会在后面进行介绍），我们接着来看消息队列：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f127q11qj22em0deta1.jpg" alt="image-20220419144508881"></p><p>可以看到消息队列列表中没有任何的消息队列，我们可以来尝试添加一个新的消息队列：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f12zs6hxj22cg0i60uv.jpg" alt="image-20220419144553817"></p><p>第一行，我们选择我们刚刚创建好的虚拟主机，在这个虚拟主机下创建此消息队列，接着我们将其类型定义为<code>Classic</code>类型，也就是经典类型（其他类型我们会在后面逐步介绍）名称随便起一个，然后持久化我们选择<code>Transient</code>暂时的（当然也可以持久化，看你自己）自动删除我们选择<code>No</code>（需要至少有一个消费者连接到这个队列，之后，一旦所有与这个队列连接的消费者都断开时，就会自动删除此队列）最下面的参数我们暂时不进行任何设置（之后会用到）</p><p>现在，我们就创建好了一个经典的消息队列：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f18gv4xoj22d80dy40j.jpg" alt="image-20220419145109450"></p><p>点击此队列的名称，我们可以查看详细信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1a07outj22cu0o6tc5.jpg" alt="image-20220419145238458"></p><p>详细相信中包括队列的当前负载状态、属性、消息队列占用的内存，消息数量等，一会我们发送消息时可以进一步进行观察。</p><p>现在我们需要将此消息队列绑定到上面的第二个直连交换机，这样我们就可以通过此交换机向此消息队列发送消息了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1ctvnhmj22da0im75w.jpg" alt="image-20220419145520844"></p><p>这里填写之前第二个交换机的名称还有我们自定义的<code>routingKey</code>（最好还是和消息队列名称一致，这里是为了一会演示两个交换机区别用）我们直接点击绑定即可：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1e42r9cj21rg0bumxv.jpg" alt="image-20220419145635179"></p><p>绑定之后我们可以看到当前队列已经绑定对应的交换机了，现在我们可以前往交换机对此消息队列发送一个消息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1ez7m11j22da0os0v4.jpg" alt="image-20220419145725499"></p><p>回到交换机之后，可以卡到这边也是同步了当前的绑定信息，在下方，我们直接向此消息队列发送信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1fq3w0zj22e40l6abl.jpg" alt="image-20220419145808450"></p><p>点击发送之后，我们回到刚刚的交换机详细页面，可以看到已经有一条新的消息在队列中了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1gojajxj22cw0lo0vh.jpg" alt="image-20220419145903723"></p><p>我们可以直接在消息队列这边获取消息队列中的消息，找到下方的Get message选项：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1h8qcnhj21q80ccmy4.jpg" alt="image-20220419145936160"></p><p>可以看到有三个选择，首先第一个Ack Mode，这个是应答模式选择，一共有4个选项：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1im04y6j214g05a3yv.jpg" alt="image-20220419150053926"></p><ul><li>Nack message requeue true：拒绝消息，也就是说不会将消息从消息队列取出，并且重新排队，一次可以拒绝多个消息。</li><li>Ack message requeue false：确认应答，确认后消息会从消息队列中移除，一次可以确认多个消息。</li><li>Reject message requeue true&#x2F;false：也是拒绝此消息，但是可以指定是否重新排队。</li></ul><p>这里我们使用默认的就可以了，这样只会查看消息是啥，但是不会取出，消息依然存在于消息队列中，第二个参数是编码格式，使用默认的就可以了，最后就是要生效的操作数量，选择1就行：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1p61hjcj21l20di758.jpg" alt="image-20220419150712314"></p><p>可以看到我们刚刚的消息已经成功读取到。</p><p>现在我们再去第一个默认交换机中尝试发送消息试试看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1r9rzvbj21ha07m74n.jpg" alt="image-20220419150913859"></p><p>如果我们使用之前自定义的<code>routingKey</code>，会显示没有路由，这是因为默认的交换机只会找对应名称的消息队列，我们现在向<code>yyds</code>发送一下试试看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1sdaa6bj21dk064wek.jpg" alt="image-20220419151016735"></p><p>可以看到消息成功发布了，我们来接收一下看看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1t2qdtmj221c0lymz8.jpg" alt="image-20220419151058659"></p><p>可以看到成功发送到此消息队列中了。</p><p>当然除了在交换机发送消息给消息队列之外，我们也可以直接在消息队列这里发：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1u2nhz7j21xc0lwq4g.jpg" alt="image-20220419151155264"></p><p>效果是一样的，注意这里我们可以选择是否将消息持久化，如果是持久化消息，那么就算服务器重启，此消息也会保存在消息队列中。</p><p>最后如果我们不需要再使用此消息队列了，我们可以手动对其进行删除或是清空：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f1y44f9dj21lu096t90.jpg" alt="image-20220419151548923"></p><p>点击Delete Queue删除我们刚刚创建好的<code>yyds</code>队列，到这里，我们对应消息队列的一些简单使用，就讲解完毕了。</p><h3 id="使用Java操作消息队列"><a href="#使用Java操作消息队列" class="headerlink" title="使用Java操作消息队列"></a>使用Java操作消息队列</h3><p>现在我们来看看如何通过Java连接到RabbitMQ服务器并使用消息队列进行消息发送（这里一起讲解，包括Java基础版本和SpringBoot版本），首先我们使用最基本的Java客户端连接方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.14.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>依赖导入之后，我们来实现一下生产者和消费者，首先是生产者，生产者负责将信息发送到消息队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//使用ConnectionFactory来创建连接</span><br>    <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br><br>    <span class="hljs-comment">//设定连接信息，基操</span><br>    factory.setHost(<span class="hljs-string">&quot;192.168.0.12&quot;</span>);<br>    factory.setPort(<span class="hljs-number">5672</span>);  <span class="hljs-comment">//注意这里写5672，是amqp协议端口</span><br>    factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>    factory.setPassword(<span class="hljs-string">&quot;admin&quot;</span>);<br>    factory.setVirtualHost(<span class="hljs-string">&quot;/test&quot;</span>);<br>  <br> <span class="hljs-comment">//创建连接</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection())&#123;<br>        <br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以直接在程序中定义并创建消息队列（实际上是和我们在管理页面创建一样的效果）客户端需要通过连接创建一个新的通道（Channel），同一个连接下可以有很多个通道，这样就不用创建很多个连接也能支持分开发送了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel())&#123;   <span class="hljs-comment">//通过Connection创建新的Channel</span><br>  <span class="hljs-comment">//声明队列，如果此队列不存在，会自动创建</span><br>    channel.queueDeclare(<span class="hljs-string">&quot;yyds&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>  <span class="hljs-comment">//将队列绑定到交换机</span><br>    channel.queueBind(<span class="hljs-string">&quot;yyds&quot;</span>, <span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>);<br>  <span class="hljs-comment">//发布新的消息，注意消息需要转换为byte[]</span><br>    channel.basicPublish(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>.getBytes());<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>queueDeclare</code>方法的参数如下：</p><ul><li>queue：队列的名称（默认创建后routingKey和队列名称一致）</li><li>durable：是否持久化。</li><li>exclusive：是否排他，如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。排他队列是基于Connection可见，同一个Connection的不同Channel是可以同时访问同一个连接创建的排他队列，并且，如果一个Connection已经声明了一个排他队列，其他的Connection是不允许建立同名的排他队列的，即使该队列是持久化的，一旦Connection关闭或者客户端退出，该排他队列都会自动被删除。</li><li>autoDelete：是否自动删除。</li><li>arguments：设置队列的其他一些参数，这里我们暂时不需要什么其他参数。</li></ul><p>其中<code>queueBind</code>方法参数如下：</p><ul><li>queue：需要绑定的队列名称。</li><li>exchange：需要绑定的交换机名称。</li><li>routingKey：不用多说了吧。</li></ul><p>其中<code>basicPublish</code>方法的参数如下：</p><ul><li>exchange: 对应的Exchange名称，我们这里就使用第二个直连交换机。</li><li>routingKey：这里我们填写绑定时指定的routingKey，其实和之前在管理页面操作一样。</li><li>props：其他的配置。</li><li>body：消息本体。</li></ul><p>执行完成后，可以在管理页面中看到我们刚刚创建好的消息队列了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f2jnj0jzj22dc0de0ui.jpg" alt="image-20220419153630431"></p><p>并且此消息队列已经成功与<code>amq.direct</code>交换机进行绑定：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f2tup1pmj21pa0bowf9.jpg" alt="image-20220419154618613"></p><p>那么现在我们的消息队列中已经存在数据了，怎么将其读取出来呢？我们来看看如何创建一个消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>    <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>    factory.setHost(<span class="hljs-string">&quot;10.37.129.4&quot;</span>);<br>    factory.setPort(<span class="hljs-number">5672</span>);<br>    factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>    factory.setPassword(<span class="hljs-string">&quot;admin&quot;</span>);<br>    factory.setVirtualHost(<span class="hljs-string">&quot;/test&quot;</span>);<br><br>    <span class="hljs-comment">//这里不使用try-with-resource，因为消费者是一直等待新的消息到来，然后按照</span><br>    <span class="hljs-comment">//我们设定的逻辑进行处理，所以这里不能在定义完成之后就关闭连接</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>    <span class="hljs-comment">//创建一个基本的消费者</span><br>    channel.basicConsume(<span class="hljs-string">&quot;yyds&quot;</span>, <span class="hljs-literal">false</span>, (s, delivery) -&gt; &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody()));<br>        <span class="hljs-comment">//basicAck是确认应答，第一个参数是当前的消息标签，后面的参数是</span><br>        <span class="hljs-comment">//是否批量处理消息队列中所有的消息，如果为false表示只处理当前消息</span><br>        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//basicNack是拒绝应答，最后一个参数表示是否将当前消息放回队列，如果</span><br>        <span class="hljs-comment">//为false，那么消息就会被丢弃</span><br>        <span class="hljs-comment">//channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);</span><br>        <span class="hljs-comment">//跟上面一样，最后一个参数为false，只不过这里省了</span><br>        <span class="hljs-comment">//channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);</span><br>    &#125;, s -&gt; &#123;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>basicConsume</code>方法参数如下：</p><ul><li>queue  -  消息队列名称，直接指定。</li><li>autoAck - 自动应答，消费者从消息队列取出数据后，需要跟服务器进行确认应答，当服务器收到确认后，会自动将消息删除，如果开启自动应答，那么消息发出后会直接删除。</li><li>deliver  -  消息接收后的函数回调，我们可以在回调中对消息进行处理，处理完成后，需要给服务器确认应答。</li><li>cancel  -  当消费者取消订阅时进行的函数回调，这里暂时用不到。</li></ul><p>现在我们启动一下消费者，可以看到立即读取到我们刚刚插入到队列中的数据：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1f37pxs0pj21h207q40k.jpg" alt="image-20220419155938158"></p><p>我们现在继续在消息队列中插入新的数据，这里直接在网页上进行操作就行了，同样的我们也可以在消费者端接受并进行处理。</p><p>现在我们把刚刚创建好的消息队列删除。</p><p>官方文档：<a href="https://docs.spring.io/spring-amqp/docs/current/reference/html/">https://docs.spring.io/spring-amqp/docs/current/reference/html/</a></p><p>前面我们已经完成了RabbitMQ的安装和简单使用，并且通过Java连接到服务器。现在我们来尝试在SpringBoot中整合消息队列客户端，首先是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们需要配置RabbitMQ的地址等信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">addresses:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.4</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/test</span><br></code></pre></td></tr></table></figure><p>这样我们就完成了最基本信息配置，现在我们来看一下，如何像之前一样去声明一个消息队列，我们只需要一个配置类就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;directExchange&quot;)</span>  <span class="hljs-comment">//定义交换机Bean，可以很多个</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(<span class="hljs-string">&quot;amq.direct&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span>     <span class="hljs-comment">//定义消息队列</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>          .nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>)   <span class="hljs-comment">//非持久化类型</span><br>          .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;directExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>      <span class="hljs-comment">//将我们刚刚定义的交换机和队列进行绑定</span><br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)   <span class="hljs-comment">//绑定队列</span><br>                .to(exchange)  <span class="hljs-comment">//到交换机</span><br>                .with(<span class="hljs-string">&quot;my-yyds&quot;</span>)   <span class="hljs-comment">//使用自定义的routingKey</span><br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来创建一个生产者，这里我们直接编写在测试用例中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringCloudMqApplicationTests</span> &#123;<br><br>  <span class="hljs-comment">//RabbitTemplate为我们封装了大量的RabbitMQ操作，已经由Starter提供，因此直接注入使用即可</span><br>    <span class="hljs-meta">@Resource</span><br>    RabbitTemplate template;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//使用convertAndSend方法一步到位，参数基本和之前是一样的</span><br>      <span class="hljs-comment">//最后一个消息本体可以是Object类型，真是大大的方便</span><br>        template.convertAndSend(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来运行一下这个测试用例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fe1qms43j219c03kgme.jpg" alt="image-20220419221426545"></p><p>可以看到后台自动声明了我们刚刚定义好的消息队列和交换机以及对应的绑定关系，并且我们的数据也是成功插入到消息队列中：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fe2uj02vj21wu0fkmyf.jpg" alt="image-20220419221532673"></p><p>现在我们再来看看如何创建一个消费者，因为消费者实际上就是一直等待消息然后进行处理的角色，这里我们只需要创建一个监听器就行了，它会一直等待消息到来然后再进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//注册为Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;)</span>   <span class="hljs-comment">//定义此方法为队列yyds的监听器，一旦监听到新的消息，就会接受并处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Message message)</span>&#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们启动服务器：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fffku7l0j228w0faaip.jpg" alt="image-20220419230223151"></p><p>可以看到控制台成功输出了我们之前放入队列的消息，并且管理页面中也显示此消费者已经连接了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ffghhmdyj21wg05ogmh.jpg" alt="image-20220419230315376"></p><p>接着我们再通过管理页面添加新的消息看看，也是可以正常进行接受的。</p><p>当然，如果我们需要确保消息能够被消费者接受并处理，然后得到消费者的反馈，也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//会等待消费者消费然后返回响应结果</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> template.convertSendAndReceive(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;收到消费者响应：&quot;</span>+res);<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者这边只需要返回一个对应的结果即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;收到!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试没有问题：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hbp9t5wsj21ce066gmt.jpg" alt="image-20220421142425891"></p><p>那么如果我们需要直接接收一个JSON格式的消息，并且希望直接获取到实体类呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br>  ...<br><br>    <span class="hljs-meta">@Bean(&quot;jacksonConverter&quot;)</span>   <span class="hljs-comment">//直接创建一个用于JSON转换的Bean</span><br>    <span class="hljs-keyword">public</span> Jackson2JsonMessageConverter <span class="hljs-title function_">converter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们只需要指定转换器就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br><br>  <span class="hljs-comment">//指定messageConverter为我们刚刚创建的Bean名称</span><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;, messageConverter = &quot;jacksonConverter&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(User user)</span>&#123;  <span class="hljs-comment">//直接接收User类型</span><br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们直接在管理页面发送：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;LB&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1byhcakabj221m0lwac0.jpg" alt="image-20220416225912100"></p><p>可以看到成功完成了转换，并输出了用户信息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1byglk5pmj21ji04imyp.jpg" alt="image-20220416225829807"></p><p>同样的，我们也可以直接发送User，因为我们刚刚已经配置了Jackson2JsonMessageConverter为Bean，所以直接使用就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> &#123;<br>    template.convertAndSend(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;yyds&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到后台的数据类型为：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fg5g2h6xj21k20gmmyl.jpg" alt="image-20220419232715025"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1bz013oa7j21c804q755.jpg" alt="image-20220416231709750"></p><p>这样，我们就通过SpringBoot实现了RabbitMQ的简单使用。</p><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>消息队列中的数据，如果迟迟没有消费者来处理，那么就会一直占用消息队列的空间。比如我们模拟一下抢车票的场景，用户下单高铁票之后，会进行抢座，然后再进行付款，但是如果用户下单之后并没有及时的付款，这张票不可能一直让这个用户占用着，因为你不买别人还要买呢，所以会在一段时间后超时，让这张票可以继续被其他人购买。</p><p>这时，我们就可以使用死信队列，将那些用户超时未付款的或是用户主动取消的订单，进行进一步的处理，以下类型的消息都会被判定为死信：</p><ul><li>消息被拒绝(basic.reject &#x2F; basic.nack)，并且requeue &#x3D; false</li><li>消息TTL过期</li><li>队列达到最大长度</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ev8hxtm7j21do07g0tn.jpg" alt="image-20220419112336088"></p><p>那么如何构建这样的一种使用模式呢？实际上本质就是一个死信交换机+绑定的死信队列，当正常队列中的消息被判定为死信时，会被发送到对应的死信交换机，然后再通过交换机发送到死信队列中，死信队列也有对应的消费者去处理消息。</p><p>这里我们直接在配置类中创建一个新的死信交换机和死信队列，并进行绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;directDlExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">dlExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//创建一个新的死信交换机</span><br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(<span class="hljs-string">&quot;dlx.direct&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yydsDlQueue&quot;)</span>   <span class="hljs-comment">//创建一个新的死信队列</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">dlQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>                .nonDurable(<span class="hljs-string">&quot;dl-yyds&quot;</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;dlBinding&quot;)</span>   <span class="hljs-comment">//死信交换机和死信队列进绑定</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">dlBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;directDlExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsDlQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;dl-yyds&quot;</span>)<br>                .noargs();<br>    &#125;<br><br>...<br><br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>                .nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>)<br>                .deadLetterExchange(<span class="hljs-string">&quot;dlx.direct&quot;</span>)   <span class="hljs-comment">//指定死信交换机</span><br>                .deadLetterRoutingKey(<span class="hljs-string">&quot;dl-yyds&quot;</span>)   <span class="hljs-comment">//指定死信RoutingKey</span><br>                .build();<br>    &#125;<br>  <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们将监听器修改为死信队列监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;dl-yyds&quot;, messageConverter = &quot;jacksonConverter&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(User user)</span>&#123;<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置完成后，我们来尝试启动一下吧，注意启动之前记得把之前的队列给删了，这里要重新定义。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fzk61bo9j21pu06wdgy.jpg" alt="image-20220420103846981"></p><p>队列列表中已经出现了我们刚刚定义好的死信队列，并且yyds队列也支持死信队列发送功能了，现在我们尝试向此队列发送一个消息，但是我们将其拒绝：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g000aphbj21ri08yaau.jpg" alt="image-20220420105359931"></p><p>可以看到拒绝后，如果不让消息重新排队，那么就会变成死信，直接被丢进死信队列中，可以看到在拒绝后：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g00ywpelj21lk03q75w.jpg" alt="image-20220420105455291"></p><p>现在我们来看看第二种情况，RabbitMQ支持将超过一定时间没被消费的消息自动删除，这需要消息队列设定TTL值，如果消息的存活时间超过了Time To Live值，就会被自动删除，自动删除后的消息如果有死信队列，那么就会进入到死信队列中。</p><p>现在我们将yyds消息队列设定TTL值（毫秒为单位）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>            .nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>)<br>            .deadLetterExchange(<span class="hljs-string">&quot;dlx.direct&quot;</span>)<br>            .deadLetterRoutingKey(<span class="hljs-string">&quot;dl-yyds&quot;</span>)<br>            .ttl(<span class="hljs-number">5000</span>)   <span class="hljs-comment">//如果5秒没处理，就自动删除</span><br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们重启测试一下，注意修改了之后记得删除之前的yyds队列：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g09oljcsj21lw06agmx.jpg" alt="image-20220420110317997"></p><p>可以看到现在yyds队列已经具有TTL特性了，我们现在来插入一个新的消息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g0bin3whj21lk08mjs4.jpg" alt="image-20220420110504022"></p><p>可以看到消息5秒钟之后就不见了，而是被丢进了死信队列中。</p><p>最后我们来看一下当消息队列长度达到最大的情况，现在我们将消息队列的长度进行限制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>            .nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>)<br>            .deadLetterExchange(<span class="hljs-string">&quot;dlx.direct&quot;</span>)<br>            .deadLetterRoutingKey(<span class="hljs-string">&quot;dl-yyds&quot;</span>)<br>            .maxLength(<span class="hljs-number">3</span>)   <span class="hljs-comment">//将最大长度设定为3</span><br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们重启一下，然后尝试连续插入4个消息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1g56k0whnj21l008awfp.jpg" alt="image-20220420135316458"></p><p>可以看到yyds消息队列新增了Limit特性，也就是限定长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <br>        template.convertAndSend(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1g57n6wlpj21r4032wfx.jpg" alt="image-20220420135419673"></p><p>可以看到因为长度限制为3，所以有一个消息直接被丢进了死信队列中，为了能够更直观地观察消息队列的机制，我们为User类新增一个时间字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>接着每隔一秒钟插入一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        template.convertAndSend(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次进行上述实验，可以发现如果到达队列长度限制，那么每次插入都会把位于队首的消息丢进死信队列，来腾出空间给新来的消息。</p><h3 id="工作队列模式"><a href="#工作队列模式" class="headerlink" title="工作队列模式"></a>工作队列模式</h3><p><strong>注意：</strong>XX模式只是一种设计思路，并不是指的具体的某种实现，可以理解为实现XX模式需要怎么去写。</p><p>前面我们了解了最简的一个消费者一个生产者的模式，接着我们来了解一下一个生产者多个消费者的情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1g7hh8h18j21he06mt8x.jpg" alt="image-20220420151258324"></p><p>实际上这种模式就非常适合多个工人等待新的任务到来的场景，我们的任务有很多个，一个一个丢进消息队列，而此时工人有很多个，那么我们就可以将这些任务分配个各个工人，让他们各自负责一些任务，并且做的快的工人还可以做完成一些（能者多劳）。</p><p>非常简单，我们只需要创建两个监听器即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;   <span class="hljs-comment">//这里直接接收String类型的数据</span><br>        System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver2</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;二号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们发送消息时，会自动进行轮询分发：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1g8fw63klj21f406gzl5.jpg" alt="image-20220420154602883"></p><p>那么如果我们一开始就在消息队列中放入一部分消息在开启消费者呢？</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1g8gs2duqj21fe05s74x.jpg" alt="image-20220420154654901"></p><p>可以看到，如果是一开始就存在消息，会被一个消费者一次性全部消耗，这是因为我们没有对消费者的Prefetch count（预获取数量，一次性获取消息的最大数量）进行限制，也就是说我们现在希望的是消费者一次只能拿一个消息，而不是将所有的消息全部都获取。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1g8xeq182j21fo05qt9x.jpg" alt="image-20220420160253144"></p><p>因此我们需要对这个数量进行一些配置，这里我们需要在配置类中定义一个自定义的ListenerContainerFactory，可以在这里设定消费者Channel的PrefetchCount的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> CachingConnectionFactory connectionFactory;<br><br><span class="hljs-meta">@Bean(name = &quot;listenerContainer&quot;)</span><br><span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title function_">listenerContainer</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SimpleRabbitListenerContainerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRabbitListenerContainerFactory</span>();<br>    factory.setConnectionFactory(connectionFactory);<br>    factory.setPrefetchCount(<span class="hljs-number">1</span>);   <span class="hljs-comment">//将PrefetchCount设定为1表示一次只能取一个</span><br>    <span class="hljs-keyword">return</span> factory;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在监听器这边指定即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;,  containerFactory = &quot;listenerContainer&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;, containerFactory = &quot;listenerContainer&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver2</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;二号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们再次启动服务器，可以看到PrefetchCount被限定为1了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ga7d3x42j21m006sdh7.jpg" alt="image-20220420164702864"></p><p>再次重复上述的实现，可以看到消息不会被一号消费者给全部抢走了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ga8tuajtj21la05sgmd.jpg" alt="image-20220420164827502"></p><p>当然除了去定义两个相同的监听器之外，我们也可以直接在注解中定义，比如我们现在需要10个同样的消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;,  containerFactory = &quot;listenerContainer&quot;, concurrency = &quot;10&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在管理页面中出现了10个消费者：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1gaotg34ij21qg0fuaeh.jpg" alt="image-20220420170349298"></p><p>至此，有关工作队列模式就讲到这里。</p><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>前面我们已经了解了RabbitMQ客户端的一些基本操作，包括普通的消息模式，接着我们来了解一下其他的模式，首先是发布订阅模式，它支持多种方式：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1gb8mwfc9j21gy08emxj.jpg" alt="image-20220420172252440"></p><p>比如我们在阿里云买了云服务器，但是最近快到期了，那么就会给你的手机、邮箱发送消息，告诉你需要去续费了，但是手机短信和邮件发送并不一定是同一个业务提供的，但是现在我们又希望能够都去执行，所以就可以用到发布订阅模式，简而言之就是，发布一次，消费多个。</p><p>实现这种模式其实也非常简单，但是如果使用我们之前的直连交换机，肯定是不行的，我们这里需要用到另一种类型的交换机，叫做<code>fanout</code>（扇出）类型，这时一种广播类型，消息会被广播到所有与此交换机绑定的消息队列中。</p><p>这里我们使用默认的交换机：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gks5vbsxj20za020t8p.jpg" alt="image-20220420225300171"></p><p>这个交换机是一个<code>fanout</code>类型的交换机，我们就是要它就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;fanoutExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//注意这里是fanoutExchange</span><br>        <span class="hljs-keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="hljs-string">&quot;amq.fanout&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yydsQueue1&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds1&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;fanoutExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue1&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;yyds1&quot;</span>)<br>                .noargs();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yydsQueue2&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds2&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;binding2&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;fanoutExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue2&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;yyds2&quot;</span>)<br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们将两个队列都绑定到此交换机上，我们先启动看看效果：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gl9px6doj21tc0bimxv.jpg" alt="image-20220420230954785"></p><p>绑定没有什么问题，接着我们搞两个监听器，监听一下这两个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds2&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver2</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;二号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们通过交换机发送消息，看看是不是两个监听器都会接收到消息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1glb33v3wj21ky0k80ts.jpg" alt="image-20220420231113658"></p><p>可以看到确实是两个消息队列都能够接受到此消息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1glbn729uj21be03umxp.jpg" alt="image-20220420231145578"></p><p>这样我们就实现了发布订阅模式。</p><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>路由模式实际上我们一开始就已经实现了，我们可以在绑定时指定想要的<code>routingKey</code>只有生产者发送时指定了对应的<code>routingKey</code>才能到达对应的队列。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1glt0bescj21dk08mjru.jpg" alt="image-20220420232826848"></p><p>当然除了我们之前的一次绑定之外，同一个消息队列可以多次绑定到交换机，并且使用不同的<code>routingKey</code>，这样只要满足其中一个都可以被发送到此消息队列中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;directExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(<span class="hljs-string">&quot;amq.direct&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span>   <span class="hljs-comment">//使用yyds1绑定</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;directExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;yyds1&quot;</span>)<br>                .noargs();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;binding2&quot;)</span>   <span class="hljs-comment">//使用yyds2绑定</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;directExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;yyds2&quot;</span>)<br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动后我们可以看到管理面板中出现了两个绑定关系：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gm0zb3hej21kq0eagmk.jpg" alt="image-20220420233606749"></p><p>这里可以测试一下，随便使用哪个<code>routingKey</code>都可以。</p><h3 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h3><p>实际上这种模式就是一种模糊匹配的模式，我们可以将<code>routingKey</code>以模糊匹配的方式去进行转发。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gm29nni5j21fs08874r.jpg" alt="image-20220420233721239"></p><p>我们可以使用<code>*</code>或<code>#</code>来表示：</p><ul><li>* - 表示任意的一个单词</li><li># - 表示0个或多个单词</li></ul><p>这里我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;topicExchange&quot;)</span>  <span class="hljs-comment">//这里使用预置的Topic类型交换机</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.topicExchange(<span class="hljs-string">&quot;amq.topic&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;topicExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;*.test.*&quot;</span>)<br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动项目，可以看到只要是满足通配符条件的都可以成功转发到对应的消息队列：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1h55kezhaj21jk0ke0to.jpg" alt="image-20220421103753962"></p><p>接着我们可以再试试看<code>#</code>通配符。</p><p>除了我们这里使用的默认主题交换机之外，还有一个叫做<code>amq.rabbitmq.trace</code>的交换机：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1h58cwa5oj20z6024jrf.jpg" alt="image-20220421104035463"></p><p>可以看到它也是<code>topic</code>类型的，那么这个交换机是做什么的呢？实际上这是用于帮助我们记录和追踪生产者和消费者使用消息队列的交换机，它是一个内部的交换机，那么如果使用呢？首先创建一个消息队列用于接收记录：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1h5ebv4vnj21f407wt9u.jpg" alt="image-20220421104619325"></p><p>接着我们需要在控制台将虚拟主机<code>/test</code>的追踪功能开启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl trace_on -p /test<br></code></pre></td></tr></table></figure><p>开启后，我们将此队列绑定到上面的交换机上：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1h5gtqdrlj21gk09st9f.jpg" alt="image-20220421104843224"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1h5jwqqf1j21cc09kdgg.jpg" alt="image-20220421105141144"></p><p>由于发送到此交换机上的<code>routingKey</code>为routing key为 publish.交换机名称 和 deliver.队列名称，分别对应生产者投递到交换机的消息，和消费者从队列上获取的消息，因此这里使用<code>#</code>通配符进行绑定。</p><p>现在我们来测试一下，比如还是往yyds队列发送消息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1h5kz432vj21ks080mxw.jpg" alt="image-20220421105242770"></p><p>可以看到在发送消息，并且消费者已经处理之后，<code>trace</code>队列中新增了两条消息，那么我们来看看都是些什么消息：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1h5nunf9kj21jg0m0jth.jpg" alt="image-20220421105528532"></p><p>通过追踪，我们可以很明确地得知消息发送的交换机、routingKey、用户等信息，包括信息本身，同样的，消费者在取出数据时也有记录：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1h5p26b1oj21nc0k440e.jpg" alt="image-20220421105638715"></p><p>我们可以明确消费者的地址、端口、具体操作的队列以及取出的消息信息等。</p><p>到这里，我们就已经了解了3种类型的交换机。</p><h3 id="第四种交换机类型"><a href="#第四种交换机类型" class="headerlink" title="第四种交换机类型"></a>第四种交换机类型</h3><p>通过前面的学习，我们已经介绍了三种交换机类型，现在我们来介绍一下第四种交换机类型<code>header</code>，它是根据头部信息来决定的，在我们发送的消息中是可以携带一些头部信息的（类似于HTTP），我们可以根据这些头部信息来决定路由到哪一个消息队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;headerExchange&quot;)</span>  <span class="hljs-comment">//注意这里返回的是HeadersExchange</span><br>    <span class="hljs-keyword">public</span> HeadersExchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder<br>                .headersExchange(<span class="hljs-string">&quot;amq.headers&quot;</span>)  <span class="hljs-comment">//RabbitMQ为我们预置了两个，这里用第一个就行</span><br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;headerExchange&quot;)</span> HeadersExchange exchange,  //这里和上面一样的类型</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)   <span class="hljs-comment">//使用HeadersExchange的to方法，可以进行进一步配置</span><br>          <span class="hljs-comment">//.whereAny(&quot;a&quot;, &quot;b&quot;).exist();   这个是只要存在任意一个指定的头部Key就行</span><br>                <span class="hljs-comment">//.whereAll(&quot;a&quot;, &quot;b&quot;).exist();   这个是必须存在所有指定的的头部Key</span><br>                .where(<span class="hljs-string">&quot;test&quot;</span>).matches(<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">//比如我们现在需要消息的头部信息中包含test，并且值为hello才能转发给我们的消息队列</span><br>      <span class="hljs-comment">//.whereAny(Collections.singletonMap(&quot;test&quot;, &quot;hello&quot;)).match();  传入Map也行，批量指定键值对</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来启动一下试试看：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1h62dn6msj21zk0moq4k.jpg" alt="image-20220421110926077"></p><p>结果发现，消息可以成功发送到消息队列，这就是使用头部信息进行路由。</p><p>这样，我们就介绍完了所有四种类型的交换机。</p><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p>前面我们对于RabbitMQ的相关内容已经基本讲解完毕了，最后我们来尝试搭建一个集群，让RabbitMQ之间进行数据复制（镜像模式）稍微有点麻烦，跟着视频走吧。</p><p>可能会用到的一些命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl stop_app<br>sudo rabbitmqctl join_cluster rabbit@ubuntu-server<br>sudo rabbitmqctl start_app<br></code></pre></td></tr></table></figure><p>实现复制即可。</p><hr><h2 id="SpringCloud-消息组件"><a href="#SpringCloud-消息组件" class="headerlink" title="SpringCloud 消息组件"></a>SpringCloud 消息组件</h2><p>前面我们已经学习了如何使用RabbitMQ消息队列，接着我们来简单介绍一下SpringCloud为我们提供的一些消息组件。</p><h3 id="SpringCloud-Stream"><a href="#SpringCloud-Stream" class="headerlink" title="SpringCloud Stream"></a>SpringCloud Stream</h3><p><strong>官方文档：</strong><a href="https://docs.spring.io/spring-cloud-stream/docs/3.2.2/reference/html/">https://docs.spring.io/spring-cloud-stream/docs/3.2.2/reference/html/</a></p><p>前面我们介绍了RabbitMQ，了解了消息队列相关的一些操作，但是可能我们会遇到不同的系统在用不同的消息队列，比如系统A用的Kafka、系统B用的RabbitMQ，但是我们现在又没有学习过Kafka，那么怎么办呢？有没有一种方式像JDBC一样，我们只需要关心SQL和业务本身，而不用关心数据库的具体实现呢？</p><p>SpringCloud Stream能够做到，它能够屏蔽底层实现，我们使用统一的消息队列操作方式就能操作多种不同类型的消息队列。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hqdnqlqsj21iu0l0myd.jpg" alt="image-20220421225215709"></p><p>它屏蔽了RabbitMQ底层操作，让我们使用统一的Input和Output形式，以Binder为中间件，这样就算我们切换了不同的消息队列，也无需修改代码，而具体某种消息队列的底层实现是交给Stream在做的。</p><p>这里我们创建一个新的项目来测试一下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hoqprxzxj21mm0bmtbx.jpg" alt="image-20220421215534386"></p><p>依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  RabbitMQ的Stream实现  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先我们来编写一下生产者，首先是配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">binders:</span>   <span class="hljs-comment">#此处配置要绑定的rabbitmq的服务信息</span><br>        <span class="hljs-attr">local-server:</span> <span class="hljs-comment">#绑定名称，随便起一个就行</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">rabbit</span> <span class="hljs-comment">#消息组件类型，这里使用的是RabbitMQ，就填写rabbit</span><br>          <span class="hljs-attr">environment:</span>  <span class="hljs-comment">#服务器相关信息，按照下面的方式填写就行，爆红别管</span><br>            <span class="hljs-attr">spring:</span><br>              <span class="hljs-attr">rabbitmq:</span><br>                <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.6</span><br>                <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>                <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>                <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>                <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/test</span><br>       <span class="hljs-attr">bindings:</span><br>        <span class="hljs-attr">test-out-0:</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">test.exchange</span><br></code></pre></td></tr></table></figure><p>接着我们来编写一个Controller，一会访问一次这个接口，就向消息队列发送一个数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PublishController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    StreamBridge bridge;  <span class="hljs-comment">//通过bridge来发送消息</span><br><br>    <span class="hljs-meta">@RequestMapping(&quot;/publish&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">publish</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//第一个参数其实就是RabbitMQ的交换机名称（数据会发送给这个交换机，到达哪个消息队列，不由我们决定）</span><br>      <span class="hljs-comment">//这个交换机的命名稍微有一些规则:</span><br>      <span class="hljs-comment">//输入:    &lt;名称&gt; + -in- + &lt;index&gt;</span><br>      <span class="hljs-comment">//输出:    &lt;名称&gt; + -out- + &lt;index&gt;</span><br>      <span class="hljs-comment">//这里我们使用输出的方式，来将数据发送到消息队列，注意这里的名称会和之后的消费者Bean名称进行对应</span><br>        bridge.send(<span class="hljs-string">&quot;test-out-0&quot;</span>, <span class="hljs-string">&quot;HelloWorld!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;消息发送成功！&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来将生产者启动一下，访问一下接口：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hp5m6t34j21fk06ggmc.jpg" alt="image-20220421220955906"></p><p>可以看到消息成功发送，我们来看看RabbitMQ这边的情况：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hp65svdxj21bg02it8r.jpg" alt="image-20220421221027145"></p><p>新增了一个<code>test-in-0</code>交换机，并且此交换机是topic类型的：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hp6umeypj218w07a0st.jpg" alt="image-20220421221107547"></p><p>但是目前没有任何队列绑定到此交换机上，因此我们刚刚发送的消息实际上是没有给到任何队列的。</p><p>接着我们来编写一下消费者，消费者的编写方式比较特别，只需要定义一个Consumer就可以了，其他配置保持一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerComponent</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;test&quot;)</span>   <span class="hljs-comment">//注意这里需要填写我们前面交换机名称中&quot;名称&quot;，这样生产者发送的数据才会正确到达</span><br>    <span class="hljs-keyword">public</span> Consumer&lt;String&gt; <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> System.out::println;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置中需要修改一下目标交换机：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8002</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>    <span class="hljs-string">...</span><br>      <span class="hljs-attr">bindings:</span><br>      <span class="hljs-comment">#因为消费者是输入，默认名称为 方法名-in-index，这里我们将其指定为我们刚刚定义的交换机</span><br>        <span class="hljs-attr">test-in-0:</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">test.exchange</span><br></code></pre></td></tr></table></figure><p>接着我们直接启动就可以了，可以看到启动之后，自动为我们创建了一个新的队列：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hpdjthrqj21sy05mdgw.jpg" alt="image-20220421221733723"></p><p>而这个队列实际上就是我们消费者等待数据到达的队列：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hpe5c8o3j21q00h4q4p.jpg" alt="image-20220421221807577"></p><p>可以看到当前队列直接绑定到了我们刚刚创建的交换机上，并且<code>routingKey</code>是直接写的<code>#</code>，也就是说一会消息会直接过来。</p><p>现在我们再来访问一些消息发送接口：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hpfpyn57j212m05y3z4.jpg" alt="image-20220421221938730"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hpfyqu94j21na09kwg3.jpg" alt="image-20220421221952663"></p><p>可以看到消费者成功地进行消费了：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hpgb6zgej218605qq4d.jpg" alt="image-20220421222011924"></p><p>这样，我们就通过使用SpringCloud Stream来屏蔽掉底层RabbitMQ来直接进行消息的操作了。</p><h3 id="SpringCloud-Bus"><a href="#SpringCloud-Bus" class="headerlink" title="SpringCloud Bus"></a>SpringCloud Bus</h3><p><strong>官方文档：</strong><a href="https://cloud.spring.io/spring-cloud-bus/reference/html/">https://cloud.spring.io/spring-cloud-bus/reference/html/</a></p><p>实际上它就相当于是一个消息总线，可用于向各个服务广播某些状态的更改（比如云端配置更改，可以结合Config组件实现动态更新配置，当然我们前面学习的Nacos其实已经包含这个功能了）或其他管理指令。</p><p>这里我们也是简单使用一下吧，Bus需要基于一个具体的消息队列实现，比如RabbitMQ或是Kafka，这里我们依然使用RabbitMQ。</p><p>我们将最开始的微服务拆分项目继续使用，比如现在我们希望借阅服务的某个接口调用时，能够给用户服务和图书服务发送一个通知，首先是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们只需要在配置文件中将RabbitMQ的相关信息配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">addresses:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.6</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/test</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span>    <span class="hljs-comment">#暴露端点，一会用于提醒刷新</span><br></code></pre></td></tr></table></figure><p>然后启动我们的三个服务器，可以看到在管理面板中：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hr7w6mluj210m01qq2x.jpg" alt="image-20220421232118952"></p><p>新增了springCloudBug这样一个交换机，并且：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hr8d3b38j21uo084411.jpg" alt="image-20220421232146646"></p><p>自动生成了各自的消息队列，这样就可以监听并接收到消息了。</p><p>现在我们访问一个端口：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hrj15tx4j227m0k0gqo.jpg" alt="image-20220421233200950"></p><p>此端口是用于通知别人进行刷新，可以看到调用之后，消息队列中成功出现了一次消费：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1hrk3h5xrj21rk0aegna.jpg" alt="image-20220421233302328"></p><p>现在我们结合之前使用的Config配置中心，来看看是不是可以做到通知之后所有的配置动态刷新了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Mq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot其他框架</title>
    <link href="/2022/10/02/Springboot%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/10/02/Springboot%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot其他框架"><a href="#SpringBoot其他框架" class="headerlink" title="SpringBoot其他框架"></a>SpringBoot其他框架</h1><p>通过了解其他的SpringBoot框架，我们就可以在我们自己的Web服务器上实现更多更高级的功能。</p><h2 id="邮件发送：Mail"><a href="#邮件发送：Mail" class="headerlink" title="邮件发送：Mail"></a>邮件发送：Mail</h2><p>我们在注册很多的网站时，都会遇到邮件或是手机号验证，也就是通过你的邮箱或是手机短信去接受网站发给你的注册验证信息，填写验证码之后，就可以完成注册了，同时，网站也会绑定你的手机号或是邮箱。</p><p>那么，像这样的功能，我们如何实现呢？SpringBoot已经给我们提供了封装好的邮件模块使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h3><p>在学习邮件发送之前，我们需要先了解一下什么是电子邮件。</p><p>电子邮件也是一种通信方式，是互联网应用最广的服务。通过网络的电子邮件系统，用户可以以非常低廉的价格（不管发送到哪里，都只需负担网费，实际上就是把信息发送到对方服务器而已）、非常快速的方式，与世界上任何一个地方的电子邮箱用户联系。</p><p>虽说方便倒是方便，虽然是曾经的霸主，不过现在这个时代，QQ微信横行，手机短信和电子邮箱貌似就只剩收验证码这一个功能了。</p><p>要在Internet上提供电子邮件功能，必须有专门的电子邮件服务器。例如现在Internet很多提供邮件服务的厂商：新浪、搜狐、163、QQ邮箱等，他们都有自己的邮件服务器。这些服务器类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中。</p><p>所有的用户都可以在电子邮件服务器上申请一个账号用于邮件发送和接收，那么邮件是以什么样的格式发送的呢？实际上和Http一样，邮件发送也有自己的协议，也就是约定邮件数据长啥样以及如何通信。</p><p><img src="https://images2015.cnblogs.com/blog/851491/201612/851491-20161202143243756-1715308358.png" alt="img"></p><p>比较常用的协议有两种：</p><ol><li>SMTP协议（主要用于发送邮件 Simple Mail Transfer Protocol）</li><li>POP3协议（主要用于接收邮件 Post Office Protocol 3）</li></ol><p>整个发送&#x2F;接收流程大致如下：</p><p><img src="https://img2.baidu.com/it/u=3675146129,445744702&fm=253&fmt=auto&app=138&f=JPG?w=812&h=309" alt="img"></p><p>实际上每个邮箱服务器都有一个smtp发送服务器和pop3接收服务器，比如要从QQ邮箱发送邮件到163邮箱，那么我们只需要通过QQ邮箱客户端告知QQ邮箱的smtp服务器我们需要发送邮件，以及邮件的相关信息，然后QQ邮箱的smtp服务器就会帮助我们发送到163邮箱的pop3服务器上，163邮箱会通过163邮箱客户端告知对应用户收到一封新邮件。</p><p>而我们如果想要实现给别人发送邮件，那么就需要连接到对应电子邮箱的smtp服务器上，并告知其我们要发送邮件。而SpringBoot已经帮助我们将最基本的底层通信全部实现了，我们只需要关心smtp服务器的地址以及我们要发送的邮件长啥样即可。</p><p>这里以163邮箱 <a href="https://mail.163.com/">https://mail.163.com</a> 为例，我们需要在配置文件中告诉SpringBootMail我们的smtp服务器的地址以及你的邮箱账号和密码，首先我们要去设置中开启smtp&#x2F;pop3服务才可以，开启后会得到一个随机生成的密钥，这个就是我们的密码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>  <span class="hljs-comment"># 163邮箱的地址为smtp.163.com，直接填写即可</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span><br>    <span class="hljs-comment"># 你申请的163邮箱</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">javastudy111@163.com</span><br>    <span class="hljs-comment"># 注意密码是在开启smtp/pop3时自动生成的，记得保存一下，不然就找不到了</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">AZJTOAWZESLMHTNI</span><br></code></pre></td></tr></table></figure><p>配置完成后，接着我们来进行一下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootTestApplicationTests</span> &#123;<br><br>  <span class="hljs-comment">//JavaMailSender是专门用于发送邮件的对象，自动配置类已经提供了Bean</span><br>    <span class="hljs-meta">@Autowired</span><br>    JavaMailSender sender;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//SimpleMailMessage是一个比较简易的邮件封装，支持设置一些比较简单内容</span><br>        <span class="hljs-type">SimpleMailMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleMailMessage</span>();<br>      <span class="hljs-comment">//设置邮件标题</span><br>        message.setSubject(<span class="hljs-string">&quot;【电子科技大学教务处】关于近期学校对您的处分决定&quot;</span>);<br>      <span class="hljs-comment">//设置邮件内容</span><br>        message.setText(<span class="hljs-string">&quot;XXX同学您好，经监控和教务巡查发现，您近期存在旷课、迟到、早退、上课刷抖音行为，&quot;</span> +<br>                <span class="hljs-string">&quot;现已通知相关辅导员，请手写5000字书面检讨，并在2022年4月1日17点前交到辅导员办公室。&quot;</span>);<br>      <span class="hljs-comment">//设置邮件发送给谁，可以多个，这里就发给你的QQ邮箱</span><br>        message.setTo(<span class="hljs-string">&quot;你的QQ号@qq.com&quot;</span>);<br>      <span class="hljs-comment">//邮件发送者，这里要与配置文件中的保持一致</span><br>        message.setFrom(<span class="hljs-string">&quot;javastudy111@163.com&quot;</span>);<br>      <span class="hljs-comment">//OK，万事俱备只欠发送</span><br>        sender.send(message);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要添加附件等更多功能，可以使用MimeMessageHelper来帮助我们完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException &#123;<br>  <span class="hljs-comment">//创建一个MimeMessage</span><br>    <span class="hljs-type">MimeMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sender.createMimeMessage();<br>  <span class="hljs-comment">//使用MimeMessageHelper来帮我们修改MimeMessage中的信息</span><br>    <span class="hljs-type">MimeMessageHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMessageHelper</span>(message, <span class="hljs-literal">true</span>);<br>    helper.setSubject(<span class="hljs-string">&quot;Test&quot;</span>);<br>    helper.setText(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    helper.setTo(<span class="hljs-string">&quot;你的QQ号@qq.com&quot;</span>);<br>    helper.setFrom(<span class="hljs-string">&quot;javastudy111@163.com&quot;</span>);<br>  <span class="hljs-comment">//发送修改好的MimeMessage</span><br>    sender.send(message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邮件注册"><a href="#邮件注册" class="headerlink" title="邮件注册"></a>邮件注册</h3><p>既然我们已经了解了邮件发送，那么我们接着来看如何在我们的项目中实现邮件验证。</p><p>首先明确验证流程：请求验证码 -&gt; 生成验证码（临时有效，注意设定过期时间） -&gt; 用户输入验证码并填写注册信息 -&gt; 验证通过注册成功！</p><hr><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-6f0b9bb234b2534ec295ff195bad183a_1440w.jpg%3Fsource%3D172ae18b&refer=http%3A%2F%2Fpic1.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645108924&t=d40aa5dc6be398725b4ff21ef5895454" alt="点击查看图片来源"></p><h2 id="持久层框架：JPA"><a href="#持久层框架：JPA" class="headerlink" title="持久层框架：JPA"></a>持久层框架：JPA</h2><ul><li>用了Mybatis之后，你看那个JDBC，真是太逊了。</li><li>这么说，你的项目很勇哦？</li><li>开玩笑，我的写代码超勇的好不好。</li><li>阿伟，你可曾幻想过有一天你的项目里不再有SQL语句？</li><li>不再有SQL语句？那我怎么和数据库交互啊？</li><li>我看你是完全不懂哦</li><li>懂，懂什么啊？</li><li>你想懂？来，到我项目里来，我给你看点好康的。</li><li>好康？是什么新框架哦？</li><li>什么新框架，比新框架还刺激，还可以让你的项目登duang郎哦。</li><li>哇，杰哥，你项目里面都没SQL语句诶，这是用的什么框架啊？</li></ul><p>在我们之前编写的项目中，我们不难发现，实际上大部分的数据库交互操作，到最后都只会做一个事情，那就是把数据库中的数据映射为Java中的对象。比如我们要通过用户名去查找对应的用户，或是通过ID查找对应的学生信息，在使用Mybatis时，我们只需要编写正确的SQL语句就可以直接将获取的数据映射为对应的Java对象，通过调用Mapper中的方法就能直接获得实体类，这样就方便我们在Java中数据库表中的相关信息了。</p><p>但是以上这些操作都有一个共性，那就是它们都是通过某种条件去进行查询，而最后的查询结果，都是一个实体类，所以你会发现你写的很多SQL语句都是一个套路<code>select * from xxx where xxx=xxx</code>，那么能否有一种框架，帮我们把这些相同的套路给封装起来，直接把这类相似的SQL语句给屏蔽掉，不再由我们编写，而是让框架自己去组合拼接。</p><h3 id="认识SpringDataJPA"><a href="#认识SpringDataJPA" class="headerlink" title="认识SpringDataJPA"></a>认识SpringDataJPA</h3><p>首先我们来看一个国外的统计：</p><p>![image-20220119140326867](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220119140326867.png)</p><p>不对吧，为什么Mybatis这么好用，这么强大，却只有10%的人喜欢呢？然而事实就是，在国外JPA几乎占据了主导地位，而Mybatis并不像国内那样受待见，所以你会发现，JPA都有SpringBoot的官方直接提供的starter，而Mybatis没有。</p><p>至于为啥SSM阶段不讲这个，而是放到现在来讲也是因为，在微服务场景下它的优势才能更多的发挥出来。</p><p>那么，什么是JPA？</p><p>JPA（Java Persistence API）和JDBC类似，也是官方定义的一组接口，但是它相比传统的JDBC，它是为了实现ORM而生的，即Object-Relationl Mapping，它的作用是在关系型数据库和对象之间形成一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。</p><p>在之前，我们使用JDBC或是Mybatis来操作数据，通过直接编写对应的SQL语句来实现数据访问，但是我们发现实际上我们在Java中大部分操作数据库的情况都是读取数据并封装为一个实体类，因此，为什么不直接将实体类直接对应到一个数据库表呢？也就是说，一张表里面有什么属性，那么我们的对象就有什么属性，所有属性跟数据库里面的字段一一对应，而读取数据时，只需要读取一行的数据并封装为我们定义好的实体类既可以，而具体的SQL语句执行，完全可以交给框架根据我们定义的映射关系去生成，不再由我们去编写，因为这些SQL实际上都是千篇一律的。</p><p>而实现JPA规范的框架一般最常用的就是<code>Hibernate</code>，它是一个重量级框架，学习难度相比Mybatis也更高一些，而SpringDataJPA也是采用Hibernate框架作为底层实现，并对其加以封装。</p><p>官网：<a href="https://spring.io/projects/spring-data-jpa">https://spring.io/projects/spring-data-jpa</a></p><h3 id="使用JPA"><a href="#使用JPA" class="headerlink" title="使用JPA"></a>使用JPA</h3><p>同样的，我们只需要导入stater依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们可以直接创建一个类，比如账户类，我们只需要把一个账号对应的属性全部定义好即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们可以通过注解形式，在属性上添加数据库映射关系，这样就能够让JPA知道我们的实体类对应的数据库表长啥样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span>   <span class="hljs-comment">//表示这个类是一个实体类</span><br><span class="hljs-meta">@Table(name = &quot;users&quot;)</span>    <span class="hljs-comment">//对应的数据库中表名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>   <span class="hljs-comment">//生成策略，这里配置为自增</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span>    <span class="hljs-comment">//对应表中id这一列</span><br>    <span class="hljs-meta">@Id</span>     <span class="hljs-comment">//此属性为主键</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;username&quot;)</span>   <span class="hljs-comment">//对应表中username这一列</span><br>    String username;<br><br>    <span class="hljs-meta">@Column(name = &quot;password&quot;)</span>   <span class="hljs-comment">//对应表中password这一列</span><br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来修改一下配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jpa:</span><br><span class="hljs-comment">#开启SQL语句执行日志信息</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">hibernate:</span><br>    <span class="hljs-comment">#配置为自动创建</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">create</span><br></code></pre></td></tr></table></figure><p><code>ddl-auto</code>属性用于设置自动表定义，可以实现自动在数据库中为我们创建一个表，表的结构会根据我们定义的实体类决定，它有4种</p><ul><li>create 启动时删数据库中的表，然后创建，退出时不删除数据表 </li><li>create-drop 启动时删数据库中的表，然后创建，退出时删除数据表 如果表不存在报错 </li><li>update 如果启动时表格式不一致则更新表，原有数据保留 </li><li>validate 项目启动表结构进行校验 如果不一致则报错</li></ul><p>我们可以在日志中发现，在启动时执行了如下SQL语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Hibernate: <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users (id <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment, <span class="hljs-keyword">password</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), username <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-keyword">primary key</span> (id)) engine=InnoDB<br></code></pre></td></tr></table></figure><p>而我们的数据库中对应的表已经创建好了。</p><p>我们接着来看如何访问我们的表，我们需要创建一个Repository实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意JpaRepository有两个泛型，前者是具体操作的对象实体，也就是对应的表，后者是ID的类型，接口中已经定义了比较常用的数据库操作。编写接口继承即可，我们可以直接注入此接口获得实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaTestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    AccountRepository repository;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//直接根据ID查找</span><br>        repository.findById(<span class="hljs-number">1</span>).ifPresent(System.out::println);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行后，成功得到查询结果。我们接着来测试增删操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">addAccount</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    account.setUsername(<span class="hljs-string">&quot;Admin&quot;</span>);<br>    account.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>    account = repository.save(account);  <span class="hljs-comment">//返回的结果会包含自动生成的主键值</span><br>    System.out.println(<span class="hljs-string">&quot;插入时，自动生成的主键ID为：&quot;</span>+account.getId());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAccount</span><span class="hljs-params">()</span>&#123;<br>    repository.deleteById(<span class="hljs-number">2</span>);   <span class="hljs-comment">//根据ID删除对应记录</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">pageAccount</span><span class="hljs-params">()</span> &#123;<br>    repository.findAll(PageRequest.of(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)).forEach(System.out::println);  <span class="hljs-comment">//直接分页</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，使用了JPA之后，整个项目的代码中没有出现任何的SQL语句，可以说是非常方便了，JPA依靠我们提供的注解信息自动完成了所有信息的映射和关联。</p><p>相比Mybatis，JPA几乎就是一个全自动的ORM框架，而Mybatis则顶多算是半自动ORM框架。</p><h3 id="方法名称拼接自定义SQL"><a href="#方法名称拼接自定义SQL" class="headerlink" title="方法名称拼接自定义SQL"></a>方法名称拼接自定义SQL</h3><p>虽然接口预置的方法使用起来非常方便，但是如果我们需要进行条件查询等操作或是一些判断，就需要自定义一些方法来实现，同样的，我们不需要编写SQL语句，而是通过方法名称的拼接来实现条件判断，这里列出了所有支持的条件判断名称：</p><table><thead><tr><th><code>Distinct</code></th><th><code>findDistinctByLastnameAndFirstname</code></th><th><code>select distinct … where x.lastname = ?1 and x.firstname = ?2</code></th></tr></thead><tbody><tr><td><code>And</code></td><td><code>findByLastnameAndFirstname</code></td><td><code>… where x.lastname = ?1 and x.firstname = ?2</code></td></tr><tr><td><code>Or</code></td><td><code>findByLastnameOrFirstname</code></td><td><code>… where x.lastname = ?1 or x.firstname = ?2</code></td></tr><tr><td><code>Is</code>，<code>Equals</code></td><td><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></td><td><code>… where x.firstname = ?1</code></td></tr><tr><td><code>Between</code></td><td><code>findByStartDateBetween</code></td><td><code>… where x.startDate between ?1 and ?2</code></td></tr><tr><td><code>LessThan</code></td><td><code>findByAgeLessThan</code></td><td><code>… where x.age &lt; ?1</code></td></tr><tr><td><code>LessThanEqual</code></td><td><code>findByAgeLessThanEqual</code></td><td><code>… where x.age &lt;= ?1</code></td></tr><tr><td><code>GreaterThan</code></td><td><code>findByAgeGreaterThan</code></td><td><code>… where x.age &gt; ?1</code></td></tr><tr><td><code>GreaterThanEqual</code></td><td><code>findByAgeGreaterThanEqual</code></td><td><code>… where x.age &gt;= ?1</code></td></tr><tr><td><code>After</code></td><td><code>findByStartDateAfter</code></td><td><code>… where x.startDate &gt; ?1</code></td></tr><tr><td><code>Before</code></td><td><code>findByStartDateBefore</code></td><td><code>… where x.startDate &lt; ?1</code></td></tr><tr><td><code>IsNull</code>，<code>Null</code></td><td><code>findByAge(Is)Null</code></td><td><code>… where x.age is null</code></td></tr><tr><td><code>IsNotNull</code>，<code>NotNull</code></td><td><code>findByAge(Is)NotNull</code></td><td><code>… where x.age not null</code></td></tr><tr><td><code>Like</code></td><td><code>findByFirstnameLike</code></td><td><code>… where x.firstname like ?1</code></td></tr><tr><td><code>NotLike</code></td><td><code>findByFirstnameNotLike</code></td><td><code>… where x.firstname not like ?1</code></td></tr><tr><td><code>StartingWith</code></td><td><code>findByFirstnameStartingWith</code></td><td><code>… where x.firstname like ?1</code>（参数与附加<code>%</code>绑定）</td></tr><tr><td><code>EndingWith</code></td><td><code>findByFirstnameEndingWith</code></td><td><code>… where x.firstname like ?1</code>（参数与前缀<code>%</code>绑定）</td></tr><tr><td><code>Containing</code></td><td><code>findByFirstnameContaining</code></td><td><code>… where x.firstname like ?1</code>（参数绑定以<code>%</code>包装）</td></tr><tr><td><code>OrderBy</code></td><td><code>findByAgeOrderByLastnameDesc</code></td><td><code>… where x.age = ?1 order by x.lastname desc</code></td></tr><tr><td><code>Not</code></td><td><code>findByLastnameNot</code></td><td><code>… where x.lastname &lt;&gt; ?1</code></td></tr><tr><td><code>In</code></td><td><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></td><td><code>… where x.age in ?1</code></td></tr><tr><td><code>NotIn</code></td><td><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></td><td><code>… where x.age not in ?1</code></td></tr><tr><td><code>True</code></td><td><code>findByActiveTrue()</code></td><td><code>… where x.active = true</code></td></tr><tr><td><code>False</code></td><td><code>findByActiveFalse()</code></td><td><code>… where x.active = false</code></td></tr><tr><td><code>IgnoreCase</code></td><td><code>findByFirstnameIgnoreCase</code></td><td><code>… where UPPER(x.firstname) = UPPER(?1)</code></td></tr></tbody></table><p>比如我们想要实现根据用户名模糊匹配查找用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br><span class="hljs-comment">//按照表中的规则进行名称拼接，不用刻意去记，IDEA会有提示</span><br>    List&lt;Account&gt; <span class="hljs-title function_">findAllByUsernameLike</span><span class="hljs-params">(String str)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    repository.findAllByUsernameLike(<span class="hljs-string">&quot;%T%&quot;</span>).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>又比如我们想同时根据用户名和ID一起查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br><br>    Account <span class="hljs-title function_">findByIdAndUsername</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String username)</span>;<br>  <span class="hljs-comment">//可以使用Optional类进行包装，Optional&lt;Account&gt; findByIdAndUsername(int id, String username);</span><br>    <br>    List&lt;Account&gt; <span class="hljs-title function_">findAllByUsernameLike</span><span class="hljs-params">(String str)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(repository.findByIdAndUsername(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Test&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们想判断数据库中是否存在某个ID的用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br><br>    Account <span class="hljs-title function_">findByIdAndUsername</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String username)</span>;<br><br>    List&lt;Account&gt; <span class="hljs-title function_">findAllByUsernameLike</span><span class="hljs-params">(String str)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">existsAccountById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(repository.existsAccountByUsername(<span class="hljs-string">&quot;Test&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>注意自定义条件操作的方法名称一定要遵循规则，不然会出现异常：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Caused by: org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.repository</span><span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.QueryCreationException</span>: Could not create query <span class="hljs-keyword">for</span> public abstract  ...<br></code></pre></td></tr></table></figure><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>在实际开发中，比较常见的场景还有关联查询，也就是我们会在表中添加一个外键字段，而此外键字段又指向了另一个表中的数据，当我们查询数据时，可能会需要将关联数据也一并获取，比如我们想要查询某个用户的详细信息，一般用户简略信息会单独存放一个表，而用户详细信息会单独存放在另一个表中。当然，除了用户详细信息之外，可能在某些电商平台还会有用户的购买记录、用户的购物车，交流社区中的用户帖子、用户评论等，这些都是需要根据用户信息进行关联查询的内容。</p><p><img src="https://img1.baidu.com/it/u=292198351,4011695440&fm=253&fmt=auto&app=138&f=JPEG?w=404&h=436" alt="img"></p><p>我们知道，在JPA中，每张表实际上就是一个实体类的映射，而表之间的关联关系，也可以看作对象之间的依赖关系，比如用户表中包含了用户详细信息的ID字段作为外键，那么实际上就是用户表实体中包括了用户详细信息实体对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users_detail&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountDetail</span> &#123;<br><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;address&quot;)</span><br>    String address;<br><br>    <span class="hljs-meta">@Column(name = &quot;email&quot;)</span><br>    String email;<br><br>    <span class="hljs-meta">@Column(name = &quot;phone&quot;)</span><br>    String phone;<br><br>    <span class="hljs-meta">@Column(name = &quot;real_name&quot;)</span><br>    String realName;<br>&#125;<br></code></pre></td></tr></table></figure><p>而用户信息和用户详细信息之间形成了一对一的关系，那么这时我们就可以直接在类中指定这种关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;username&quot;)</span><br>    String username;<br><br>    <span class="hljs-meta">@Column(name = &quot;password&quot;)</span><br>    String password;<br><br>    <span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span>   <span class="hljs-comment">//指定存储外键的字段名称</span><br>    <span class="hljs-meta">@OneToOne</span>    <span class="hljs-comment">//声明为一对一关系</span><br>    AccountDetail detail;<br>&#125;<br></code></pre></td></tr></table></figure><p>在修改实体类信息后，我们发现在启动时也进行了更新，日志如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">Hibernate: <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> users <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> detail_id <span class="hljs-type">integer</span><br>Hibernate: <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users_detail (id <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment, address <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), phone <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), real_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-keyword">primary</span> key (id)) engine<span class="hljs-operator">=</span>InnoDB<br>Hibernate: <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> users <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK7gb021edkxf3mdv5bs75ni6jd <span class="hljs-keyword">foreign</span> key (detail_id) <span class="hljs-keyword">references</span> users_detail (id)<br></code></pre></td></tr></table></figure><p>是不是感觉非常方便！都懒得去手动改表结构了。</p><p>接着我们往用户详细信息中添加一些数据，一会我们可以直接进行查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">pageAccount</span><span class="hljs-params">()</span> &#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>查询后，可以发现，得到如下结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Hibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_, accountdet1_.id as id1_1_1_, accountdet1_.address as address2_1_1_, accountdet1_.email as email3_1_1_, accountdet1_.phone as phone4_1_1_, accountdet1_.real_name as real_nam5_1_1_ <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>account0_ left outer join users_detail accountdet1_ on account0_.<span class="hljs-attribute">detail_id</span>=accountdet1_.id where account0_.<span class="hljs-attribute">id</span>=?<br>Account(<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">username</span>=Test, <span class="hljs-attribute">password</span>=123456, <span class="hljs-attribute">detail</span>=AccountDetail(id=1, <span class="hljs-attribute">address</span>=四川省成都市青羊区, <span class="hljs-attribute">email</span>=8371289@qq.com, <span class="hljs-attribute">phone</span>=1234567890, <span class="hljs-attribute">realName</span>=本伟))<br></code></pre></td></tr></table></figure><p>也就是，在建立关系之后，我们查询Account对象时，会自动将关联数据的结果也一并进行查询。</p><p>那要是我们只想要Account的数据，不想要用户详细信息数据怎么办呢？我希望在我要用的时候再获取详细信息，这样可以节省一些网络开销，我们可以设置懒加载，这样只有在需要时才会向数据库获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span><br><span class="hljs-meta">@OneToOne(fetch = FetchType.LAZY)</span>    <span class="hljs-comment">//将获取类型改为LAZY</span><br>AccountDetail detail;<br></code></pre></td></tr></table></figure><p>接着我们测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>   <span class="hljs-comment">//懒加载属性需要在事务环境下获取，因为repository方法调用完后Session会立即关闭</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">pageAccount</span><span class="hljs-params">()</span> &#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(account -&gt; &#123;<br>        System.out.println(account.getUsername());   <span class="hljs-comment">//获取用户名</span><br>        System.out.println(account.getDetail());  <span class="hljs-comment">//获取详细信息（懒加载）</span><br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看看控制台输出了什么：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Hibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_ <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>account0_ where account0_.<span class="hljs-attribute">id</span>=?<br>Test<br>Hibernate: select accountdet0_.id as id1_1_0_, accountdet0_.address as address2_1_0_, accountdet0_.email as email3_1_0_, accountdet0_.phone as phone4_1_0_, accountdet0_.real_name as real_nam5_1_0_ <span class="hljs-keyword">from</span> users_detail accountdet0_ where accountdet0_.<span class="hljs-attribute">id</span>=?<br>AccountDetail(<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">address</span>=四川省成都市青羊区, <span class="hljs-attribute">email</span>=8371289@qq.com, <span class="hljs-attribute">phone</span>=1234567890, <span class="hljs-attribute">realName</span>=卢本)<br></code></pre></td></tr></table></figure><p>可以看到，获取用户名之前，并没有去查询用户的详细信息，而是当我们获取详细信息时才进行查询并返回AccountDetail对象。</p><p>那么我们是否也可以在添加数据时，利用实体类之间的关联信息，一次性添加两张表的数据呢？可以，但是我们需要稍微修改一下级联关联操作设定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span><br><span class="hljs-meta">@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)</span> <span class="hljs-comment">//设置关联操作为ALL</span><br>AccountDetail detail;<br></code></pre></td></tr></table></figure><ul><li>ALL：所有操作都进行关联操作</li><li>PERSIST：插入操作时才进行关联操作</li><li>REMOVE：删除操作时才进行关联操作</li><li>MERGE：修改操作时才进行关联操作</li></ul><p>可以多个并存，接着我们来进行一下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">addAccount</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    account.setUsername(<span class="hljs-string">&quot;Nike&quot;</span>);<br>    account.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>    <span class="hljs-type">AccountDetail</span> <span class="hljs-variable">detail</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountDetail</span>();<br>    detail.setAddress(<span class="hljs-string">&quot;重庆市渝中区解放碑&quot;</span>);<br>    detail.setPhone(<span class="hljs-string">&quot;1234567890&quot;</span>);<br>    detail.setEmail(<span class="hljs-string">&quot;73281937@qq.com&quot;</span>);<br>    detail.setRealName(<span class="hljs-string">&quot;张三&quot;</span>);<br>  account.setDetail(detail);<br>    account = repository.save(account);<br>    System.out.println(<span class="hljs-string">&quot;插入时，自动生成的主键ID为：&quot;</span>+account.getId()+<span class="hljs-string">&quot;，外键ID为：&quot;</span>+account.getDetail().getId());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到日志结果：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">Hibernate:</span> insert into users_detail (address, email, phone, real_name) values (<span class="hljs-string">?,</span> <span class="hljs-string">?,</span> <span class="hljs-string">?,</span> <span class="hljs-string">?)</span><br><span class="hljs-symbol">Hibernate:</span> insert into users (detail_id, password, username) values (<span class="hljs-string">?,</span> <span class="hljs-string">?,</span> <span class="hljs-string">?)</span><br>插入时，自动生成的主键<span class="hljs-variable constant_">ID</span>为：<span class="hljs-number">6</span>，外键<span class="hljs-variable constant_">ID</span>为：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>结束后会发现数据库中两张表都同时存在数据。</p><p>接着我们来看一对多关联，比如每个用户的成绩信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;uid&quot;)</span>  <span class="hljs-comment">//注意这里的name指的是Score表中的uid字段对应的就是当前的主键，会将uid外键设置为当前的主键</span><br><span class="hljs-meta">@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)</span>   <span class="hljs-comment">//在移除Account时，一并移除所有的成绩信息，依然使用懒加载</span><br>List&lt;Score&gt; scoreList;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users_score&quot;)</span>   <span class="hljs-comment">//成绩表，注意只存成绩，不存学科信息，学科信息id做外键</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span> &#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@OneToOne</span>   <span class="hljs-comment">//一对一对应到学科上</span><br>    <span class="hljs-meta">@JoinColumn(name = &quot;cid&quot;)</span><br>    Subject subject;<br><br>    <span class="hljs-meta">@Column(name = &quot;socre&quot;)</span><br>    <span class="hljs-type">double</span> score;<br><br>    <span class="hljs-meta">@Column(name = &quot;uid&quot;)</span><br>    <span class="hljs-type">int</span> uid;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;subjects&quot;)</span>   <span class="hljs-comment">//学科信息表</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;cid&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> cid;<br><br>    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span><br>    String name;<br><br>    <span class="hljs-meta">@Column(name = &quot;teacher&quot;)</span><br>    String teacher;<br><br>    <span class="hljs-meta">@Column(name = &quot;time&quot;)</span><br>    <span class="hljs-type">int</span> time;<br>&#125;<br></code></pre></td></tr></table></figure><p>在数据库中填写相应数据，接着我们就可以查询用户的成绩信息了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(account -&gt; &#123;<br>        account.getScoreList().forEach(System.out::println);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>成功得到用户所有的成绩信息，包括得分和学科信息。</p><p>同样的，我们还可以将对应成绩中的教师信息单独分出一张表存储，并建立多对一的关系，因为多门课程可能由同一个老师教授（千万别搞晕了，一定要理清楚关联关系，同时也是考验你的基础扎不扎实）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ManyToOne(fetch = FetchType.LAZY)</span><br><span class="hljs-meta">@JoinColumn(name = &quot;tid&quot;)</span>   <span class="hljs-comment">//存储教师ID的字段，和一对一是一样的，也会当前表中创个外键</span><br>Teacher teacher;<br></code></pre></td></tr></table></figure><p>接着就是教师实体类了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;teachers&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span><br>    String name;<br><br>    <span class="hljs-meta">@Column(name = &quot;sex&quot;)</span><br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们再进行一下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    repository.findById(<span class="hljs-number">3</span>).ifPresent(account -&gt; &#123;<br>        account.getScoreList().forEach(score -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;课程名称：&quot;</span>+score.getSubject().getName());<br>            System.out.println(<span class="hljs-string">&quot;得分：&quot;</span>+score.getScore());<br>            System.out.println(<span class="hljs-string">&quot;任课教师：&quot;</span>+score.getSubject().getTeacher().getName());<br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>成功得到多对一的教师信息。</p><p>最后我们再来看最复杂的情况，现在我们一门课程可以由多个老师教授，而一个老师也可以教授多个课程，那么这种情况就是很明显的多对多场景，现在又该如何定义呢？我们可以像之前一样，插入一张中间表表示教授关系，这个表中专门存储哪个老师教哪个科目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ManyToMany(fetch = FetchType.LAZY)</span>   <span class="hljs-comment">//多对多场景</span><br><span class="hljs-meta">@JoinTable(name = &quot;teach_relation&quot;,     //多对多中间关联表</span><br><span class="hljs-meta">        joinColumns = @JoinColumn(name = &quot;cid&quot;),    //当前实体主键在关联表中的字段名称</span><br><span class="hljs-meta">        inverseJoinColumns = @JoinColumn(name = &quot;tid&quot;)   //教师实体主键在关联表中的字段名称</span><br><span class="hljs-meta">)</span><br>List&lt;Teacher&gt; teacher;<br></code></pre></td></tr></table></figure><p>接着，JPA会自动创建一张中间表，并自动设置外键，我们就可以将多对多关联信息编写在其中了。</p><h3 id="JPQL自定义SQL语句"><a href="#JPQL自定义SQL语句" class="headerlink" title="JPQL自定义SQL语句"></a>JPQL自定义SQL语句</h3><p>虽然SpringDataJPA能够简化大部分数据获取场景，但是难免会有一些特殊的场景，需要使用复杂查询才能够去完成，这时你又会发现，如果要实现，只能用回Mybatis了，因为我们需要自己手动编写SQL语句，过度依赖SpringDataJPA会使得SQL语句不可控。</p><p>使用JPA，我们也可以像Mybatis那样，直接编写SQL语句，不过它是JPQL语言，与原生SQL语句很类似，但是它是面向对象的，当然我们也可以编写原生SQL语句。</p><p>比如我们要更新用户表中指定ID用户的密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br><br>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-comment">//DML操作需要事务环境，可以不在这里声明，但是调用时一定要处于事务环境下</span><br>    <span class="hljs-meta">@Modifying</span>     <span class="hljs-comment">//表示这是一个DML操作</span><br>    <span class="hljs-meta">@Query(&quot;update Account set password = ?2 where id = ?1&quot;)</span> <span class="hljs-comment">//这里操作的是一个实体类对应的表，参数使用?代表，后面接第n个参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updatePasswordById</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String newPassword)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateAccount</span><span class="hljs-params">()</span>&#123;<br>    repository.updatePasswordById(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;654321&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我想使用原生SQL来实现根据用户名称修改密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Modifying</span><br><span class="hljs-meta">@Query(value = &quot;update users set password = :pwd where username = :name&quot;, nativeQuery = true)</span> <span class="hljs-comment">//使用原生SQL，和Mybatis一样，这里使用 :名称 表示参数，当然也可以继续用上面那种方式。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">updatePasswordByUsername</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String username,   //我们可以使用<span class="hljs-meta">@Param</span>指定名称</span><br><span class="hljs-params">                             <span class="hljs-meta">@Param(&quot;pwd&quot;)</span> String newPassword)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateAccount</span><span class="hljs-params">()</span>&#123;<br>    repository.updatePasswordByUsername(<span class="hljs-string">&quot;Admin&quot;</span>, <span class="hljs-string">&quot;654321&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过编写原生SQL，在一定程度上弥补了SQL不可控的问题。</p><p>虽然JPA能够为我们带来非常便捷的开发体验，但是正式因为太便捷了，保姆级的体验有时也会适得其反，可能项目开发到后期特别庞大时，就只能从底层SQL语句开始进行优化，而由于JPA尽可能地在屏蔽我们对SQL语句的编写，所以后期优化是个大问题，并且Hibernate相对于Mybatis来说，更加重量级。不过，在微服务的时代，单体项目一般不会太大，而JPA的劣势并没有太明显地体现出来。</p><p>有关Mybatis和JPA的对比，可以参考：<a href="https://blog.csdn.net/u010253246/article/details/105731204">https://blog.csdn.net/u010253246/article/details/105731204</a></p><hr><h2 id="Extra-前后端分离跨域处理"><a href="#Extra-前后端分离跨域处理" class="headerlink" title="Extra. 前后端分离跨域处理"></a>Extra. 前后端分离跨域处理</h2><p>我们的项目已经处于前后端分离状态了，那么前后端分离状态和我们之前的状态有什么区别的呢？</p><ul><li><strong>不分离：</strong>前端页面看到的都是由后端控制，由后端渲染页面或重定向，后端需要控制前端的展示，前端与后端的耦合度很高。比如我们之前都是使用后端来执行重定向操作或是使用Thymeleaf来填充数据，而最终返回的是整个渲染好的页。</li></ul><p><img src="https://img2018.cnblogs.com/blog/1394466/201809/1394466-20180916231510365-285933655.png" alt="img"></p><ul><li><strong>分离：</strong>后端仅返回前端所需的数据，不再渲染HTML页面，不再控制前端的效果。至于前端用户看到什么效果，从后端请求的数据如何加载到前端中，都由前端通过JS等进行动态数据填充和渲染。这样后端只返回JSON数据，前端处理JSON数据并展示，这样前后端的职责就非常明确了。</li></ul><p><img src="https://img2018.cnblogs.com/blog/1394466/201809/1394466-20180916231716242-1862208927.png" alt="img"></p><p>实现前后端分离有两种方案，一种是直接放入SpringBoot的资源文件夹下，但是这样实际上还是在依靠SpringBoot内嵌的Tomcat服务器进行页面和静态资源的发送，我们现在就是这种方案。</p><p>另一种方案就是直接将所有的页面和静态资源单独放到代理服务器上（如Nginx），这样我们后端服务器就不必再处理静态资源和页面了，专心返回数据即可，而前端页面就需要访问另一个服务器来获取，虽然逻辑和明确，但是这样会出现跨域问题，实际上就是我们之前所说的跨站请求伪造，为了防止这种不安全的行为发生，所以对异步请求会进行一定的限制。</p><p>这里，我们将前端页面和后端页面直接分离进行测试，在登陆时得到如下错误：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Access</span> <span class="hljs-keyword">to</span> XMLHttpRequest at <span class="hljs-string">&#x27;http://localhost:8080/api/auth/login&#x27;</span> <span class="hljs-keyword">from</span> origin <span class="hljs-string">&#x27;http://localhost:63342&#x27;</span> has been blocked <span class="hljs-keyword">by</span> CORS <span class="hljs-keyword">policy</span>: <span class="hljs-keyword">No</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-keyword">header</span> <span class="hljs-keyword">is</span> present <span class="hljs-keyword">on</span> the requested resource.<br></code></pre></td></tr></table></figure><p>可以很清楚地看到，在Ajax发送异步请求时，我们的请求被阻止，原因是在响应头中没有包含<code>Access-Control-Allow-Origin</code>，也就表示，如果服务端允许跨域请求，那么会在响应头中添加一个<code>Access-Control-Allow-Origin</code>字段，如果不允许跨域，就像现在这样。那么，什么才算是跨域呢：</p><ol><li>请求协议<code>如http、https</code>不同</li><li>请求的地址&#x2F;域名不同</li><li>端口不同</li></ol><p>因为我们现在相当于前端页面访问的是静态资源服务器，而后端数据是由我们的SpringBoot项目提供，它们是两个不同的服务器，所以在垮服务器请求资源时，会被判断为存在安全风险。</p><p>但是现在，由于我们前后端是分离状态，我们希望的是能够实现跨域请求，这时我们就需要添加一个过滤器来处理跨域问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//创建CorsConfiguration对象后添加配置</span><br>    <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>    <span class="hljs-comment">//设置放行哪些原始域，这里直接设置为所有</span><br>    config.addAllowedOriginPattern(<span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-comment">//你可以单独设置放行哪些原始域 config.addAllowedOrigin(&quot;http://localhost:2222&quot;);</span><br>    <span class="hljs-comment">//放行哪些原始请求头部信息</span><br>    config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-comment">//放行哪些请求方式，*代表所有</span><br>    config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-comment">//是否允许发送Cookie，必须要开启，因为我们的JSESSIONID需要在Cookie中携带</span><br>    config.setAllowCredentials(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//映射路径</span><br>    <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">corsConfigurationSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>    corsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, config);<br>    <span class="hljs-comment">//返回CorsFilter</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsFilter</span>(corsConfigurationSource);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们的SpringBoot项目就支持跨域访问了，接着我们再来尝试进行登陆，可以发现已经能够正常访问了，并且响应头中包含了以下信息：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Vary: Access-Control-Request-<span class="hljs-keyword">Method</span><br><span class="hljs-title function_">Vary</span>: Access-Control-Request-Headers<br>Access-Control-Allow-Origin: http:<span class="hljs-comment">//localhost:63342</span><br>Access-Control-Expose-Headers: *<br>Access-Control-Allow-Credentials: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>可以看到我们当前访问的原始域已经被放行了。</p><p>但是还有一个问题，我们的Ajax请求中没有携带Cookie信息（这个按理说属于前端知识了）这里我们稍微改一下，不然我们的请求无法确认身份：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url, success</span>)&#123;<br>    $.<span class="hljs-title function_">ajax</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;get&quot;</span>,<br>        <span class="hljs-attr">url</span>: url,<br>        <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>        <span class="hljs-attr">xhrFields</span>: &#123;<br>            <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>        &#125;,<br>        <span class="hljs-attr">success</span>: success<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">url, data, success</span>)&#123;<br>    $.<span class="hljs-title function_">ajax</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;post&quot;</span>,<br>        <span class="hljs-attr">url</span>: url,<br>        <span class="hljs-attr">async</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">data</span>: data,<br>        <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>        <span class="hljs-attr">xhrFields</span>: &#123;<br>            <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>        &#125;,<br>        <span class="hljs-attr">success</span>: success<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>添加两个封装好的方法，并且将<code>withCredentials</code>开启，这样在发送异步请求时，就会携带Cookie信息了。</p><p> 在学习完成Linux之后，我们会讲解如何在Linux服务器上部署Nginx反向代理服务器。</p><hr><h2 id="接口管理：Swagger"><a href="#接口管理：Swagger" class="headerlink" title="接口管理：Swagger"></a>接口管理：Swagger</h2><p>在前后端分离项目中，前端人员需要知道我们后端会提供什么数据，根据后端提供的数据来进行前端页面渲染（在之前我们也演示过）这个时候，我们就需要编写一个API文档，以便前端人员随时查阅。</p><p>但是这样的一个文档，我们也不可能单独写一个项目去进行维护，并且随着我们的后端项目不断更新，文档也需要跟随更新，这显然是很麻烦的一件事情，那么有没有一种比较好的解决方案呢？</p><p>当然有，那就是丝袜哥：Swagger</p><h3 id="走进Swagger"><a href="#走进Swagger" class="headerlink" title="走进Swagger"></a>走进Swagger</h3><p>Swagger的主要功能如下：</p><ul><li>支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。</li><li>提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。</li></ul><p>结合Spring框架（Spring-fox），Swagger可以很轻松地利用注解以及扫描机制，来快速生成在线文档，以实现当我们项目启动之后，前端开发人员就可以打开Swagger提供的前端页面，查看和测试接口。依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SpringBoot 2.6以上版本修改了路径匹配规则，但是Swagger3还不支持，这里换回之前的，不然启动直接报错：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">mvc:</span><br><span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ant_path_matcher</span><br></code></pre></td></tr></table></figure><p>项目启动后，我们可以直接打开：<a href="http://localhost:8080/swagger-ui/index.html%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%88%E8%A6%81%E6%98%AF%E8%A7%89%E5%BE%97%E4%B8%91%EF%BC%8CUI%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%8D%A2%E7%9A%84%EF%BC%8C%E6%94%AF%E6%8C%81%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%89%E4%BC%9A%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E7%9A%84API%E6%96%87%E6%A1%A3%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%81%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AD%89%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%AF%B9API%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%96%B9%E4%BE%BF%E3%80%82">http://localhost:8080/swagger-ui/index.html，这个页面（要是觉得丑，UI是可以换的，支持第三方）会显示所有的API文档，包括接口的路径、支持的方法、接口的描述等，并且我们可以直接对API接口进行测试，非常方便。</a></p><p>我们可以创建一个配置类去配置页面的相关信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.OAS_30).apiInfo(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                        .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;你的名字&quot;</span>, <span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>, <span class="hljs-string">&quot;javastudy111*@163.com&quot;</span>))<br>                        .title(<span class="hljs-string">&quot;图书管理系统 - 在线API接口文档&quot;</span>)<br>                        .build()<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口信息配置"><a href="#接口信息配置" class="headerlink" title="接口信息配置"></a>接口信息配置</h3><p>虽然Swagger的UI界面已经可以很好地展示后端提供的接口信息了，但是非常的混乱，我们来看看如何配置接口的一些描述信息。</p><p>首先我们的页面中完全不需要显示ErrorController相关的API，所以我们配置一下选择哪些Controller才会生成API信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">docket</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ApiInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>            .contact(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contact</span>(<span class="hljs-string">&quot;你的名字&quot;</span>, <span class="hljs-string">&quot;https://www.bilibili.com&quot;</span>, <span class="hljs-string">&quot;javastudy111@163.com&quot;</span>))<br>            .title(<span class="hljs-string">&quot;图书管理系统 - 在线API接口文档&quot;</span>)<br>            .description(<span class="hljs-string">&quot;这是一个图书管理系统的后端API文档，欢迎前端人员查阅！&quot;</span>)<br>            .build();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.OAS_30)<br>            .apiInfo(info)<br>            .select()       <span class="hljs-comment">//对项目中的所有API接口进行选择</span><br>            .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.example.controller&quot;</span>))<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看看如何为一个Controller编写API描述信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;账户验证接口&quot;, description = &quot;包括用户登录、注册、验证码请求等操作。&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/auth&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthApiController</span> &#123;<br></code></pre></td></tr></table></figure><p>我们可以直接在类名称上面添加<code>@Api</code>注解，并填写相关信息，来为当前的Controller设置描述信息。</p><p>接着我们可以为所有的请求映射配置描述信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiResponses(&#123;</span><br><span class="hljs-meta">        @ApiResponse(code = 200, message = &quot;邮件发送成功&quot;),  </span><br><span class="hljs-meta">        @ApiResponse(code = 500, message = &quot;邮件发送失败&quot;)   //不同返回状态码描述</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@ApiOperation(&quot;请求邮件验证码&quot;)</span>   <span class="hljs-comment">//接口描述</span><br><span class="hljs-meta">@GetMapping(&quot;/verify-code&quot;)</span><br><span class="hljs-keyword">public</span> RestBean&lt;Void&gt; <span class="hljs-title function_">verifyCode</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;邮箱地址&quot;)</span>   //请求参数的描述</span><br><span class="hljs-params">                                 <span class="hljs-meta">@RequestParam(&quot;email&quot;)</span> String email)</span>&#123;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiIgnore</span>     <span class="hljs-comment">//忽略此请求映射</span><br><span class="hljs-meta">@PostMapping(&quot;/login-success&quot;)</span><br><span class="hljs-keyword">public</span> RestBean&lt;Void&gt; <span class="hljs-title function_">loginSuccess</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestBean</span>&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;登陆成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以为实体类配置相关的描述信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ApiModel(description = &quot;响应实体封装类&quot;)</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestBean</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;状态码&quot;)</span><br>    <span class="hljs-type">int</span> code;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;状态码描述&quot;)</span><br>    String reason;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;数据实体&quot;)</span><br>    T data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RestBean</span><span class="hljs-params">(<span class="hljs-type">int</span> code, String reason)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.reason = reason;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就可以在文档中查看实体类简介以及各个属性的介绍了。</p><p>最后我们再配置一下多环境：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;environment&#125;.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先在Maven中添加两个环境，接着我们配置一下不同环境的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml">  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">hibernate:</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><br><span class="hljs-attr">springfox:</span><br>  <span class="hljs-attr">documentation:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>在生产环境下，我们选择不开启Swagger文档以及JPA的数据库操作日志，这样我们就可以根据情况选择两套环境了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作系统与项目部署</title>
    <link href="/2022/10/02/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/10/02/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20171116%2F4f98ec55839b434cba335319b5ebf963.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645350734&t=099b0e4fb640617498cc40939e7e2070" alt="点击查看图片来源"></p><h1 id="Linux操作系统与项目部署"><a href="#Linux操作系统与项目部署" class="headerlink" title="Linux操作系统与项目部署"></a>Linux操作系统与项目部署</h1><p><strong>注意：</strong>本版块会涉及到<code>操作系统</code>相关知识。</p><p>现在，几乎所有智能设备都有一个自己的操作系统，比如我们的家用个人电脑，基本都是预装Windows操作系统，我们的手机也有Android和iOS操作系统，还有程序员比较青睐的MacBook，预装MacOS操作系统，甚至连Macbook的Touchbar都有一个自己的小型操作系统。</p><blockquote><p>操作系统是管理计算机硬件与软件资源的计算机程序，操作系统可以对计算机系统的各项资源板块开展调度工作，运用计算机操作系统可以减少人工资源分配的工作强度。</p></blockquote><p>在我们的电脑没有操作系统的情况下，它就是一堆电子元器件组合而成的机器，就像我们有了一具完整的身体，但是现在缺少的是一个大脑，来控制我们的身体做出各种动作和行为，而安装了操作系统，就像为电脑注入了灵魂，操作系统会帮助我们对所有的硬件进行调度和管理。</p><p>比如我们现在最常用的Windows操作系统，我们可以在系统中做各种各样的事情，包括游戏、看片、学习、编程等，而所有的程序正是基于操作系统之上运行的，操作系统帮助我们与底层硬件进行交互，而在程序中我们只需要告诉操作系统我们需要做什么就可以了，操作系统知道该如何使用和调度底层的硬件，来完成我们程序中指定的任务。</p><p>（如果你在自己电脑上安装过Windows操作系统，甚至自己打过驱动程序，或是使用安装过Linux任意发行版本，那么本章学习起来会比较轻松）</p><h2 id="发展简史"><a href="#发展简史" class="headerlink" title="发展简史"></a>发展简史</h2><p>这是整个SpringBoot阶段的最后部分了，为了不让学习那么枯燥，我们先来讲点小故事。</p><p>在1965年，当时还处于批处理操作系统的时代，但是它只能同时供一个用户使用，而当时人们正希望能够开发一种交互式的、具有多道程序处理能力的分时操作系统。于是，贝尔实验室、美国麻省理工学院和通用电气公司联合发起了一项名为 Multics 的工程计划，而目的也是希望能够开发出这样的一个操作系统，但是最终由于各种原因以失败告终。</p><p>以肯•汤普森为首的贝尔实验室研究人员吸取了 Multics 工程计划失败的经验教训，于 1969 年实现了分时操作系统的雏形，在1970 年该操作系统正式取名为<strong>UNIX</strong>，它是一个强大的多用户、多任务操作系统，支持多种处理器架构，1973 年，也就是C语言问世不久后，UNIX操作系统的绝大部分源代码都用C语言进行了重写。</p><p>从这之后，大量的UNIX发行版本涌现（基于Unix进行完善的系统）比如 FreeBSD 就是美国加利福尼亚大学伯克利分校开发的 UNIX 版本，它由来自世界各地的志愿者开发和维护，为不同架构的计算机系统提供了不同程度的支持。</p><p> 而后来1984年苹果公司发布的的MacOS（在Macintosh电脑上搭载）操作系统，正是在 FreeBSD 基础之上开发的全新操作系统，这是首次计算机正式跨进图形化时代，具有里程碑的意义。</p><p><img src="https://www.webdesignerdepot.com/cdn-origin/uploads/2009/03/mac-os-1.gif" alt="Mac OS"></p><p>同年，乔布斯非常高兴地将自家的图形化MacOS界面展示给微软创始人比尔盖茨，并且希望微软可以为MacOS开发一些软件。比尔盖茨一看，woc，这玩意牛逼啊，咱们自己也给安排一个。于是，在1985年，微软仿造MacOS并基于MS-DOS操作系统，开发出了名为Windows的操作系统：</p><p><img src="https://pics5.baidu.com/feed/b7003af33a87e950dd561c8ef220e945faf2b4ab.jpeg?token=b2063459ad19e976ed42754e5f9caea8" alt="img"></p><p>Windows操作系统的问世，无疑是对MacOS的一次打击，因为MacOS只能搭载在Mac上，但是售价实在太贵，并且软件生态也不尽人意，同时代的Windows却能够安装到各种各样的DIY电脑上，称其为PC，尤其是后来的Windows95，几乎是封神的存在，各种各样基于Windows的软件、游戏层出不穷，以至于到今天为止，MacOS的市场占有率依然远低于Windows，不过Apple这十几年一直在注重自家软件生态的发展，总体来说在办公领域体验感其实和Windows差不多，甚至可能还更好，但是打游戏，别想了。</p><p>说了这么多，Linux呢，怎么一句都没提它呢？最牛逼的当然放最后说（不是</p><p>Unix虽然强大但是有着昂贵的授权费用，并且不开放源代码，于是有人发起了GNU运动（GNU IS NOT UNIX，带有那么一丝嘲讽），模仿 Unix 的界面和使用方式，从头做一个开源的版本。在1987年荷兰有个大学教授安德鲁写了一个Minix，类似于Unix，专用于教学。当Minix流传开来之后，世界各地的黑客们纷纷开始使用并改进，希望把改进的东西合并到Minix中，但是安德鲁觉得他的系统是用于教学的，不能破坏纯净性，于是拒绝了。</p><p>在1991年，林纳斯.托瓦兹（Linus Torvalds）认为Minix不够开放，自己又写了一个全新的开源操作系统，它希望这个系统由全世界的爱好者一同参与开发，并且不收费，于是Linux内核就被公开发布到互联网上。一经发布，便引起了社会强烈的反响，在大家的努力下，于1994年Linux的1.0版本正式发布。结合当时的GNU运动，最终合在一起称为了GNU&#x2F;Linux，以一只企鹅Tux作为吉祥物。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%3A%2F%2Fdingyue.ws.126.net%2F2021%2F0914%2F1833179ap00qzeyx5000cc000go009qg.png%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&refer=http%3A%2F%2Fnimg.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645451358&t=082f4539e97a1a3c9dc8002847e9ad5a" alt="点击查看图片来源"></p><p>没错，Git也是林纳斯.托瓦兹只花了2周时间开发的。不过林纳斯非常讨厌C++，他认为C++只会让一个项目变得混乱。</p><p>从此以后，各式各样的基于Linux发行版就开始出现：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fqnam.smzdm.com%2F202002%2F08%2F5e3e59003360f5288.jpg_e680.jpg&refer=http%3A%2F%2Fqnam.smzdm.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645451543&t=f2471b52851d92920194d2ef2acbab6f" alt="点击查看图片来源"></p><p>这些发行版都是在Linux内核的基础之上，添加了大量的额外功能，包括开发环境、图形化桌面、包管理等。包括我们的安卓系统，也是基于Linux之上的，而我们要重点介绍的就是基于Debian之上的Ubuntu操作系统。</p><p>最后，2022年了，我们再来看一下各大操作系统的市场占有率：</p><ul><li>Windows11&#x2F;10&#x2F;7：80%</li><li>MacOS：11%</li><li>Linux：5%</li><li>其他：4%</li></ul><p>Windows无疑是现在最广泛的操作系统，尤其是Windows XP，是多少00后的青春，很多游戏都是基于Windows平台。当然，如果你已经厌倦了游戏，一心只读圣贤书的话，那么还是建议直接使用任意Linux桌面版或是Mac，因为它们能够为你提供极致和纯粹的开发体验（貌似之前华为也出过Linux笔记本？）</p><hr><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.iasptk.com%2Fwp-content%2Fuploads%2Fsites%2F12%2F2017%2F03%2FUbuntu-02804350.jpg&refer=http%3A%2F%2Fwww.iasptk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645453389&t=d7908bc10978585c9ce374cc8013ff64" alt="点击查看图片来源"></p><h2 id="安装Ubuntu系统"><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h2><p>这里我们就以安装虚拟机的方式在我们的电脑上安装Linux操作系统，我们选用Ubuntu作为教程，如果有经济实力，可以在腾讯云、阿里云之类的服务商购买一台云服务器，并选择预装Ubuntu系统；如果你还想搞嵌入式开发之类的工作，可以购买一台树莓派服务器，也可以在上面安装Ubuntu系统，相当于一台迷你主机。在你已经有云服务器的情况下，可以直接跳过虚拟机安装教学。</p><p>官网下载：<a href="https://cn.ubuntu.com/download/server/step1">https://cn.ubuntu.com/download/server/step1</a></p><p>注意是下载服务器版本，不是桌面版本。</p><h3 id="在虚拟机中安装"><a href="#在虚拟机中安装" class="headerlink" title="在虚拟机中安装"></a>在虚拟机中安装</h3><p>这里我们使用VMware进行安装，VMware是一个虚拟化应用程序，它可以在我们当前运行的操作系统之上，创建一个虚线的主机，相当于创建了一台电脑，而我们就可以在这台电脑上安装各种各样的操作系统，并且我们可以自由为其分配CPU核心和内存以及硬盘容量（如果你接触过云计算相关内容，应该会对虚拟化技术有所了解）</p><p>官网下载：<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a></p><p>安装完成后，会出现一个类似于CMD的命令窗口，而我们就是通过输入命令来操作我们的操作系统。</p><h3 id="使用SSH远程连接"><a href="#使用SSH远程连接" class="headerlink" title="使用SSH远程连接"></a>使用SSH远程连接</h3><p>如果你使用的是树莓派或是云服务器，那么你会得到一个公网的IP地址，以及默认的用户名和密码，由于服务器安装的Ubuntu并不是在我们的电脑上运行的，那么我们怎么去远程操作呢？</p><p>比如我们要远程操作一台Windows电脑，直接使用远程桌面连接即可，但是Ubuntu上来就是命令行，这种情况下要实现远程连接就只能使用SSH终端。</p><p>SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</p><p>云服务器上安装的Ubuntu默认都是自带了OpenSSH服务端的，我们可以直接连接，如果你的Ubuntu服务器上没有安装OpenSSH服务器端，那么可以输入命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install openssh-server<br><span class="hljs-meta prompt_">#</span><span class="language-bash">输入后还需要你输入当前用户的密码才可以执行，至于为什么我们后面会说</span><br></code></pre></td></tr></table></figure><p>这里我们使用XShell来进行SSH登陆，官网：<a href="https://www.netsarang.com/zh/free-for-home-school/">https://www.netsarang.com/zh/free-for-home-school/</a></p><h3 id="文件系统介绍"><a href="#文件系统介绍" class="headerlink" title="文件系统介绍"></a>文件系统介绍</h3><p>在Windows下，我们的整个硬盘实际上可以被分为多个磁盘驱动器：</p><p><img src="https://img-blog.csdnimg.cn/20190415191752939.png" alt="在这里插入图片描述"></p><p>我们一般习惯将软件装到D盘，文件数据存在E盘，系统和一些环境安装在C盘，根据不同的盘符进行划分，并且每个盘都有各自的存储容量大小。而在Linux中，没有这个概念，所有的文件都是位于根目录下的：</p><p><img src="https://upload-images.jianshu.io/upload_images/17163728-8d41eb59e5cfb7ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/904" alt="img"></p><p>我们可以看到根目录下有很多个文件夹，它们都有着各自的划分：</p><ul><li>&#x2F;bin 可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等实际上都是一些小的应用程序</li><li>&#x2F;home 普通用户的主目录，对应Windows下的C:&#x2F;Users&#x2F;用户名&#x2F;</li><li>&#x2F;root root用户的主目录（root用户是具有最高权限的用户，之后会讲）</li><li>&#x2F;boot 内核文件的引导目录, 放置 linux 系统启动时用到的一些文件</li><li>&#x2F;sbing 超级用户使用的指令文件</li><li>&#x2F;tmp 临时文件目录，一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</li><li>&#x2F;dev 设备文件目录，在Linux中万物皆文件，实际上你插入的U盘等设备都会在dev目录下生成一个文件，我们可以很方便地通过文件IO方式去操作外设，对嵌入式开发极为友好。</li><li>&#x2F;lib 共享库，系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。</li><li>&#x2F;usr 第三方 程序目录</li><li>&#x2F;etc 配置程序目录，系统配置文件存放的目录</li><li>&#x2F;var 可变文件，放置系统执行过程中经常变化的文件</li><li>&#x2F;opt 用户使用目录，给主机额外安装软件所摆放的目录。</li></ul><p>我们可以直接输入命令来查看目录下的所有文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">只显示文件名称，且不显示隐藏文件</span><br>ls<br><span class="hljs-meta prompt_">#</span><span class="language-bash">显示隐藏文件以及文件详细信息</span><br>ll<br></code></pre></td></tr></table></figure><p>那么我们如何才能像Windows那样方便的管理Linux中的文件呢？我们可以使用FTP管理工具，默认情况下Ubuntu是安装了SFTP服务器的。</p><p>这里我们使用Xftp来进行管理，官网：<a href="https://www.netsarang.com/zh/free-for-home-school/">https://www.netsarang.com/zh/free-for-home-school/</a></p><hr><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><p>我们整个Linux阶段的学习主要是以实操为主，大量的命令需要大量的使用才能记得更牢固。</p><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统的用户，都必须申请一个账号，然后以这个账号的身份进入系统。比如我们之前就是使用我们在创建服务器时申请的初始用户test，通过输入用户名和密码登录到系统中，之后才能使用各种命令进行操作。其实用户机制和我们的Windows比较类似。一般的普通用户只能做一些比较基本的操作，并且只能在自己的目录（如&#x2F;home&#x2F;test）中进行文件的创建和删除操作。</p><p>我们可以看到，当前状态信息分为三段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test@ubuntu-server:~$<br></code></pre></td></tr></table></figure><p>格式为：用户名@服务器名称:当前所处的目录$，其中~代表用户目录，如果不是用户目录，会显示当前的绝对路径地址。我们也可以使用<code>pwd</code>命令来直接查看当前所处的目录。</p><p>在Linux中默认存在一个超级用户root，而此用户拥有最高执行权限，它能够修改任何的内容，甚至可以删除整个Linux内核，正常情况下不会使用root用户进行登陆，只有在特殊情况下才会使用root用户来进行一些操作，root用户非常危险，哪怕一个小小的命令都能够毁掉整个Linux系统，比如<code>rm -rf /*</code>，感兴趣的话我们可以放在最后来演示（在以前老是听说安卓手机root，实际上就是获取安卓系统底层Linux系统的root权限，以实现修改系统文件的目的）</p><p>我们可以使用<code>sudo -s</code>并输入当前用户的密码切换到root用户，可以看到出现了一些变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">test@ubuntu-server:~$<br><br>root@ubuntu-server:/home/test#<br></code></pre></td></tr></table></figure><p>我们发现<code>$</code>符号变成了<code>#</code>符号，注意此符号表示当前的用户权限等级，并且test也变为了root，在此用户下，我们可以随意修改test用户文件夹以外的内容，而test用户下则无法修改。如果需要退出root用户，直接输入<code>exit</code>即可。</p><p>接着我们来看一下，如何进行用户的管理操作，进行用户管理，包括添加用户和删除用户都需要root权限才可以执行，但是现在我们是test用户，我们可以在命令前面添加<code>sudo</code>来暂时以管理员身份执行此命令，比如说我们现在想要添加一个新的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo useradd study<br></code></pre></td></tr></table></figure><p>其中<code>study</code>就是我们想要创建的新用户，<code>useradd</code>命令就是创建新用户的命令，同样的，删除用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo userdel study<br></code></pre></td></tr></table></figure><p>Linux中的命令一般都可以携带一些参数来以更多特地的方式执行，我们可以在创建用户时，添加一些额外的参数来进行更多高级操作：</p><ul><li>-d&lt;登录目录&gt; 　指定用户登录时的起始目录。</li><li>-g&lt;群组&gt; 　指定用户所属的群组。</li><li>-G&lt;群组&gt; 　指定用户所属的附加群组。</li><li>-m 　自动建立用户的登入目录。</li><li>-M 　不要自动建立用户的登入目录。</li><li>-s  指定Shell，一般指定为&#x2F;bin&#x2F;bash</li></ul><p>如果还想查看更多命令，可以直接使用<code>man</code>来查看命令的详细参数列表，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">man useradd<br></code></pre></td></tr></table></figure><p>比如我们现在需要在用户创建时顺便创建用户的文件夹，并指定shell（任意一种命令解释程序，用于处理我们输入的命令）为bash：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo useradd study -m -s /bin/bash<br></code></pre></td></tr></table></figure><p>可以看到已经自动在home目录下创建了study文件夹（这里..表示上一级目录，.表示当前目录）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">test@ubuntu-server:~$ ls ..<br>study  test<br></code></pre></td></tr></table></figure><p>用户创建完成之后，我们可以为此用户设定密码（如果不指定用户，那么会设置当前用户的密码）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo passwd study<br></code></pre></td></tr></table></figure><p>输入密码之后，我们可以使用命令来切换用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">test@ubuntu-server:~$ su - study<br>Password: <br>study@ubuntu-server:~$ <br></code></pre></td></tr></table></figure><p>可以看到，切换用户后名称已经修改为study了，我们使用<code>exit</code>即可退出当前用户回到test。</p><p>输入<code>who</code>可以查看当前登录账号（注意是登录的账号）输入<code>whoami</code>可以查看当前的操作账号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">test@ubuntu-server:~$ su study<br>Password: <br>study@ubuntu-server:/home/test$ cd ~<br>study@ubuntu-server:~$ who<br>test     pts/0        2022-01-24 03:57 (192.168.10.3)<br>study@ubuntu-server:~$ whoami<br>study<br>study@ubuntu-server:~$ <br></code></pre></td></tr></table></figure><p>接着我们来看用户组，每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。我们可以输入<code>groups</code>来查看当前用户所有的用户组：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">groups</span><br><span class="hljs-built_in">test</span> adm cdrom sudo dip plugdev lxd<br></code></pre></td></tr></table></figure><p>我们可以输入<code>id</code>来查看用户所属的用户相关信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">id</span><br>uid=1000(<span class="hljs-built_in">test</span>) gid=1000(<span class="hljs-built_in">test</span>) <span class="hljs-built_in">groups</span>=1000(<span class="hljs-built_in">test</span>),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)<br></code></pre></td></tr></table></figure><p>我们可以看到test用户默认情况下主要用户组为同名的test用户组，并且还属于一些其他的用户组，其中sudo用户组就表示可以执行<code>sudo</code>命令，我们发现我们创建的study用户没有sudo的执行权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">study@ubuntu-server:~$ sudo -s<br>[sudo] password <span class="hljs-keyword">for</span> study: <br>study is not <span class="hljs-keyword">in</span> the sudoers file.  This incident will be reported.<br></code></pre></td></tr></table></figure><p>正是因为没有加入到sudo用户组，这里我们来尝试将其添加到sudo用户组：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">id</span> study<br>uid=1001(study) gid=1001(study) <span class="hljs-built_in">groups</span>=1001(study)<br></code></pre></td></tr></table></figure><p>使用<code>usermod</code>命令来对用户的相关设置进行修改，参数与useradd大致相同：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo usermod study -G sudo<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">id</span> study<br>uid=1001(study) gid=1001(study) <span class="hljs-built_in">groups</span>=1001(study),27(sudo)<br></code></pre></td></tr></table></figure><p>接着切换到study用户就可以使用sudo命令了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">To run a <span class="hljs-built_in">command</span> as administrator (user <span class="hljs-string">&quot;root&quot;</span>), use <span class="hljs-string">&quot;sudo &lt;command&gt;&quot;</span>.<br>See <span class="hljs-string">&quot;man sudo_root&quot;</span> <span class="hljs-keyword">for</span> details.<br><br>study@ubuntu-server:/home/test$ sudo -s<br>[sudo] password <span class="hljs-keyword">for</span> study: <br>root@ubuntu-server:/home/test<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p>实际上，我们的用户信息是存储在配置文件中的，我们之前说了，配置文件一般都放在etc目录下，而用户和用户组相关的配置文件，存放在<code>/etc/passwd</code>和<code>/etc/group</code>中，我们可以使用cat命令将文件内容打印到控制台：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cat</span> /etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin<br>bin:x:2:2:bin:/bin:/usr/sbin/nologin<br>sys:x:3:3:sys:/dev:/usr/sbin/nologin<br><span class="hljs-built_in">sync</span>:x:4:65534:<span class="hljs-built_in">sync</span>:/bin:/bin/sync<br></code></pre></td></tr></table></figure><p>格式为：<code>注册名:口令:用户标识号:组标识号:用户名:用户主目录:命令解释程序 </code>，而我们的密码则存放在<code>/etc/shadow</code>中，是以加密形式存储的，并且需要root权限才能查看。</p><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>接着我们来看一下Linux系统中一些比较常用的命令。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件是最基本的内容，我们可以使用ls命令列出当前目录中所有的文件，参数-a表示包含所有的隐藏文件，-l表示列出详细信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span> -al<br>total 44<br>drwxr-xr-x 4 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 24 08:55 .<br>drwxr-xr-x 4 root root 4096 Jan 24 04:24 ..<br>-rw------- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 2124 Jan 24 04:29 .bash_history<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>  220 Feb 25  2020 .bash_logout<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 3771 Feb 25  2020 .bashrc<br>drwx------ 2 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 21 15:48 .cache<br>drwx------ 3 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 23 14:49 .config<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>  807 Feb 25  2020 .profile<br>-rw------- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>   34 Jan 24 04:17 .python_history<br>-rw-r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>    0 Jan 21 15:52 .sudo_as_admin_successful<br>-rw------- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 7201 Jan 24 08:55 .viminfo<br></code></pre></td></tr></table></figure><p>可以看到当前目录下的整个文件列表，那么这些信息各种代表什么意思呢，尤其是最前面那一栏类似于<code>drwxr-xr-x</code>的字符串。</p><p>它表示文件的属性，其中第1个字符表示此文件的类型：<code>-</code>表示普通文件，<code>l</code>为链接文件，<code>d</code>表示目录（文件夹），<code>c</code>表示字符设备、<code>b</code>表示块设备，还有<code>p</code>有名管道、<code>f</code>堆栈文件、<code>s</code>套接字等，这些一般都是用于进程之间通信使用的。</p><p>第2-4个字符表示文件的拥有者（User）对该文件的权限，第5-7个字符表示文件所属用户组（Group）内用户对该文件的权限，最后8-10个字符表示其他用户（Other）对该文件的权限。其中<code>r</code>为读权限、<code>w</code>为写权限、<code>x</code>为执行权限，为了方便记忆，直接记UGO就行了。</p><p>比如<code>drwxr-xr-x</code>就表示这是一个目录，文件的拥有者可以在目录中读、写和执行，而同一用户组的其他用户只能读和执行，其他用户也是一样。</p><p>第二栏数据可以看到是一列数字，它表示文件创建的链接文件（快捷方式）数量，一般只有1表示只有当前文件，我们也可以尝试创建一个链接文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ln</span> .bash_logout kk<br></code></pre></td></tr></table></figure><p>创建后，会生成一个名为kk的文件，我们对此文件的操作相当于直接操作.bash_logout，跟Windows中的快捷方式比较类似，了解一下即可。再次执行<code>ll</code>命令，可以看到.bash_logout的链接数变成了2。</p><p>第三栏数据为该文件或是目录的拥有者。</p><p>第四栏数据表示所属的组。</p><p>第五栏数据表示文件大小，以字节为单位。</p><p>第六栏数据为文件的最后一次修改时间</p><p>最后一栏就是文件名称了，就不多说了，再次提及..表示上级目录，.表示当前目录，最前面有一个.开头的文件为隐藏文件。可以看到上级目录（也就是&#x2F;home目录）所有者为root，并且非root用户无法进行写操作，只能执行读操作，而当前目录以及目录下所有文件则属于test用户，test用户可以随意进行修改。</p><p>在了解了Linux的文件查看之后再去看Windows的文件管理，会觉得Windows的太拉了：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg0.pconline.com.cn%2Fpconline%2F2107%2F02%2F14306786_05_thumb.jpg&refer=http%3A%2F%2Fimg0.pconline.com.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645608268&t=75ea125c46cb38b22268156794b986d4" alt="img"></p><p>那么，如果我们希望对文件的属性进行修改，比如我们现在希望将某个文件的写权限给关闭，可以使用<code>chmod</code>命令来进行文件属性修改，我们先创建一个test文件，使用<code>touch</code>命令来创建文件，使用<code>mkdir</code>命令来创建目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">test@ubuntu-server:~$ touch test<br>test@ubuntu-server:~$ ll test<br>-rw-rw-r-- 1 test test 0 Jan 24 09:32 test<br></code></pre></td></tr></table></figure><p>可以看到文件创建之后的默认权限为可读可写，接着我们来将其修改为只读，chmod的使用方法如下：</p><ul><li>chmod (u&#x2F;g&#x2F;o&#x2F;a)(+&#x2F;-)(r&#x2F;w&#x2F;x) 文件名称</li></ul><p>我们可以从ugo中选择或是直接a表示所有，+和-表示添加和删除权限，最后rwx不用我说了吧</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">chmod</span> a-w <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ll <span class="hljs-built_in">test</span><br>-r--r--r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 0 Jan 24 09:32 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>除了这种方式之外，我们也可以使用数字来代替，比如现在我要给前两个添加读权限，那么：</p><p>约定：r&#x3D;4，w&#x3D;2，x&#x3D;1，需要什么权限就让对应权限的数字相加，一个数字表示一个rwx的权限状态，比如我们想修改为<code>-rw-rw-r--</code>，那么对应的数字就是<code>664</code>，对应的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">chmod</span> 664 <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ll <span class="hljs-built_in">test</span><br>-rw-rw-r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 0 Jan 24 09:32 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>如果我们想修改文件的拥有者或是所属组，可以使用<code>chown</code>和<code>chgrp</code>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo <span class="hljs-built_in">chown</span> root <span class="hljs-built_in">test</span> <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span> -l<br>total 0<br>-rw-rw-r-- 1 root <span class="hljs-built_in">test</span> 0 Jan 24 10:43 <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo <span class="hljs-built_in">chgrp</span> root <span class="hljs-built_in">test</span> <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span> -l<br>total 0<br>-rw-rw-r-- 1 root root 0 Jan 24 10:43 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>再次操作该文件，会发现没权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">chmod</span> 777 <span class="hljs-built_in">test</span> <br><span class="hljs-built_in">chmod</span>: changing permissions of <span class="hljs-string">&#x27;test&#x27;</span>: Operation not permitted<br></code></pre></td></tr></table></figure><p>接着我们来看文件的复制、移动和删除，这里我们先创建一个新的目录并进入到此目录用于操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">mkdir</span> study<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> study<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study$<br></code></pre></td></tr></table></figure><p>首先我们演示文件的复制操作，文件的复制使用<code>cp</code>命令，比如现在我们想把上一级目录中的test文件复制到当前目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~/study$ <span class="hljs-built_in">cp</span> ../test <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~/study$ <span class="hljs-built_in">ls</span><br><span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>那么如果我们想要将一整个目录进行复制呢？我们需要添加一个<code>-r</code>参数表示将目录中的文件递归复制：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~/study$ <span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cp</span> -r study study_copied<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span> -l<br>total 8<br>drwxrwxr-x 2 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 24 10:16 study<br>drwxrwxr-x 2 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 4096 Jan 24 10:20 study_copied<br>-rw-rw-r-- 1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>    0 Jan 24 09:32 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>可以看到我们的整个目录中所有的文件也一起被复制了。</p><p>接着我们来看看移动操作，相当于是直接将一个文件转移到另一个目录中了，我们再创建一个目录用于文件的移动，并将test文件移动到此目录中，我们使用<code>mv</code>命令进行文件的移动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">mkdir</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">mv</span> <span class="hljs-built_in">test</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br>study  study2  study_copied<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ <span class="hljs-built_in">ls</span><br><span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>现在我们想要移动个目录到另一个目录中，比如我们想将study目录移动到study2目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">mv</span> study study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br>study2  study_copied<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ <span class="hljs-built_in">ls</span><br>study  <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><code>mv</code>命令不仅能实现文件的移动，还可以实现对文件重命名操作，比如我们想将文件test重命名为yyds，那么直接将其进行移动操作即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ <span class="hljs-built_in">ls</span><br>study  <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ <span class="hljs-built_in">mv</span> <span class="hljs-built_in">test</span> yyds<br><span class="hljs-built_in">test</span>@ubuntu-server:~/study2$ <span class="hljs-built_in">ls</span><br>study  yyds<br></code></pre></td></tr></table></figure><p>最后就是删除命令了，使用<code>rm</code>进行删除操作，比如现在我们想删除study2目录（注意需要添加-r参数表示递归删除文件夹中的内容）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">rm</span> -r study2<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br>study_copied<br></code></pre></td></tr></table></figure><p>而最常提到的<code>rm -rf /*</code>正是删除根目录下所有的文件（非常危险的操作），-f表示忽略不存在的文件，不进行任何提示，*是一个通配符，表示任意文件。这里我们演示一下删除所有.txt结尾的文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">touch</span> 1.txt 2.txt 3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br>1.txt  2.txt  3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">rm</span> *.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <br></code></pre></td></tr></table></figure><p>最后我们再来看文件的搜索，我们使用find命令来进行搜索，比如我想搜索&#x2F;etc目录下名为passwd的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo find /etc -name passwd<br>[sudo] password <span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span>: <br>/etc/pam.d/passwd<br>/etc/passwd<br></code></pre></td></tr></table></figure><p>它还支持通配符，比如搜索以s开头的文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle">test@ubuntu-server:~$ sudo <span class="hljs-keyword">find</span> /etc -name s*<br><span class="hljs-regexp">/etc/</span>subuid<br><span class="hljs-regexp">/etc/</span>screenrc<br><span class="hljs-regexp">/etc/</span>sensors3.conf<br><span class="hljs-regexp">/etc/</span>sysctl.conf<br><span class="hljs-regexp">/etc/</span>sudoers<br><span class="hljs-regexp">/etc/</span>shadow<br><span class="hljs-regexp">/etc/</span>skel<br><span class="hljs-regexp">/etc/</span>pam.d/su<br><span class="hljs-regexp">/etc/</span>pam.d/sshd<br><span class="hljs-regexp">/etc/</span>pam.d/sudo<br>...<br></code></pre></td></tr></table></figure><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p>接着我们来查看一些系统管理相关的命令，比如我们Windows中的任务管理器，我们可以使用<code>top</code>命令来打开：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tap">top - 10:48:46 up  5:52, <span class="hljs-number"> 1 </span>user,  load average: 0.00, 0.00, 0.00<br>Tasks:<span class="hljs-number"> 191 </span>total,  <span class="hljs-number"> 2 </span>running,<span class="hljs-number"> 189 </span>sleeping,  <span class="hljs-number"> 0 </span>stopped,  <span class="hljs-number"> 0 </span>zombie<br>%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>MiB Mem :   3919.1 total,   2704.2 free,    215.0 used,    999.9 buff/cache<br>MiB Swap:   3923.0 total,   3923.0 free,      0.0 used.   3521.4 avail Mem <br><br>    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                       <br> <span class="hljs-number"> 10528 </span>test     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>  <span class="hljs-number"> 8944 </span> <span class="hljs-number"> 3072 </span> <span class="hljs-number"> 2652 </span>R   0.7   0.1   0:00.07 top                           <br>  <span class="hljs-number"> 9847 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.3   0.0   0:00.87 kworker/0:0-events            <br>     <span class="hljs-number"> 1 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span><span class="hljs-number"> 102760 </span><span class="hljs-number"> 10456 </span> <span class="hljs-number"> 7120 </span>S   0.0   0.3   0:02.02 systemd                       <br>     <span class="hljs-number"> 2 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.01 kthreadd                      <br>     <span class="hljs-number"> 3 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 rcu_gp                        <br>     <span class="hljs-number"> 4 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 rcu_par_gp                    <br>     <span class="hljs-number"> 6 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 kworker/0:0H-kblockd          <br>     <span class="hljs-number"> 8 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 mm_percpu_wq                  <br>     <span class="hljs-number"> 9 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.15 ksoftirqd/0                   <br>    <span class="hljs-number"> 10 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>R   0.0   0.0   0:01.49 rcu_sched                     <br>    <span class="hljs-number"> 11 </span>root      rt  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.24 migration/0                   <br>    <span class="hljs-number"> 12 </span>root     -51  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 idle_inject/0                 <br>    <span class="hljs-number"> 14 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 cpuhp/0                       <br>    <span class="hljs-number"> 15 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 cpuhp/1                       <br>    <span class="hljs-number"> 16 </span>root     -51  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.00 idle_inject/1                 <br>    <span class="hljs-number"> 17 </span>root      rt  <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.30 migration/1                   <br>    <span class="hljs-number"> 18 </span>root     <span class="hljs-number"> 20 </span> <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>S   0.0   0.0   0:00.07 ksoftirqd/1                   <br>    <span class="hljs-number"> 20 </span>root      <span class="hljs-number"> 0 </span>-20      <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 0 </span>I   0.0   0.0   0:00.00 kworker/1:0H-kblockd  <br></code></pre></td></tr></table></figure><p>可以很清楚地看到当前CPU的使用情况以及内存的占用情况。</p><p>按下数字键1，可以展示所有CPU核心的使用情况：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">%Cpu0  :  <span class="hljs-number">0.0</span> us,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">sy</span>,  <span class="hljs-number">0.0</span> ni,<span class="hljs-number">100.0</span> id,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">wa</span>,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">hi</span>,  <span class="hljs-number">0.0</span> si,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">st</span><br>%Cpu1  :  <span class="hljs-number">0.0</span> us,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">sy</span>,  <span class="hljs-number">0.0</span> ni,<span class="hljs-number">100.0</span> id,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">wa</span>,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">hi</span>,  <span class="hljs-number">0.0</span> si,  <span class="hljs-number">0.0</span> <span class="hljs-keyword">st</span><br></code></pre></td></tr></table></figure><p>按下f键可以设置以哪一列进行排序或是显示那些参数：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">Fields Management <span class="hljs-keyword">for</span> window <span class="hljs-number">1</span>:Def, whose current <span class="hljs-keyword">sort</span> field <span class="hljs-keyword">is</span> %MEM<br>   Navigate with Up/Dn, Right selects <span class="hljs-keyword">for</span> <span class="hljs-keyword">move</span> then <span class="hljs-symbol">&lt;Enter&gt;</span> <span class="hljs-built_in">or</span> Left commits,<br>   <span class="hljs-string">&#x27;d&#x27;</span> <span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;Space&gt;</span> toggles <span class="hljs-keyword">display</span>, <span class="hljs-string">&#x27;s&#x27;</span> sets <span class="hljs-keyword">sort</span>.  Use <span class="hljs-string">&#x27;q&#x27;</span> <span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;Esc&gt;</span> <span class="hljs-keyword">to</span> end!<br></code></pre></td></tr></table></figure><p>按下q键即可退出监控界面。</p><p>我们可以直接输入free命令来查看当前系统的内存使用情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">test</span>@ubuntu-server:~$ free -m<br>              <span class="hljs-attribute">total</span>        used        free      shared  buff/cache   available<br><span class="hljs-attribute">Mem</span>:           <span class="hljs-number">3919</span>         <span class="hljs-number">212</span>        <span class="hljs-number">2706</span>           <span class="hljs-number">1</span>         <span class="hljs-number">999</span>        <span class="hljs-number">3523</span><br><span class="hljs-attribute">Swap</span>:          <span class="hljs-number">3922</span>           <span class="hljs-number">0</span>        <span class="hljs-number">3922</span><br></code></pre></td></tr></table></figure><p>其中-m表示以M为单位，也可以-g表示以G为单位，默认是kb为单位。</p><p>最后就是磁盘容量，我们可以使用<code>lsblk</code>来查看所有块设备的信息，其中就包括我们的硬盘、光驱等：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">test@ubuntu-server:~$ lsblk<br>NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>loop0                       7:0   <span class="hljs-number"> 0 </span>48.9M <span class="hljs-number"> 1 </span>loop /snap/core18/2127<br>loop1                       7:1   <span class="hljs-number"> 0 </span>28.1M <span class="hljs-number"> 1 </span>loop /snap/snapd/12707<br>loop2                       7:2   <span class="hljs-number"> 0 </span>  62M <span class="hljs-number"> 1 </span>loop /snap/lxd/21032<br>sr0                        11:0   <span class="hljs-number"> 1 </span>1024M <span class="hljs-number"> 0 </span>rom  <br>nvme0n1                   259:0   <span class="hljs-number"> 0 </span>  20G <span class="hljs-number"> 0 </span>disk <br>├─nvme0n1p1               259:1   <span class="hljs-number"> 0 </span> 512M <span class="hljs-number"> 0 </span>part /boot/efi<br>├─nvme0n1p2               259:2   <span class="hljs-number"> 0 </span>   1G <span class="hljs-number"> 0 </span>part /boot<br>└─nvme0n1p3               259:3   <span class="hljs-number"> 0 </span>18.5G <span class="hljs-number"> 0 </span>part <br>  └─ubuntu--vg-ubuntu--lv 253:0   <span class="hljs-number"> 0 </span>18.5G <span class="hljs-number"> 0 </span>lvm  /<br></code></pre></td></tr></table></figure><p>可以看到nvme开头的就是我们的硬盘（这个因人而异，可能你们的是sda，磁盘类型不同名称就不同）可以看到<code>nvme0n1  </code>容量为20G，并且512M用作存放EFI文件，1G存放启动文件，剩余容量就是存放系统文件和我们的用户目录。</p><p>这里要提到一个挂载的概念：</p><blockquote><p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p></blockquote><p>比如我们的主硬盘，挂载点就被设定为<code>/</code>根目录，而我们所有保存的文件都会存储在硬盘中，如果你有U盘（最好将U盘的文件格式改为ExFat，可以直接在Windows中进行格式化，然后随便放入一些文件即可）之类的东西，我们可以演示一下对U盘进行挂载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo fdisk -l<br>...<br>Disk /dev/sda: 60 GiB, 64424509440 bytes, 125829120 sectors<br>Disk model: USB DISK        <br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel <span class="hljs-built_in">type</span>: dos<br>Disk identifier: 0x4a416279<br><br>Device     Boot     Start       End   Sectors  Size Id Type<br>/dev/sda1  *       614400 125214719 124600320 59.4G  7 HPFS/NTFS/exFAT<br>/dev/sda2       125214720 125825022    610303  298M  6 FAT16<br></code></pre></td></tr></table></figure><p>将U盘插入电脑，选择连接到Linux，输入<code>sudo fdisk -l</code>命令来查看硬盘实体情况，可以看到有一个USB DISK设备，注意观察一下是不是和自己的U盘容量一致，可以看到设备名称为<code>/dev/sda1</code>。</p><p>接着我们设备挂载到一个目录下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">mkdir</span> u-test<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo mount /dev/sda1 u-test/<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">cd</span> u-test/<br><span class="hljs-built_in">test</span>@ubuntu-server:~/u-test$ <span class="hljs-built_in">ls</span><br> CGI<br> cn_windows_10_enterprise_ltsc_2019_x64_dvd_9c09ff24.iso<br> cn_windows_7_professional_x64_dvd_x15-65791.iso<br> cn_windows_8.1_enterprise_with_update_x64_dvd_6050374.iso<br> cn_windows_8.1_professional_vl_with_update_x64_dvd_4050293.iso<br> cn_windows_server_2019_updated_july_2020_x64_dvd_2c9b67da.iso<br><span class="hljs-string">&#x27;System Volume Information&#x27;</span><br> zh-cn_windows_10_consumer_editions_version_21h1_updated_sep_2021_x64_dvd_991b822f.iso<br> zh-cn_windows_11_consumer_editions_x64_dvd_904f13e4.iso<br></code></pre></td></tr></table></figure><p>最后进入到此目录中，就能看到你U盘中的文件了，如果你不想使用U盘了，可以直接取消挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>@ubuntu-server:~/u-test$ <span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo umount /dev/sda1<br></code></pre></td></tr></table></figure><p>最后我们可以通过<code>df</code>命令查看当前磁盘使用情况：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">test@ubuntu-server:~$ df -m<br>Filesystem                        1M-blocks  Used Available Use% Mounted on<br>udev                                  <span class="hljs-number"> 1900 </span>   <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 1900 </span>  0% /dev<br>tmpfs                                  <span class="hljs-number"> 392 </span>   <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 391 </span>  1% /run<br>/dev/mapper/ubuntu--vg-ubuntu--lv    <span class="hljs-number"> 18515 </span><span class="hljs-number"> 6544 </span>   <span class="hljs-number"> 11009 </span> 38% /<br>tmpfs                                 <span class="hljs-number"> 1960 </span>   <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 1960 </span>  0% /dev/shm<br>tmpfs                                    <span class="hljs-number"> 5 </span>   <span class="hljs-number"> 0 </span>       <span class="hljs-number"> 5 </span>  0% /run/lock<br>tmpfs                                 <span class="hljs-number"> 1960 </span>   <span class="hljs-number"> 0 </span>    <span class="hljs-number"> 1960 </span>  0% /sys/fs/cgroup<br>/dev/nvme0n1p2                         <span class="hljs-number"> 976 </span> <span class="hljs-number"> 109 </span>     <span class="hljs-number"> 800 </span> 12% /boot<br>/dev/nvme0n1p1                         <span class="hljs-number"> 511 </span>   <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 508 </span>  1% /boot/efi<br>/dev/loop0                              <span class="hljs-number"> 49 </span>  <span class="hljs-number"> 49 </span>       <span class="hljs-number"> 0 </span>100% /snap/core18/2127<br>/dev/loop1                              <span class="hljs-number"> 29 </span>  <span class="hljs-number"> 29 </span>       <span class="hljs-number"> 0 </span>100% /snap/snapd/12707<br>/dev/loop2                              <span class="hljs-number"> 62 </span>  <span class="hljs-number"> 62 </span>       <span class="hljs-number"> 0 </span>100% /snap/lxd/21032<br>tmpfs                                  <span class="hljs-number"> 392 </span>   <span class="hljs-number"> 0 </span>     <span class="hljs-number"> 392 </span>  0% /run/user/1000<br></code></pre></td></tr></table></figure><p>输入<code>ps</code>可以查看当前运行的一些进程，其实和top有点类似，但是没有监控功能，只能显示当前的。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">test</span>@ubuntu-server:~$ ps<br>    <span class="hljs-attribute">PID</span> TTY          TIME CMD<br>  <span class="hljs-attribute">11438</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> bash<br>  <span class="hljs-attribute">11453</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ps<br></code></pre></td></tr></table></figure><p>添加-ef查看所有的进程：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">test@ubuntu-server:~$ ps -ef<br>UID          PID    PPID  C STIME TTY          TIME CMD<br>root          <span class="hljs-number"> 1 </span>     <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:02 /sbin/init<br>root          <span class="hljs-number"> 2 </span>     <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [kthreadd]<br>root          <span class="hljs-number"> 3 </span>     <span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [rcu_gp]<br>root          <span class="hljs-number"> 4 </span>     <span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [rcu_par_gp]<br>root          <span class="hljs-number"> 6 </span>     <span class="hljs-number"> 2 </span><span class="hljs-number"> 0 </span>04:55 ?        00:00:00 [kworker/0:0H-kblockd]<br>...<br></code></pre></td></tr></table></figure><p>我们可以找到对应的进程ID（PID），使用kill命令将其强制终止：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">test</span>@ubuntu-server:~$ ps<br>    <span class="hljs-attribute">PID</span> TTY          TIME CMD<br>  <span class="hljs-attribute">11438</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> bash<br>  <span class="hljs-attribute">11455</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> ps<br><span class="hljs-attribute">test</span>@ubuntu-server:~$ kill -<span class="hljs-number">9</span> <span class="hljs-number">11438</span><br><span class="hljs-attribute">Connection</span> to <span class="hljs-number">192.168.10.6</span> closed.<br></code></pre></td></tr></table></figure><p>比如我们可以将当前会话的bash给杀死，那么会导致我们的连接直接断开，其中-9是一个信号，表示杀死进程：</p><ul><li>1 (HUP)：重新加载进程。</li><li>9 (KILL)：杀死一个进程。</li><li>15 (TERM)：正常停止一个进程。</li></ul><p>最后如果我们想要正常关机，只需要输入shutdown即可，系统会创建一个关机计划，并在指定时间关机，或是添加now表示立即关机：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit">test<span class="hljs-symbol">@ubuntu</span>-server:~$ sudo <span class="hljs-built_in">shutdown</span><br>[sudo] password <span class="hljs-keyword">for</span> test: <br><span class="hljs-built_in">Shutdown</span> scheduled <span class="hljs-keyword">for</span> Mon <span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">46</span>:<span class="hljs-number">18</span> UTC, use <span class="hljs-string">&#x27;shutdown -c&#x27;</span> <span class="hljs-keyword">to</span> cancel.<br>test<span class="hljs-symbol">@ubuntu</span>-server:~$ sudo <span class="hljs-built_in">shutdown</span> now<br>Connection <span class="hljs-keyword">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.6</span> closed by remote host.<br>Connection <span class="hljs-keyword">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.6</span> closed.<br></code></pre></td></tr></table></figure><h3 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h3><p>比较常用的压缩和解压也是重点，我们在Windows中经常需要下载一些压缩包，并且将压缩包解压才能获得里面的文件，而Linux中也支持文件的压缩和解压。</p><p>这里我们使用<code>tar</code>命令来完成文件亚索和解压操作，在Linux中比较常用的是gzip格式，后缀名一般为.gz，tar命令的参数-c表示对文件进行压缩，创建新的压缩文件，-x表示进行解压操作，-z表示以gzip格式进行操作，-v可以在处理过程中输出一些日志信息，-f表示对普通文件进行操作，这里我们创建三个文件并对这三个文件进行打包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zcvf test.tar.gz *.txt<br>1.txt<br>2.txt<br>3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br>1.txt  2.txt  3.txt  test.tar.gz<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <br></code></pre></td></tr></table></figure><p>接着我们删除刚刚三个文件，再执行解压操作，得到压缩包中文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">rm</span> *.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br>test.tar.gz<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zxvf test.tar.gz <br>1.txt<br>2.txt<br>3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br>1.txt  2.txt  3.txt  test.tar.gz<br></code></pre></td></tr></table></figure><p>同样的，我们也可以对一个文件夹进行打包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">mv</span> *.txt <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zcvf test.tar.gz <span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">test</span>/1.txt<br><span class="hljs-built_in">test</span>/2.txt<br><span class="hljs-built_in">test</span>/3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">rm</span> -r <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br>test.tar.gz <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ tar -zxvf test.tar.gz <br><span class="hljs-built_in">test</span>/<br><span class="hljs-built_in">test</span>/1.txt<br><span class="hljs-built_in">test</span>/2.txt<br><span class="hljs-built_in">test</span>/3.txt<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span><br><span class="hljs-built_in">test</span>  test.tar.gz<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ <span class="hljs-built_in">ls</span> <span class="hljs-built_in">test</span><br>1.txt  2.txt  3.txt<br></code></pre></td></tr></table></figure><p>到此，Linux的一些基本命令就讲解为止。</p><hr><h2 id="vim文本编辑器"><a href="#vim文本编辑器" class="headerlink" title="vim文本编辑器"></a>vim文本编辑器</h2><p>和Windows中的记事本一样，Linux中也有文本编辑器，叫做Vi编辑器，Ubuntu中内置了Vi编辑器的升级版Vim，我们这里就讲解Vim编辑器的使用。</p><p>我们可以直接输入<code>vim 文件名称</code>来使用Vim编辑器对文本文件进行编辑：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ vim hello.txt<br></code></pre></td></tr></table></figure><p>进入编辑器之后，我们发现界面变成了：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haml">~                                                                                                                                                                                         <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>&quot;hello.txt&quot; [New File]                                                            0,0-1         All<br></code></pre></td></tr></table></figure><p>这时我们直接输入内容是无法完成的，因为默认进入之后为<code>命令模式</code>，Vim编辑器默认有三种模式：</p><p><img src="http://c.biancheng.net/uploads/allimg/180914/1-1P9141F35R32.jpg" alt="img"></p><ul><li>命令模式：此模式下可以输入任意的命令进行操作，所有的输入都被看做是命令输入，而不是文本编辑输入。</li><li>编辑模式：此模式下输入的任何内容都会以文本编辑方式写入到文件中，就像我们直接在Windows的记事本中写内容一样。</li><li>末行模式：此模式下用于输入一些复杂命令，会在最后一行进行复杂命令的输入。</li></ul><p>在命令模式下，我们可以直接按下键盘上的<code>i</code>，此命令表示进行插入操作，会自动切换到编辑模式，这时可以看到最下方变为：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml">~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>~                                                                                                   <br>-<span class="language-ruby">- <span class="hljs-variable constant_">INSERT</span> --                                                                      <span class="hljs-number">1</span>,<span class="hljs-number">1</span>           All</span><br></code></pre></td></tr></table></figure><p>而这时我们所有的输入内容都可以直接写到文件中了，如果我们想回到命令模式，按下<code>Esc</code>键即可。</p><p>除了<code>i</code>以外，我们也可以按下<code>a</code>表示从当前光标所在位置之后继续写，与<code>i</code>不同的是，<code>i</code>会在光标之前继续写，<code>o</code>会直接跳到下一行，而<code>A</code>表示在当前行的最后继续写入，<code>I</code>表示在当前行的最前面继续写入。</p><p>这里我们随便粘贴一段文本信息进去（不要用Ctrl+V，Linux中没这操作，XShell右键点粘贴）：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">I was hard <span class="hljs-keyword">on</span> people sometimes, probably harder than I needed <span class="hljs-keyword">to</span> be. <br>I remember <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> when Reed was six years old, coming home, <span class="hljs-keyword">and</span> I had just fired somebody <span class="hljs-keyword">that</span> <span class="hljs-built_in">day</span>.<br>And I imagined what <span class="hljs-keyword">it</span> was like <span class="hljs-keyword">for</span> <span class="hljs-keyword">that</span> person <span class="hljs-keyword">to</span> <span class="hljs-keyword">tell</span> his family <span class="hljs-keyword">and</span> his young son <span class="hljs-keyword">that</span> he had lost his job. <br>It was hard. <br>But　somebody’s got <span class="hljs-keyword">to</span> do <span class="hljs-keyword">it</span>. <br>I figured <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> was always <span class="hljs-keyword">my</span> job <span class="hljs-keyword">to</span> make sure <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> team was excellent, <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span> I didn’t do <span class="hljs-keyword">it</span>, nobody was going <span class="hljs-keyword">to</span> do <span class="hljs-keyword">it</span>.<br>You always have <span class="hljs-keyword">to</span> keep pushing <span class="hljs-keyword">to</span> innovate.<br>Dylan could have sung protest songs forever <span class="hljs-keyword">and</span> probably made a lot <span class="hljs-keyword">of</span> money, <span class="hljs-keyword">but</span> he didn’t. <br>He had <span class="hljs-keyword">to</span> move <span class="hljs-keyword">on</span>, <span class="hljs-keyword">and</span> when he did, <span class="hljs-keyword">by</span> going electric <span class="hljs-keyword">in</span> <span class="hljs-number">1965</span>, he alienated a lot <span class="hljs-keyword">of</span> people.<br></code></pre></td></tr></table></figure><p>在我们编辑完成之后，需要进入到末行模式进行文件的保存并退出，按下<code>:</code>进入末行模式，再输入wq即可保存退出。</p><p>接着我们来看一些比较常用的命令，首先是命令模式下的光标移动命令：</p><ul><li>^   直接调到本行最前面</li><li>$   直接跳到本行最后面</li><li>gg  直接跳到第一行</li><li>[N]G    跳转到第N行</li><li>[N]方向键    向一个方向跳转N个字符</li></ul><p>在末行模式下，常用的复杂命令有：</p><ul><li>:set number    开启行号</li><li>:w保存</li><li>:wq或:x保存并关闭</li><li>:q关闭</li><li>:q!强制关闭</li></ul><p>我们可以输入<code>/</code>或是<code>?</code>在末行模式中使用搜索功能，比如我们要搜索单词<code>it</code>：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">/<span class="hljs-keyword">it</span>  <br></code></pre></td></tr></table></figure><p>接着会在文本中出现高亮，按<code>n</code>跳转到下一个搜索结果，?是从后向前搜索，&#x2F;是从前向后搜索。</p><p>它还支持替换功能，但是使用起来稍微比较复杂，语法如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:[addr]s<span class="hljs-regexp">/源字符串/</span>目的字符串/[option]<br></code></pre></td></tr></table></figure><p>addr表示第几行或是一个范围，option表示操作类型：</p><ul><li>g: globe,表示全局替换</li><li>c: confirm,表示进行确认</li><li>p: 表示替代结果逐行显示(Ctrl + L恢复屏幕)</li><li>i:  ignore,不区分大小写</li></ul><p>比如我们要将当前行中的<code>it</code>全部替换为<code>he</code>，那么可以这样写：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:s/it/he/g</span><br></code></pre></td></tr></table></figure><p>实际上除了以上三种模式外，还有一种模式叫做可视化模式，按下键盘上的<code>v</code>即可进入，它能够支持选取一段文本，选取后，我们可以对指定段落的文本内容快速进行复制、剪切、删除、插入等操作，非常方便。在此模式下，我们可以通过上下左右键进行选取，以进入可视化模式时的位置作为基本位置，通过移动另一端来进行选取。</p><p>我们可以使用以下命令来对选中区域进行各种操作：</p><ul><li>y   复制选中区域</li><li>d&#x2F;x   剪切（删除）选中区域</li><li>p  粘贴</li><li>u  撤销上一步</li></ul><p>当然，这些命令在命令模式下也可以使用，但是可视化模式下使用更适合一些。</p><hr><h2 id="环境安装和项目部署"><a href="#环境安装和项目部署" class="headerlink" title="环境安装和项目部署"></a>环境安装和项目部署</h2><p>在学习完了Linux操作系统的一些基本操作之后，我们接着来看如何进行项目的环境安装和部署，包括安装JDK、Nginx服务器，以及上传我们的SpringBoot项目并运行。</p><p>我们可以直接使用apt进行软件的安装，它是一个高级的安装包管理工具，我们可以直接寻找对应的软件进行安装，无需再去官网进行下载，非常方便，软件仓库中默认已经帮助我们存放了大量实用软件的安装包，只需要一个安装命令就可以进行安装了。</p><p>实际上Ubuntu系统已经为我们自带了一些环境了，比如Python3：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">test@ubuntu-server:~$ python3<br>Python <span class="hljs-number">3.8</span>.<span class="hljs-number">10</span> (default, Nov <span class="hljs-number">26</span> <span class="hljs-number">2021</span>, <span class="hljs-number">20</span>:<span class="hljs-number">14</span>:<span class="hljs-number">08</span>) <br>[GCC <span class="hljs-number">9.3</span>.<span class="hljs-number">0</span>] on linux<br>Type <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> or <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.<br>&gt;&gt;&gt; print(<span class="hljs-string">&quot;HelloWorld！&quot;</span>)<br>HelloWorld！<br>&gt;&gt;&gt; <span class="hljs-keyword">exit</span>()<br></code></pre></td></tr></table></figure><p>C语言的编译工具GCC可以通过APT进行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install gcc<br></code></pre></td></tr></table></figure><p>安装后，可以编写一个简单的C语言程序并且编译为可执行文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>&#125;  <br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ vim hello.c<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ gcc hello.c -o hello<br><span class="hljs-built_in">test</span>@ubuntu-server:~$ ./hello <br>Hello World!<br></code></pre></td></tr></table></figure><p>而JDK实际上安装也非常简单，通过APT即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo apt install openjdk-8-j<br>openjdk-8-jdk           openjdk-8-jre           openjdk-8-jre-zero      <br>openjdk-8-jdk-headless  openjdk-8-jre-headless  <br><span class="hljs-built_in">test</span>@ubuntu-server:~$ sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>接着我们来测试一下编译和运行，首先编写一个Java程序：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>vim Main.java<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)&#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello World！&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>javac Main.java <br>test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>ls<br>Main.<span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>.java<br>test<span class="hljs-variable">@ubuntu</span>-<span class="hljs-symbol">server:</span>~<span class="hljs-variable">$ </span>java Main <br>Hello World！<br></code></pre></td></tr></table></figure><p>接着我们来部署一下Redis服务器：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>@ubuntu-server:~$ sudo apt <span class="hljs-keyword">install</span> redis<br></code></pre></td></tr></table></figure><p>安装完成后，可以直接使用<code>redis-cli</code>命令打开Redis客户端连接本地的服务器：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">test@ubuntu-server:~$ redis-cli<br><span class="hljs-number">127.0.0.1:6379</span>&gt; keys *<br>(empty list or set)<br></code></pre></td></tr></table></figure><p>使用和之前Windows下没有区别。</p><p>接着我们安装一下MySQL服务器，同样的，直接使用apt即可：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> apt install mysql-server-<span class="hljs-number">8</span>.<span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>我们直接直接登录MySQL服务器，注意要在root权限下使用，这样就不用输入密码了：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo mysql -u root -p<br>Enter password: <br>Welcome to the MySQ<span class="hljs-class">L monitor.  Commands end with ;</span><span class="hljs-built_in"> or </span>\g.<br>Your MySQL connection id is 11<br>Server version: 8.0.27-0ubuntu0.20.04.1 (Ubuntu)<br><br>Copyright (c) 2000, 2021, Oracle<span class="hljs-built_in"> and/or </span>its affiliates.<br><br>Oracle is a registered trademark of Oracle Corporation<span class="hljs-built_in"> and/or </span>its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#x27;help;&#x27;<span class="hljs-built_in"> or </span>&#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.<br><br>mysql&gt; exit<br></code></pre></td></tr></table></figure><p>可以发现实际上就是我们之前在Windows的CMD中使用的样子，接着我们就创建一个生产环境下使用的数据库：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; create database book_manage;<br>mysql&gt; show databases;<br>+--------------------+<br>|<span class="hljs-string"> Database           </span>|<br>+--------------------+<br>|<span class="hljs-string"> book_manage        </span>|<br>|<span class="hljs-string"> information_schema </span>|<br>|<span class="hljs-string"> mysql              </span>|<br>|<span class="hljs-string"> performance_schema </span>|<br>|<span class="hljs-string"> sys                </span>|<br>+--------------------+<br>5 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>接着我们创建一个用户来使用这个数据，一会我们就可以将SpringBoot配置文件进行修改并直接放到此服务器上进行部署。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> test identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.01</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> book_manage.* <span class="hljs-keyword">to</span> test;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>如果觉得这样很麻烦不是可视化的，可以使用Navicat连接进行操作，注意开启一下MySQL的外网访问。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs smali">test@ubuntu-server:~$ mysql -u test -p<br>Enter password: <br>Welcome to the MySQ<span class="hljs-class">L monitor.  Commands end with ;</span><span class="hljs-built_in"> or </span>\g.<br>Your MySQL connection id is 13<br>Server version: 8.0.27-0ubuntu0.20.04.1 (Ubuntu)<br><br>Copyright (c) 2000, 2021, Oracle<span class="hljs-built_in"> and/or </span>its affiliates.<br><br>Oracle is a registered trademark of Oracle Corporation<span class="hljs-built_in"> and/or </span>its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#x27;help;&#x27;<span class="hljs-built_in"> or </span>&#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.<br><br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| book_manage        |<br>| information_schema |<br>+--------------------+<br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p>使用test用户登录之后，查看数据库列表，有book_manage就OK了。</p><p>最后我们修改一下SpringBoot项目的生产环境配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">javastudy111@163.com</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">TKPGLAPDSWKGJOWK</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/book_manage</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">hibernate:</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><br><span class="hljs-attr">springfox:</span><br>  <span class="hljs-attr">documentation:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>然后启动我们的项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">test</span>@ubuntu-server:~$ java -jar springboot-project-0.0.1-SNAPSHOT.jar <br></code></pre></td></tr></table></figure><p>现在我们将前端页面的API访问地址修改为我们的SpringBoot服务器地址，即可正常使用了。</p><p>我们也可以将我们的静态资源使用Nginx服务器进行代理：</p><blockquote><p>Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。 在高连接并发的情况下，Nginx是Apache服务器不错的替代品。</p></blockquote><p>Nginx非常强大，它能够通提供非常方便的反向代理服务，并且支持负载均衡，不过我们这里用一下反向代理就可以了，实际上就是代理我们的前端页面，然后我们访问Nginx服务器即可访问到静态资源，这样我们前后端都放在了服务器上（你也可以搞两台服务器，一台挂静态资源一台挂SpringBoot服务器，实现真正意义上的分离，有条件的还能上个域名和证书啥的）。</p><p>安装如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>@ubuntu-server:~$ sudo apt <span class="hljs-keyword">install</span> nginx<br></code></pre></td></tr></table></figure><p>安装完成后，我们可以直接访问：<a href="http://192.168.10.4/%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%87%BA%E7%8E%B0Nginx%E9%A1%B5%E9%9D%A2%E8%A1%A8%E7%A4%BA%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%EF%BC%81">http://192.168.10.4/，能够出现Nginx页面表示安装成功！</a></p><p>接着我们将静态资源上传到Linux服务器中，然后对Nginx进行反向代理配置：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">test</span>@ubuntu-server:~$ <span class="hljs-keyword">cd</span> /etc/nginx/<br><span class="hljs-keyword">test</span>@ubuntu-server:/etc/nginx$ <span class="hljs-keyword">ls</span><br><span class="hljs-keyword">conf</span>.<span class="hljs-keyword">d</span>koi-utf     modules-available  proxy_paramssites-enabled  <span class="hljs-keyword">win</span>-utf<br>fastcgi.<span class="hljs-keyword">conf</span>koi-<span class="hljs-keyword">win</span>     modules-enabled    scgi_paramssnippets<br>fastcgi_paramsmime.types  nginx.<span class="hljs-keyword">conf</span>       sites-availableuwsgi_params<br><span class="hljs-keyword">test</span>@ubuntu-server:/etc/nginx$ sudo vim nginx.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>                <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>                <span class="hljs-attribute">server_name</span>  <span class="hljs-number">192.168.10.4</span>;<br>                <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *;<br>                <span class="hljs-section">location</span> / &#123;<br>                        <span class="hljs-attribute">root</span> /home/test/static;<br>                        <span class="hljs-attribute">charset</span> utf-<span class="hljs-number">8</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span>;<br>                        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;Content-Type,*&#x27;</span>;<br>                &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>然后就可以直接访问到我们的前端页面了，这时再开启SpringBoot服务器即可，可以在最后添加&amp;符号表示后台启动。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2022/10/02/redis/"/>
    <url>/2022/10/02/redis/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-054d8ff6135b3638aca543eff7424f98_1200x500.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644500043&t=72a4f8ecfca9ff5a2a0b3896edef4be7" alt="点击查看源网页"></p><h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><p><strong>灵魂拷问：</strong>不是学了MySQL吗，存数据也能存了啊，又学一个数据库干嘛？</p><p>在前面我们学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web应用下，只需要一个MySQL+Mybatis自带的缓存系统就可以胜任大部分的数据存储工作。但是MySQL的缺点也很明显，它的数据始终是存储在硬盘上的，对于我们的用户信息这种不需要经常发生修改的内容，使用MySQL存储确实可以，但是如果是快速更新或是频繁使用的数据，比如微博热搜、双十一秒杀，这些数据不仅要求服务器需要提供更高的响应速度，而且还需要面对短时间内上百万甚至上千万次访问，而MySQL的磁盘IO读写性能完全不能满足上面的需求，能够满足上述需求的只有内存，因为速度远高于磁盘IO。</p><p>因此，我们需要寻找一种更好的解决方案，来存储上述这类特殊数据，弥补MySQL的不足，以应对大数据时代的重重考验。</p><h2 id="NoSQL概论"><a href="#NoSQL概论" class="headerlink" title="NoSQL概论"></a>NoSQL概论</h2><p>NoSQL全称是Not Only SQL（不仅仅是SQL）它是一种非关系型数据库，相比传统SQL关系型数据库，它：</p><ul><li>不保证关系数据的ACID特性</li><li>并不遵循SQL标准</li><li>消除数据之间关联性</li></ul><p>乍一看，这玩意不比MySQL垃圾？我们再来看看它的优势：</p><ul><li>远超传统关系型数据库的性能</li><li>非常易于扩展</li><li>数据模型更加灵活</li><li>高可用</li></ul><p>这样，NoSQL的优势一下就出来了，这不就是我们正要寻找的高并发海量数据的解决方案吗！</p><p>NoSQL数据库分为以下几种：</p><ul><li><strong>键值存储数据库：</strong>所有的数据都是以键值方式存储的，类似于我们之前学过的HashMap，使用起来非常简单方便，性能也非常高。</li><li><strong>列存储数据库：</strong>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。</li><li><strong>文档型数据库：</strong>它是以一种特定的文档格式存储数据，比如JSON格式，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。</li><li><strong>图形数据库：</strong>利用类似于图的数据结构存储数据，结合图相关算法实现高速访问。</li></ul><p>其中我们要学习的Redis数据库，就是一个开源的<strong>键值存储数据库</strong>，所有的数据全部存放在内存中，它的性能大大高于磁盘IO，并且它也可以支持数据持久化，他还支持横向扩展、主从复制等。</p><p>实际生产中，我们一般会配合使用Redis和MySQL以发挥它们各自的优势，取长补短。</p><h2 id="Redis安装和部署"><a href="#Redis安装和部署" class="headerlink" title="Redis安装和部署"></a>Redis安装和部署</h2><p>我们这里还是使用Windows安装Redis服务器，但是官方指定是安装到Linux服务器上，我们后面学习了Linux之后，再来安装到Linux服务器上。由于官方并没有提供Windows版本的安装包，我们需要另外寻找：</p><ul><li>官网地址：<a href="https://redis.io/">https://redis.io</a></li><li>GitHub Windows版本维护地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></li></ul><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>在我们之前使用MySQL时，我们需要先在数据库中创建一张表，并定义好表的每个字段内容，最后再通过<code>insert</code>语句向表中添加数据，而Redis并不具有MySQL那样的严格的表结构，Redis是一个键值数据库，因此，可以像Map一样的操作方式，通过键值对向Redis数据库中添加数据（操作起来类似于向一个HashMap中存放数据）</p><p>在Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。 默认情况下，我们连接Redis数据库之后，会使用0号数据库，我们可以通过Redis配置文件中的参数来修改数据库总数，默认为16个。</p><p>我们可以通过<code>select</code>语句进行切换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 序号;<br></code></pre></td></tr></table></figure><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><p>我们来看看，如何向Redis数据库中添加数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 一次性多个</span><br>mset [<span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>]...<br></code></pre></td></tr></table></figure><p>所有存入的数据默认会以<strong>字符串</strong>的形式保存，键值具有一定的命名规范，以方便我们可以快速定位我们的数据属于哪一个部分，比如用户的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 使用冒号来进行板块分割，比如下面表示用户XXX的信息中的name属性，值为lbw</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">user</span>:info:用户ID:name lbw<br></code></pre></td></tr></table></figure><p>我们可以通过键值获取存入的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">get</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>你以为Redis就仅仅只是存取个数据吗？它还支持数据的过期时间设定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> EX 秒<br><span class="hljs-keyword">set</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> PX 毫秒<br></code></pre></td></tr></table></figure><p>当数据到达指定时间时，会被自动删除。我们也可以单独为其他的键值对设置过期时间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">expire <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> 秒<br></code></pre></td></tr></table></figure><p>通过下面的命令来查询某个键值对的过期时间还剩多少：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">ttl <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 毫秒显示</span><br>pttl <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 转换为永久</span><br>persist <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>那么当我们想直接删除这个数据时呢？直接使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">del <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>...<br></code></pre></td></tr></table></figure><p>删除命令可以同时拼接多个键值一起删除。</p><p>当我们想要查看数据库中所有的键值时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">keys <span class="hljs-operator">*</span><br></code></pre></td></tr></table></figure><p>也可以查询某个键是否存在：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">exists</span> <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>...<br></code></pre></td></tr></table></figure><p>还可以随机拿一个键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">randomkey<br></code></pre></td></tr></table></figure><p>我们可以将一个数据库中的内容移动到另一个数据库中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">move <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> 数据库序号<br></code></pre></td></tr></table></figure><p>修改一个键为另一个键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">rename <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>新的名称<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 下面这个会检查新的名称是否已经存在</span><br>renamex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>新的名称<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>如果存放的数据是一个数字，我们还可以对其进行自增自减操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 等价于a = a + 1</span><br>incr <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 等价于a = a + b</span><br>incrby <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> b<br><span class="hljs-comment">-- 等价于a = a - 1</span><br>decr <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>最后就是查看值的数据类型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">type <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>Redis数据库也支持多种数据类型，但是它更偏向于我们在Java中认识的那些数据类型。</p><h2 id="数据类型介绍"><a href="#数据类型介绍" class="headerlink" title="数据类型介绍"></a>数据类型介绍</h2><p>一个键值对除了存储一个String类型的值以外，还支持多种常用的数据类型。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>这种类型本质上就是一个HashMap，也就是嵌套了一个HashMap罢了，在Java中就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">#Redis默认存String类似于这样：<br>Map&lt;String, String&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>#Redis存Hash类型的数据类似于这样：<br>Map&lt;String, Map&lt;String, String&gt;&gt; hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>它比较适合存储类这样的数据，由于值本身又是一个Map，因此我们可以在此Map中放入类的各种属性和值，以实现一个Hash数据类型存储一个类的数据。</p><p>我们可以像这样来添加一个Hash类型的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hset <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>值<span class="hljs-operator">&gt;</span>]...<br></code></pre></td></tr></table></figure><p>我们可以直接获取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">hget <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 如果想要一次性获取所有的字段和值</span><br>hgetall <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>同样的，我们也可以判断某个字段是否存在：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hexists <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>字段<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>删除Hash中的某个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hdel <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>我们发现，在操作一个Hash时，实际上就是我们普通操作命令前面添加一个<code>h</code>，这样就能以同样的方式去操作Hash里面存放的键值对了，这里就不一一列出所有的操作了。我们来看看几个比较特殊的。</p><p>我们现在想要知道Hash中一共存了多少个键值对：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hlen <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>我们也可以一次性获取所有字段的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">hvals <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>唯一需要注意的是，Hash中只能存放字符串值，不允许出现嵌套的的情况。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>我们接着来看List类型，实际上这个猜都知道，它就是一个列表，而列表中存放一系列的字符串，它支持随机访问，支持双端操作，就像我们使用Java中的LinkedList一样。</p><p>我们可以直接向一个已存在或是不存在的List中添加数据，如果不存在，会自动创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 向列表头部添加元素</span><br>lpush <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 向列表尾部添加元素</span><br>rpush <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 在指定元素前面/后面插入元素</span><br>linsert <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> before<span class="hljs-operator">/</span>after <span class="hljs-operator">&lt;</span>指定元素<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>element<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>同样的，获取元素也非常简单：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 根据下标获取元素</span><br>lindex <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>下标<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取并移除头部元素</span><br>lpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取并移除尾部元素</span><br>rpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 获取指定范围内的</span><br>lrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop<br></code></pre></td></tr></table></figure><p>注意下标可以使用负数来表示从后到前数的数字（Python：搁这儿抄呢是吧）:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 获取列表a中的全部元素</span><br>lrange a <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p>没想到吧，push和pop还能连着用呢：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 从前一个数组的最后取一个数出来放到另一个数组的头部，并返回元素</span><br>rpoplpush 当前数组 目标数组<br></code></pre></td></tr></table></figure><p>它还支持阻塞操作，类似于生产者和消费者，比如我们想要等待列表中有了数据后再进行pop操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 如果列表中没有元素，那么就等待，如果指定时间（秒）内被添加了数据，那么就执行pop操作，如果超时就作废，支持同时等待多个列表，只要其中一个列表有元素了，那么就能执行</span><br>blpop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>... timeout<br></code></pre></td></tr></table></figure><h3 id="Set和SortedSet"><a href="#Set和SortedSet" class="headerlink" title="Set和SortedSet"></a>Set和SortedSet</h3><p>Set集合其实就像Java中的HashSet一样（我们在JavaSE中已经讲解过了，HashSet本质上就是利用了一个HashMap，但是Value都是固定对象，仅仅是Key不同）它不允许出现重复元素，不支持随机访问，但是能够利用Hash表提供极高的查找效率。</p><p>向Set中添加一个或多个值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>...<br></code></pre></td></tr></table></figure><p>查看Set集合中有多少个值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">scard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>判断集合中是否包含：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 是否包含指定值</span><br>sismember <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 列出所有值</span><br>smembers <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>集合之间的运算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 集合之间的差集</span><br>sdiff <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 集合之间的交集</span><br>sinter <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 求并集</span><br>sunion <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 将集合之间的差集存到目标集合中</span><br>sdiffstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 同上</span><br>sinterstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 同上</span><br>sunionstore 目标 <span class="hljs-operator">&lt;</span>key1<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>key2<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>移动指定值到另一个集合中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">smove <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> 目标 <span class="hljs-keyword">value</span> <br></code></pre></td></tr></table></figure><p>移除操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 随机移除一个幸运儿</span><br>spop <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 移除指定</span><br>srem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>...<br></code></pre></td></tr></table></figure><p>那么如果我们要求Set集合中的数据按照我们指定的顺序进行排列怎么办呢？这时就可以使用SortedSet，它支持我们为每个值设定一个分数，分数的大小决定了值的位置，所以它是有序的。</p><p>我们可以添加一个带分数的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">zadd <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>score<span class="hljs-operator">&gt;</span>]...<br></code></pre></td></tr></table></figure><p>同样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询有多少个值</span><br>zcard <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span><br><span class="hljs-comment">-- 移除</span><br>zrem <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span>...<br><span class="hljs-comment">-- 获取区间内的所有</span><br>zrange <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop<br></code></pre></td></tr></table></figure><p>由于所有的值都有一个分数，我们也可以根据分数段来获取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 通过分数段查看</span><br>zrangebyscore <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">start</span> stop [withscores] [limit]<br><span class="hljs-comment">-- 统计分数段内的数量</span><br>zcount <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span>  <span class="hljs-keyword">start</span> stop<br><span class="hljs-comment">-- 根据分数获取指定值的排名</span><br>zrank <span class="hljs-operator">&lt;</span>key<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/32b9fe8c20e1">https://www.jianshu.com/p/32b9fe8c20e1</a></p><p>有关Bitmap、HyperLogLog和Geospatial等数据类型，这里暂时不做介绍，感兴趣可以自行了解。</p><hr><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>我们知道，Redis数据库中的数据都是存放在内存中，虽然很高效，但是这样存在一个非常严重的问题，如果突然停电，那我们的数据不就全部丢失了吗？它不像硬盘上的数据，断电依然能够保存。</p><p>这个时候我们就需要持久化，我们需要将我们的数据备份到硬盘上，防止断电或是机器故障导致的数据丢失。</p><p>持久化的实现方式有两种方案：一种是直接保存当前<strong>已经存储的数据</strong>，相当于复制内存中的数据到硬盘上，需要恢复数据时直接读取即可；还有一种就是保存我们存放数据的<strong>所有过程</strong>，需要恢复数据时，只需要将整个过程完整地重演一遍就能保证与之前数据库中的内容一致。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB就是我们所说的第一种解决方案，那么如何将数据保存到本地呢？我们可以使用命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">save<br><span class="hljs-comment">-- 注意上面这个命令是直接保存，会占用一定的时间，也可以单独开一个子进程后台执行保存</span><br>bgsave<br></code></pre></td></tr></table></figure><p>执行后，会在服务端目录下生成一个dump.rdb文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。保存后我们可以关闭服务器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">shutdown<br></code></pre></td></tr></table></figure><p>重启后可以看到数据依然存在。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fqqe2.com%2Fjava%2Fzb_users%2Fupload%2F2020%2F04%2F202004281588086055367603.png&refer=http%3A%2F%2Fqqe2.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644843952&t=ec4cd6eb2c6d47a10aff5b9f264d2f16" alt="点击查看图片来源"></p><p>虽然这种方式非常方便，但是由于会完整复制所有的数据，如果数据库中的数据量比较大，那么复制一次可能就需要花费大量的时间，所以我们可以每隔一段时间自动进行保存；还有就是，如果我们基本上都是在进行读操作，而没有进行写操作，实际上只需要偶尔保存一次即可，因为数据几乎没有怎么变化，可能两次保存的都是一样的数据。</p><p>我们可以在配置文件中设置自动保存，并设定在一段时间内写入多少数据时，执行一次保存操作：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span> # <span class="hljs-number">300</span>秒（<span class="hljs-number">5</span>分钟）内有<span class="hljs-number">10</span>个写入<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span> # <span class="hljs-number">60</span>秒（<span class="hljs-number">1</span>分钟）内有<span class="hljs-number">10000</span>个写入<br></code></pre></td></tr></table></figure><p>配置的save使用的都是bgsave后台执行。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>虽然RDB能够很好地解决数据持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它并不是实时保存的，如果在自动保存触发之前服务器崩溃，那么依然会导致少量数据的丢失。</p><p>而AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过这种重演的方式将数据恢复，这样就能很好解决实时性存储问题。</p><p><img src="https://qqe2.com/java/zb_users/upload/2020/04/202004281588086068660716.png" alt="rdb和aof区别"></p><p>但是，我们多久写一次日志呢？我们可以自己配置保存策略，有三种策略：</p><ul><li>always：每次执行写操作都会保存一次</li><li>everysec：每秒保存一次（默认配置），这样就算丢失数据也只会丢一秒以内的数据</li><li>no：看系统心情保存</li></ul><p>可以在配置文件中配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 注意得改成也是<br>appendonly yes<br><br># appendfsync always<br>appendfsync everysec<br># appendfsync <span class="hljs-keyword">no</span><br></code></pre></td></tr></table></figure><p>重启服务器后，可以看到服务器目录下多了一个<code>appendonly.aof</code>文件，存储的就是我们执行的命令。</p><p> AOF的缺点也很明显，每次服务器启动都需要进行过程重演，相比RDB更加耗费时间，并且随着我们的操作变多，不断累计，可能到最后我们的aof文件会变得无比巨大，我们需要一个改进方案来优化这些问题。</p><p>Redis有一个AOF重写机制进行优化，比如我们执行了这样的语句：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lpush</span> test <span class="hljs-number">666</span><br><span class="hljs-attribute">lpush</span> test <span class="hljs-number">777</span><br><span class="hljs-attribute">lpush</span> test <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>实际上用一条语句也可以实现：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lpush</span> test <span class="hljs-number">666</span> <span class="hljs-number">777</span> <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><p>正是如此，只要我们能够保证最终的重演结果和原有语句的结果一致，无论语句如何修改都可以，所以我们可以通过这种方式将多条语句进行压缩。</p><p>我们可以输入命令来手动执行重写操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">bgrewriteaof<br></code></pre></td></tr></table></figure><p>或是在配置文件中配置自动重写：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 百分比计算，这里不多介绍</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-comment"># 当达到这个大小时，触发自动重写</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb<br></code></pre></td></tr></table></figure><p>至此，我们就完成了两种持久化方案的介绍，最后我们再来进行一下总结：</p><ul><li>AOF：<ul><li>优点：存储速度快、消耗资源少、支持实时存储</li><li>缺点：加载速度慢、数据体积大</li></ul></li><li>RDB：<ul><li>优点：加载速度快、数据体积小</li><li>缺点：存储速度慢大量消耗资源、会发生数据丢失</li></ul></li></ul><hr><h2 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h2><p>和MySQL一样，在Redis中也有事务机制，当我们需要保证多条命令一次性完整执行而中途不受到其他命令干扰时，就可以使用事务机制。</p><p>我们可以使用命令来直接开启事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">multi<br></code></pre></td></tr></table></figure><p>当我们输入完所有要执行的命令时，可以使用命令来立即执行事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">exec</span><br></code></pre></td></tr></table></figure><p>我们也可以中途取消事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">discard<br></code></pre></td></tr></table></figure><p>实际上整个事务是创建了一个命令队列，它不像MySQL那种在事务中也能单独得到结果，而是我们提前将所有的命令装在队列中，但是并不会执行，而是等我们提交事务的时候再统一执行。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>又提到锁了，实际上这个概念对我们来说已经不算是陌生了。实际上在Redis中也会出现多个命令同时竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。</p><p>虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁，那么什么是乐观锁什么是悲观锁呢？</p><ul><li>悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质。</li><li>乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其他人抢占资源。</li></ul><p>Redis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">watch<br></code></pre></td></tr></table></figure><p>我们可以开两个客户端进行测试。</p><p>取消监视可以使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unwatch<br></code></pre></td></tr></table></figure><p>至此，Redis的基础内容就讲解完毕了，在之后的SpringCloud阶段，我们还会去讲解集群相关的知识，包括主从复制、哨兵模式等。</p><hr><h2 id="使用Java与Redis交互"><a href="#使用Java与Redis交互" class="headerlink" title="使用Java与Redis交互"></a>使用Java与Redis交互</h2><p>既然了解了如何通过命令窗口操作Redis数据库，那么我们如何使用Java来操作呢？</p><p>这里我们需要使用到Jedis框架，它能够实现Java与Redis数据库的交互，依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p>我们来看看如何连接Redis数据库，非常简单，只需要创建一个对象即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//创建Jedis对象</span><br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>);<br>  <br>  <span class="hljs-comment">//使用之后关闭连接</span><br>  jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Jedis对象，我们就可以直接调用命令的同名方法来执行Redis命令了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//直接使用try-with-resouse，省去close</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.set(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//等同于 set test lbwnb 命令</span><br>        System.out.println(jedis.get(<span class="hljs-string">&quot;test&quot;</span>));  <span class="hljs-comment">//等同于 get test 命令</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Hash类型的数据也是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.hset(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;sxc&quot;</span>);   <span class="hljs-comment">//等同于 hset hhh name sxc</span><br>        jedis.hset(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;19&quot;</span>);    <span class="hljs-comment">//等同于 hset hhh age 19</span><br>        jedis.hgetAll(<span class="hljs-string">&quot;hhh&quot;</span>).forEach((k, v) -&gt; System.out.println(k+<span class="hljs-string">&quot;: &quot;</span>+v));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看看列表操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.10.3&quot;</span>, <span class="hljs-number">6379</span>))&#123;<br>        jedis.lpush(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>);  <span class="hljs-comment">//等同于 lpush mylist 111 222 333 命令</span><br>        jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br>                .forEach(System.out::println);    <span class="hljs-comment">//等同于 lrange mylist 0 -1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上我们只需要按照对应的操作去调用同名方法即可，所有的类型封装Jedis已经帮助我们完成了。</p><h3 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h3><p>我们接着来看如何在SpringBoot项目中整合Redis操作框架，只需要一个starter即可，但是它底层没有用Jedis，而是Lettuce：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>starter提供的默认配置会去连接本地的Redis服务器，并使用0号数据库，当然你也可以手动进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>  <span class="hljs-comment">#Redis服务器地址</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.3</span><br>    <span class="hljs-comment">#端口</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-comment">#使用几号数据库</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>starter已经给我们提供了两个默认的模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(</span><br><span class="hljs-meta">    proxyBeanMethods = false</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span><br><span class="hljs-meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisAutoConfiguration</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisAutoConfiguration</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>();<br>        template.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>    <span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title function_">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisTemplate</span>(redisConnectionFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如何去使用这两个模板类呢？我们可以直接注入<code>StringRedisTemplate</code>来使用模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootTestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StringRedisTemplate template;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        ValueOperations&lt;String, String&gt; operations = template.opsForValue();<br>        operations.set(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);   <span class="hljs-comment">//设置值</span><br>        System.out.println(operations.get(<span class="hljs-string">&quot;c&quot;</span>));   <span class="hljs-comment">//获取值</span><br>      <br>        template.delete(<span class="hljs-string">&quot;c&quot;</span>);    <span class="hljs-comment">//删除键</span><br>        System.out.println(template.hasKey(<span class="hljs-string">&quot;c&quot;</span>));   <span class="hljs-comment">//判断是否包含键</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上所有的值的操作都被封装到了<code>ValueOperations</code>对象中，而普通的键操作直接通过模板对象就可以使用了，大致使用方式其实和Jedis一致。</p><p>我们接着来看看事务操作，由于Spring没有专门的Redis事务管理器，所以只能借用JDBC提供的，只不过无所谓，正常情况下反正我们也要用到这玩意：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    StringRedisTemplate template;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        template.setEnableTransactionSupport(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//需要开启事务</span><br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-comment">//需要添加此注解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        template.multi();<br>        template.opsForValue().set(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);<br>        template.exec();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以为RedisTemplate对象配置一个Serializer来实现对象的JSON存储：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoad2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//注意Student需要实现序列化接口才能存入Redis</span><br>    template.opsForValue().set(<span class="hljs-string">&quot;student&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>());<br>    System.out.println(template.opsForValue().get(<span class="hljs-string">&quot;student&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="使用Redis做缓存"><a href="#使用Redis做缓存" class="headerlink" title="使用Redis做缓存"></a>使用Redis做缓存</h2><p>我们可以轻松地使用Redis来实现一些框架的缓存和其他存储。</p><h3 id="Mybatis二级缓存"><a href="#Mybatis二级缓存" class="headerlink" title="Mybatis二级缓存"></a>Mybatis二级缓存</h3><p>还记得我们在学习Mybatis讲解的缓存机制吗，我们当时介绍了二级缓存，它是Mapper级别的缓存，能够作用与所有会话。但是当时我们提出了一个问题，由于Mybatis的默认二级缓存只能是单机的，如果存在多台服务器访问同一个数据库，实际上二级缓存只会在各自的服务器上生效，但是我们希望的是多台服务器都能使用同一个二级缓存，这样就不会造成过多的资源浪费。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5afd7713f9a97615dc3a0b1d3bc7db27.png" alt="img"></p><p>我们可以将Redis作为Mybatis的二级缓存，这样就能实现多台服务器使用同一个二级缓存，因为它们只需要连接同一个Redis服务器即可，所有的缓存数据全部存储在Redis服务器上。我们需要手动实现Mybatis提供的Cache接口，这里我们简单编写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现Mybatis的Cache接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisMybatisCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cache</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RedisTemplate&lt;Object, Object&gt; template;<br><br>   <span class="hljs-comment">//注意构造方法必须带一个String类型的参数接收id</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisMybatisCache</span><span class="hljs-params">(String id)</span>&#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>  <span class="hljs-comment">//初始化时通过配置类将RedisTemplate给过来</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTemplate</span><span class="hljs-params">(RedisTemplate&lt;Object, Object&gt; template)</span> &#123;<br>        RedisMybatisCache.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object o, Object o1)</span> &#123;<br>      <span class="hljs-comment">//这里直接向Redis数据库中丢数据即可，o就是Key，o1就是Value，60秒为过期时间</span><br>        template.opsForValue().set(o, o1, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object o)</span> &#123;<br>      <span class="hljs-comment">//这里根据Key直接从Redis数据库中获取值即可</span><br>        <span class="hljs-keyword">return</span> template.opsForValue().get(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">removeObject</span><span class="hljs-params">(Object o)</span> &#123;<br>      <span class="hljs-comment">//根据Key删除</span><br>        <span class="hljs-keyword">return</span> template.delete(o);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//由于template中没封装清除操作，只能通过connection来执行</span><br>template.execute((RedisCallback&lt;Void&gt;) connection -&gt; &#123;<br>          <span class="hljs-comment">//通过connection对象执行清空操作</span><br>            connection.flushDb();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//这里也是使用connection对象来获取当前的Key数量</span><br>        <span class="hljs-keyword">return</span> template.execute(RedisServerCommands::dbSize).intValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缓存类编写完成后，我们接着来编写配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    RedisTemplate&lt;Object, Object&gt; template;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//把RedisTemplate给到RedisMybatisCache</span><br>        RedisMybatisCache.setTemplate(template);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们在Mapper上启用此缓存即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只需要修改缓存实现类implementation为我们的RedisMybatisCache即可</span><br><span class="hljs-meta">@CacheNamespace(implementation = RedisMybatisCache.class)</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MainMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select name from student where sid = 1&quot;)</span><br>    String <span class="hljs-title function_">getSid</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们提供一个测试用例来查看当前的二级缓存是否生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootTestApplicationTests</span> &#123;<br><br><br>    <span class="hljs-meta">@Resource</span><br>    MainMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(mapper.getSid());<br>        System.out.println(mapper.getSid());<br>        System.out.println(mapper.getSid());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>手动使用客户端查看Redis数据库，可以看到已经有一条Mybatis生成的缓存数据了。</p><h3 id="Token持久化存储"><a href="#Token持久化存储" class="headerlink" title="Token持久化存储"></a>Token持久化存储</h3><p>我们之前使用SpringSecurity时，remember-me的Token是支持持久化存储的，而我们当时是存储在数据库中，那么Token信息能否存储在缓存中呢，当然也是可以的，我们可以手动实现一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现PersistentTokenRepository接口</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTokenRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PersistentTokenRepository</span> &#123;<br>  <span class="hljs-comment">//Key名称前缀，用于区分</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">REMEMBER_ME_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring:security:rememberMe:&quot;</span>;<br>    <span class="hljs-meta">@Resource</span><br>    RedisTemplate&lt;Object, Object&gt; template;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createNewToken</span><span class="hljs-params">(PersistentRememberMeToken token)</span> &#123;<br>      <span class="hljs-comment">//这里要放两个，一个存seriesId-&gt;Token，一个存username-&gt;seriesId，因为删除时是通过username删除</span><br>        template.opsForValue().set(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+token.getUsername(), token.getSeries());<br>        template.expire(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+token.getUsername(), <span class="hljs-number">1</span>, TimeUnit.DAYS);<br>        <span class="hljs-built_in">this</span>.setToken(token);<br>    &#125;<br><br>  <span class="hljs-comment">//先获取，然后修改创建一个新的，再放入</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateToken</span><span class="hljs-params">(String series, String tokenValue, Date lastUsed)</span> &#123;<br>        <span class="hljs-type">PersistentRememberMeToken</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getToken(series);<br>        <span class="hljs-keyword">if</span>(token != <span class="hljs-literal">null</span>)<br>           <span class="hljs-built_in">this</span>.setToken(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PersistentRememberMeToken</span>(token.getUsername(), series, tokenValue, lastUsed));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PersistentRememberMeToken <span class="hljs-title function_">getTokenForSeries</span><span class="hljs-params">(String seriesId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getToken(seriesId);<br>    &#125;<br><br>  <span class="hljs-comment">//通过username找seriesId直接删除这两个</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeUserTokens</span><span class="hljs-params">(String username)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">series</span> <span class="hljs-operator">=</span> (String) template.opsForValue().get(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+username);<br>        template.delete(REMEMBER_ME_KEY+series);<br>        template.delete(REMEMBER_ME_KEY+<span class="hljs-string">&quot;username:&quot;</span>+username);<br>    &#125;<br><br>  <br>  <span class="hljs-comment">//由于PersistentRememberMeToken没实现序列化接口，这里只能用Hash来存储了，所以单独编写一个set和get操作</span><br>    <span class="hljs-keyword">private</span> PersistentRememberMeToken <span class="hljs-title function_">getToken</span><span class="hljs-params">(String series)</span>&#123;<br>        Map&lt;Object, Object&gt; map = template.opsForHash().entries(REMEMBER_ME_KEY+series);<br>        <span class="hljs-keyword">if</span>(map.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersistentRememberMeToken</span>(<br>                (String) map.get(<span class="hljs-string">&quot;username&quot;</span>),<br>                (String) map.get(<span class="hljs-string">&quot;series&quot;</span>),<br>                (String) map.get(<span class="hljs-string">&quot;tokenValue&quot;</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(Long.parseLong((String) map.get(<span class="hljs-string">&quot;date&quot;</span>))));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setToken</span><span class="hljs-params">(PersistentRememberMeToken token)</span>&#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;username&quot;</span>, token.getUsername());<br>        map.put(<span class="hljs-string">&quot;series&quot;</span>, token.getSeries());<br>        map.put(<span class="hljs-string">&quot;tokenValue&quot;</span>, token.getTokenValue());<br>        map.put(<span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;&quot;</span>+token.getDate().getTime());<br>        template.opsForHash().putAll(REMEMBER_ME_KEY+token.getSeries(), map);<br>        template.expire(REMEMBER_ME_KEY+token.getSeries(), <span class="hljs-number">1</span>, TimeUnit.DAYS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着把验证Service实现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> mapper.getAccountByUsername(username);<br>        <span class="hljs-keyword">if</span>(account == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> User<br>                .withUsername(username)<br>                .password(account.getPassword())<br>                .roles(account.getRole())<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mapper也安排上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String username;<br>    String password;<br>    String role;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheNamespace(implementation = MybatisRedisCache.class)</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)</span><br>    Account <span class="hljs-title function_">getAccountByUsername</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后配置文件配一波：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    http<br>            .authorizeRequests()<br>            .anyRequest().authenticated()<br>            .and()<br>            .formLogin()<br>            .and()<br>            .rememberMe()<br>            .tokenRepository(repository);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth<br>            .userDetailsService(service)<br>            .passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，启动服务器验证一下吧。</p><hr><h2 id="三大缓存问题"><a href="#三大缓存问题" class="headerlink" title="三大缓存问题"></a>三大缓存问题</h2><p><strong>注意：</strong>这部分内容作为选学内容。</p><p>虽然我们可以利用缓存来大幅度提升我们程序的数据获取效率，但是使用缓存也存在着一些潜在的问题。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><img src="https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/springboot-cache-redis-1004.png?x-oss-process=style/shuiyin" alt="img"></p><p>当我们去查询一个一定不存在的数据，比如Mybatis在缓存是未命中的情况下需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>这显然是很浪费资源的，我们希望的是，如果这个数据不存在，为什么缓存这一层不直接返回空呢，这时就不必再去查数据库了，但是也有一个问题，缓存不去查数据库怎么知道数据库里面到底有没有这个数据呢？</p><p>这时我们就可以使用布隆过滤器来进行判断。什么是布隆过滤器？（当然不是打辅助的那个布隆，只不过也挺像，辅助布隆也是挡子弹的）</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.bubuko.com%2Finfo%2F201903%2F20190321142642446276.png&refer=http%3A%2F%2Fimage.bubuko.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644902390&t=4f0440b0357965ead1fa34fb27513927" alt="点击查看图片来源"></p><p>使用布隆过滤器，能够告诉你某样东西一定不存在或是某样东西可能存在。</p><p>布隆过滤器本质是一个存放二进制位的bit数组，如果我们要添加一个值到布隆过滤器中，我们需要使用N个不同的哈希函数来生成N个哈希值，并对每个生成的哈希值指向的bit位置1，如上图所示，一共添加了三个值abc。</p><p>接着我们给一个d，那么这时就可以进行判断，如果说d计算的N个哈希值的位置上都是1，那么就说明d可能存在；这时候又来了个e，计算后我们发现有一个位置上的值是0，这时就可以直接断定e一定不存在。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><img src="https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/springboot-cache-redis-1005.png?x-oss-process=style/shuiyin" alt="img"></p><p>某个 Key 属于热点数据，访问非常频繁，同一时间很多人都在访问，在这个Key失效的瞬间，大量的请求到来，这时发现缓存中没有数据，就全都直接请求数据库，相当于击穿了缓存屏障，直接攻击整个系统核心。</p><p>这种情况下，最好的解决办法就是不让Key那么快过期，如果一个Key处于高频访问，那么可以适当地延长过期时间。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><img src="https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/springboot-cache-redis-1006.png?x-oss-process=style/shuiyin" alt="img"></p><p>当你的Redis服务器炸了或是大量的Key在同一时间过期，这时相当于缓存直接GG了，那么如果这时又有很多的请求来访问不同的数据，同一时间内缓存服务器就得向数据库大量发起请求来重新建立缓存，很容易把数据库也搞GG。</p><p>解决这种问题最好的办法就是设置高可用，也就是搭建Redis集群，当然也可以采取一些服务熔断降级机制，这些内容我们会在SpringCloud阶段再进行探讨。</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot</title>
    <link href="/2022/10/02/Springboot/"/>
    <url>/2022/10/02/Springboot/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F174788b2ec1d828d85a0a7ac65bea2cd.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644064714&t=46bead84c9b2fb6e0b65fd4afdaf805e" alt="点击查看源网页"></p><h1 id="SpringBoot一站式开发"><a href="#SpringBoot一站式开发" class="headerlink" title="SpringBoot一站式开发"></a>SpringBoot一站式开发</h1><p>官网：<a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p><blockquote><p>Spring Boot可以轻松创建独立的、基于Spring的生产级应用程序，它可以让你“运行即可”。大多数Spring Boot应用程序只需要少量的Spring配置。</p></blockquote><p>SpringBoot功能：</p><ul><li>创建独立的Spring应用程序</li><li>直接嵌入Tomcat、Jetty或Undertow（无需部署WAR包，打包成Jar本身就是一个可以运行的应用程序）</li><li>提供一站式的“starter”依赖项，以简化Maven配置（需要整合什么框架，直接导对应框架的starter依赖）</li><li>尽可能自动配置Spring和第三方库（除非特殊情况，否则几乎不需要你进行什么配置）</li><li>提供生产就绪功能，如指标、运行状况检查和外部化配置</li><li>没有代码生成，也没有XML配置的要求（XML是什么，好吃吗）</li></ul><p>SpringBoot是现在最主流的开发框架，它提供了一站式的开发体验，大幅度提高了我们的开发效率。</p><h2 id="走进SpringBoot"><a href="#走进SpringBoot" class="headerlink" title="走进SpringBoot"></a>走进SpringBoot</h2><p>在SSM阶段，当我们需要搭建一个基于Spring全家桶的Web应用程序时，我们不得不做大量的依赖导入和框架整合相关的Bean定义，光是整合框架就花费了我们大量的时间，但是实际上我们发现，整合框架其实基本都是一些固定流程，我们每创建一个新的Web应用程序，基本都会使用同样的方式去整合框架，我们完全可以将一些重复的配置作为约定，只要框架遵守这个约定，为我们提供默认的配置就好，这样就不用我们再去配置了，约定优于配置！</p><p>而SpringBoot正是将这些过程大幅度进行了简化，它可以自动进行配置，我们只需要导入对应的启动器（starter）依赖即可。</p><p>完成本阶段的学习，基本能够胜任部分网站系统的后端开发工作，也建议同学们学习完SpringBoot之后寻找合适的队友去参加计算机项目相关的高校竞赛。</p><p>我们可以通过IDEA来演示如何快速创建一个SpringBoot项目，并且无需任何配置，就可以实现Bean注册。</p><h2 id="SpringBoot项目文件结构"><a href="#SpringBoot项目文件结构" class="headerlink" title="SpringBoot项目文件结构"></a>SpringBoot项目文件结构</h2><p>我们在创建SpringBoot项目之后，首先会自动生成一个主类，而主类中的<code>main</code>方法中调用了<code>SpringApplication</code>类的静态方法来启动整个SpringBoot项目，并且我们可以看到主类的上方有一个<code>@SpringBootApplication</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootTestApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootTestApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>同时还自带了一个测试类，测试类的上方仅添加了一个<code>@SpringBootTest</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootTestApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看Maven中写了哪些内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  父工程  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-study<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>SpringBootTest<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>SpringBootTest<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  spring-boot-starter SpringBoot核心启动器  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  spring-boot-starter-test SpringBoot测试模块启动器  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--  SpringBoot Maven插件，打包Jar都不用你操心了   --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了以上这些文件以外，我们的项目目录下还有：</p><ul><li>.gitignore  -  Git忽略名单，下一章我们会专门讲解Git版本控制。</li><li>application.properties   -    SpringBoot的配置文件，所有依赖的配置都在这里编写，但是一般情况下只需要配置必要项即可。</li></ul><hr><h2 id="整合Web相关框架"><a href="#整合Web相关框架" class="headerlink" title="整合Web相关框架"></a>整合Web相关框架</h2><p>我们来看一下，既然我们前面提到SpringBoot会内嵌一个Tomcat服务器，也就是说我们的Jar打包后，相当于就是一个可以直接运行的应用程序，我们来看一下如何创建一个SpringBootWeb项目。</p><p>这里我们演示使用IDEA来创建一个基于SpringBoot的Web应用程序。</p><h3 id="它是真的快"><a href="#它是真的快" class="headerlink" title="它是真的快"></a>它是真的快</h3><p>创建完成后，直接开启项目，我们就可以直接访问：<a href="http://localhost:8080/%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E4%BD%86%E6%98%AF%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E6%B2%A1%E6%9C%89%E7%BC%96%E5%86%99%E4%BB%BB%E4%BD%95%E7%9A%84%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%EF%BC%8C%E6%89%80%E4%BB%A5%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E3%80%82%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%97%A5%E5%BF%97%EF%BC%9A">http://localhost:8080/，我们可以看到，但是由于我们没有编写任何的请求映射，所以没有数据。我们可以来看看日志：</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.308</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> c<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.SpringBootWebTestApplication</span>   : Starting SpringBootWebTestApplication using Java <span class="hljs-number">1.8</span>.<span class="hljs-number">0</span>_312 on NagodeMacBook-Pro<span class="hljs-selector-class">.local</span> with PID <span class="hljs-number">853</span> (/Users/nagocoler/Downloads/SpringBootWebTest/target/classes started by nagocoler <span class="hljs-keyword">in</span> /Users/nagocoler/Downloads/SpringBootWebTest)<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.309</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> c<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.SpringBootWebTestApplication</span>   : No active profile set, falling back to default profiles: default<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.629</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.w</span><span class="hljs-selector-class">.embedded</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.TomcatWebServer</span>  : Tomcat initialized with <span class="hljs-built_in">port</span>(s): <span class="hljs-number">8080</span> (http)<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.632</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardService</span>   : Starting service <span class="hljs-selector-attr">[Tomcat]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.632</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardEngine</span>  : Starting Servlet engine: <span class="hljs-selector-attr">[Apache Tomcat/9.0.56]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.654</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-attr">[Tomcat]</span>.<span class="hljs-selector-attr">[localhost]</span>.<span class="hljs-selector-attr">[/]</span>       : Initializing Spring embedded WebApplicationContext<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.654</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> w<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.ServletWebServerApplicationContext</span> : Root WebApplicationContext: initialization completed <span class="hljs-keyword">in</span> <span class="hljs-number">325</span> ms<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.780</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.b</span><span class="hljs-selector-class">.w</span><span class="hljs-selector-class">.embedded</span><span class="hljs-selector-class">.tomcat</span><span class="hljs-selector-class">.TomcatWebServer</span>  : Tomcat started on <span class="hljs-built_in">port</span>(s): <span class="hljs-number">8080</span> (http) with context path <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">46.785</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[           main]</span> c<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.SpringBootWebTestApplication</span>   : Started SpringBootWebTestApplication <span class="hljs-keyword">in</span> <span class="hljs-number">0.62</span> seconds (JVM running <span class="hljs-keyword">for</span> <span class="hljs-number">0.999</span>)<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02.979</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> o<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-attr">[Tomcat]</span>.<span class="hljs-selector-attr">[localhost]</span>.<span class="hljs-selector-attr">[/]</span>       : Initializing Spring DispatcherServlet <span class="hljs-string">&#x27;dispatcherServlet&#x27;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02.979</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.DispatcherServlet</span>        : Initializing Servlet <span class="hljs-string">&#x27;dispatcherServlet&#x27;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">22</span>:<span class="hljs-number">18</span>:<span class="hljs-number">02.980</span>  INFO <span class="hljs-number">853</span> --- <span class="hljs-selector-attr">[nio-8080-exec-1]</span> o<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.DispatcherServlet</span>        : Completed initialization <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> ms<br></code></pre></td></tr></table></figure><p>我们可以看到，日志中除了最基本的SpringBoot启动日志以外，还新增了内嵌Web服务器（Tomcat）的启动日志，并且显示了当前Web服务器所开放的端口，并且自动帮助我们初始化了DispatcherServlet，但是我们只是创建了项目，导入了web相关的starter依赖，没有进行任何的配置，实际上它使用的是starter提供的默认配置进行初始化的。</p><p>由于SpringBoot是自动扫描的，因此我们直接创建一个Controller即可被加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainController</span> &#123;<br><br>  <span class="hljs-comment">//直接访问http://localhost:8080/index即可，不用加web应用程序名称了</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你好，欢迎访问主页！&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们几乎没有做任何配置，但是可以直接开始配置Controller，SpringBoot创建一个Web项目的速度就是这么快！</p><p>它还可以自动识别类型，如果我们返回的是一个对象类型的数据，那么它会自动转换为JSON数据格式，无需配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> sid;<br>    String name;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/student&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">student</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setName(<span class="hljs-string">&quot;小明&quot;</span>);<br>    student.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>    student.setSid(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> student;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后浏览器能够直接得到<code>application/json</code>的响应数据，就是这么方便。</p><h3 id="修改Web相关配置"><a href="#修改Web相关配置" class="headerlink" title="修改Web相关配置"></a>修改Web相关配置</h3><p>如果我们需要修改Web服务器的端口或是一些其他的内容，我们可以直接在<code>application.properties</code>中进行修改，它是整个SpringBoot的配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 修改端口为80</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">80</span><br></code></pre></td></tr></table></figure><p>我们还可以编写自定义的配置项，并在我们的项目中通过<code>@Value</code>直接注入：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">test.data</span>=<span class="hljs-string">100</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;test.data&#125;&quot;)</span><br>    <span class="hljs-type">int</span> data;<br></code></pre></td></tr></table></figure><p>通过这种方式，我们就可以更好地将一些需要频繁修改的配置项写在配置文件中，并通过注解方式去获取值。</p><p>配置文件除了使用<code>properties</code>格式以外，还有一种叫做<code>yaml</code>格式，它的语法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">一级目录:</span><br><span class="hljs-string">二级目录:</span><br>  <span class="hljs-string">三级目录1:</span> <span class="hljs-string">值</span><br>  <span class="hljs-string">三级目录2:</span> <span class="hljs-string">值</span><br>  <span class="hljs-string">三级目录List:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">元素1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">元素2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">元素3</span><br></code></pre></td></tr></table></figure><p>我们可以看到，每一级目录都是通过缩进（不能使用Tab，只能使用空格）区分，并且键和值之间需要添加冒号+空格来表示。</p><p>SpringBoot也支持这种格式的配置文件，我们可以将<code>application.properties</code>修改为<code>application.yml</code>或是<code>application.yaml</code>来使用YAML语法编写配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="整合SpringSecurity依赖"><a href="#整合SpringSecurity依赖" class="headerlink" title="整合SpringSecurity依赖"></a>整合SpringSecurity依赖</h3><p>我们接着来整合一下SpringSecurity依赖，继续感受SpringBoot带来的光速开发体验，只需要导入SpringSecurity的Starter依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入依赖后，我们直接启动SpringBoot应用程序，可以发现SpringSecurity已经生效了。</p><p>并且SpringSecurity会自动为我们生成一个默认用户<code>user</code>，它的密码会出现在日志中：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.329</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardService</span>   : Starting service <span class="hljs-selector-attr">[Tomcat]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.329</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.catalina</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.StandardEngine</span>  : Starting Servlet engine: <span class="hljs-selector-attr">[Apache Tomcat/9.0.56]</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.350</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> o<span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.C</span>.<span class="hljs-selector-attr">[Tomcat]</span>.<span class="hljs-selector-attr">[localhost]</span>.<span class="hljs-selector-attr">[/]</span>       : Initializing Spring embedded WebApplicationContext<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.351</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> w<span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.c</span><span class="hljs-selector-class">.ServletWebServerApplicationContext</span> : Root WebApplicationContext: initialization completed <span class="hljs-keyword">in</span> <span class="hljs-number">341</span> ms<br><span class="hljs-number">2022</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.469</span>  INFO <span class="hljs-number">2901</span> --- <span class="hljs-selector-attr">[           main]</span> <span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.s</span><span class="hljs-selector-class">.UserDetailsServiceAutoConfiguration</span> : <br><br>Using generated security password: ff24bee3-e1b7-<span class="hljs-number">4309</span>-<span class="hljs-number">9609</span>-d32618baf5cb<br><br></code></pre></td></tr></table></figure><p>其中<code>ff24bee3-e1b7-4309-9609-d32618baf5cb</code>就是随机生成的一个密码，我们可以使用此用户登录。</p><p>我们也可以在配置文件中直接配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">test</span>   <span class="hljs-comment"># 用户名</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>  <span class="hljs-comment"># 密码</span><br>      <span class="hljs-attr">roles:</span>   <span class="hljs-comment"># 角色</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">user</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">admin</span><br></code></pre></td></tr></table></figure><p>实际上这样的配置方式就是一个<code>inMemoryAuthentication</code>，只是我们可以直接配置而已。</p><p>当然，页面的控制和数据库验证我们还是需要提供<code>WebSecurityConfigurerAdapter</code>的实现类去完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http<br>                .authorizeRequests()<br>                .antMatchers(<span class="hljs-string">&quot;/login&quot;</span>).permitAll()<br>                .anyRequest().hasRole(<span class="hljs-string">&quot;user&quot;</span>)<br>                .and()<br>                .formLogin();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里不需要再添加<code>@EnableWebSecurity</code>了，因为starter依赖已经帮我们添加了。</p><p>使用了SpringBoot之后，我们发现，需要什么功能，只需要导入对应的starter依赖即可，甚至都不需要你去进行额外的配置，你只需要关注依赖本身的必要设置即可，大大提高了我们的开发效率。</p><hr><h2 id="整合Mybatis框架"><a href="#整合Mybatis框架" class="headerlink" title="整合Mybatis框架"></a>整合Mybatis框架</h2><p>我们接着来看如何整合Mybatis框架，同样的，我们只需要导入对应的starter依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入依赖后，直接启动会报错，是因为有必要的配置我们没有去编写，我们需要指定数据源的相关信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>再次启动，成功。</p><p>我们发现日志中会出现这样一句话：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">2022-01-07 12:32:09.106  WARN 6917 --- [           main] o.m.s.mapper.ClassPathMapperScanner     <span class="hljs-keyword"> :</span> No MyBatis mapper was found in &#x27;[com.example]&#x27; package. Please<span class="hljs-built_in"> check </span>your configuration.<br></code></pre></td></tr></table></figure><p>这是Mybatis自动扫描输出的语句，导入依赖后，我们不需要再去设置Mybatis的相关Bean了，也不需要添加任何<code>@MapperSacn</code>注解，因为starter已经帮助我们做了，它会自动扫描项目中添加了<code>@Mapper</code>注解的接口，直接将其注册为Bean，不需要进行任何配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MainMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)</span><br>    UserData <span class="hljs-title function_">findUserByName</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果你觉得每个接口都去加一个<code>@Mapper</code>比较麻烦的话也可以用回之前的方式，直接<code>@MapperScan</code>使用包扫描。</p><p>添加Mapper之后，使用方法和SSM阶段是一样的，我们可以将其与SpringSecurity结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserAuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    MainMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>        <span class="hljs-type">UserData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> mapper.findUserByName(username);<br>        <span class="hljs-keyword">if</span>(data == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;用户 &quot;</span>+username+<span class="hljs-string">&quot; 登录失败，用户名不存在！&quot;</span>);<br>        <span class="hljs-keyword">return</span> User<br>                .withUsername(data.getUsername())<br>                .password(data.getPassword())<br>                .roles(data.getRole())<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后配置一下自定义验证即可，注意这样之前配置文件里面配置的用户就失效了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth<br>            .userDetailsService(service)<br>            .passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>在首次使用时，我们发现日志中输出以以下语句：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">2022<span class="hljs-string">-01</span><span class="hljs-string">-07</span> 12:39:40.559  INFO 6930 --- [nio<span class="hljs-string">-8080</span>-exec<span class="hljs-string">-3</span>] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="hljs-string">-1</span> - Starting...<br>2022<span class="hljs-string">-01</span><span class="hljs-string">-07</span> 12:39:41.033  INFO 6930 --- [nio<span class="hljs-string">-8080</span>-exec<span class="hljs-string">-3</span>] com.zaxxer.hikari.HikariDataSource       : HikariPool<span class="hljs-string">-1</span> - Start completed.<br></code></pre></td></tr></table></figure><p>实际上，SpringBoot会自动为Mybatis配置数据源，默认使用的就是<code>HikariCP</code>数据源。</p><hr><h2 id="整合Thymeleaf框架"><a href="#整合Thymeleaf框架" class="headerlink" title="整合Thymeleaf框架"></a>整合Thymeleaf框架</h2><p>整合Thymeleaf也只需导入对应的starter即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们只需要直接使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是注意，这样只能正常解析HTML页面，但是js、css等静态资源我们需要进行路径指定，不然无法访问，我们在配文件中配置一下静态资源的访问前缀：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">mvc:</span><br>  <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string">/static/**</span><br></code></pre></td></tr></table></figure><p>接着我们像之前一样，把登陆页面实现一下吧。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">http://www.thymeleaf.org</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:sec</span>=<span class="hljs-string">http://www.thymeleaf.org/extras/spring-security</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>SpringBoot为我们提供了丰富的日志系统，它几乎是开箱即用的。</p><h3 id="日志门面和日志实现"><a href="#日志门面和日志实现" class="headerlink" title="日志门面和日志实现"></a>日志门面和日志实现</h3><p>我们首先要区分一下，什么是日志门面（Facade）什么是日志实现，我们之前学习的JUL实际上就是一种日志实现，我们可以直接使用JUL为我们提供的日志框架来规范化打印日志，而日志门面，如Slf4j，是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于它只是一个接口，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要通过接口绑定的具体的日志系统来实现，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。</p><p>日志门面和日志实现就像JDBC和数据库驱动一样，一个是画大饼的，一个是真的去做饼的。</p><p><img src="https://upload-images.jianshu.io/upload_images/2909474-b5127a18b3eda3ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/888" alt="img"></p><p>但是现在有一个问题就是，不同的框架可能使用了不同的日志框架，如果这个时候出现众多日志框架并存的情况，我们现在希望的是所有的框架一律使用日志门面（Slf4j）进行日志打印，这时该怎么去解决？我们不可能将其他框架依赖的日志框架替换掉，直接更换为Slf4j吧，这样显然不现实。</p><p>这时，可以采取类似于偷梁换柱的做法，只保留不同日志框架的接口和类定义等关键信息，而将实现全部定向为Slf4j调用。相当于有着和原有日志框架一样的外壳，对于其他框架来说依然可以使用对应的类进行操作，而具体如何执行，真正的内心已经是Slf4j的了。</p><p><img src="https://upload-images.jianshu.io/upload_images/2909474-512f5cca92e05e59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/928" alt="img"></p><p>所以，SpringBoot为了统一日志框架的使用，做了这些事情：</p><ul><li>直接将其他依赖以前的日志框架剔除</li><li>导入对应日志框架的Slf4j中间包</li><li>导入自己官方指定的日志实现，并作为Slf4j的日志实现层</li></ul><h3 id="在SpringBoot中打印日志信息"><a href="#在SpringBoot中打印日志信息" class="headerlink" title="在SpringBoot中打印日志信息"></a>在SpringBoot中打印日志信息</h3><p>SpringBoot使用的是Slf4j作为日志门面，Logback（<a href="http://logback.qos.ch/">Logback</a> 是log4j 框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J）作为日志实现，对应的依赖为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此依赖已经被包含了，所以我们如果需要打印日志，可以像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(MainController.class);<br>    logger.info(<span class="hljs-string">&quot;用户访问了一次登陆界面&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们使用了Lombok，所以直接一个注解也可以搞定哦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;用户访问了一次登陆界面&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，SpringBoot默认只会打印INFO以上级别的信息。</p><h3 id="配置Logback日志"><a href="#配置Logback日志" class="headerlink" title="配置Logback日志"></a>配置Logback日志</h3><p>Logback官网：<a href="https://logback.qos.ch/">https://logback.qos.ch</a></p><p>和JUL一样，Logback也能实现定制化，我们可以编写对应的配置文件，SpringBoot推荐将配置文件名称命名为<code>logback-spring.xml</code>表示这是SpringBoot下Logback专用的配置，可以使用SpringBoot 的高级Proﬁle功能，它的内容类似于这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最外层由<code>configuration</code>包裹，一旦编写，那么就会替换默认的配置，所以如果内部什么都不写的话，那么会导致我们的SpringBoot项目没有配置任何日志输出方式，控制台也不会打印日志。</p><p>我们接着来看如何配置一个控制台日志打印，我们可以直接导入并使用SpringBoot为我们预设好的日志格式，在<code>org/springframework/boot/logging/logback/defaults.xml</code>中已经帮我们把日志的输出格式定义好了，我们只需要设置对应的<code>appender</code>即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">included</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;clr&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wex&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wEx&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;</span> /&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_CHARSET&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; : %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_CHARSET&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.catalina.startup.DigesterFactory&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.catalina.util.LifecycleBase&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.sshd.common.util.SecurityUtils&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.net.NioSelectorPool&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.hibernate.validator.internal.util.Version&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.boot.actuate.endpoint.jmx&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">included</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入后，我们利用预设的日志格式创建一个控制台日志打印：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  导入其他配置文件，作为预设  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  Appender作为日志打印器配置，这里命名随意  --&gt;</span><br>    <span class="hljs-comment">&lt;!--  ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;CONSOLE_LOG_CHARSET&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置完成后，我们发现控制台已经可以正常打印日志信息了。</p><p>接着我们来看看如何开启文件打印，我们只需要配置一个对应的Appender即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;FILE_LOG_CHARSET&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  文件保存位置以及文件命名规则，这里用到了%d&#123;yyyy-MM-dd&#125;表示当前日期，%i表示这一天的第N个日志  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>log/%d&#123;yyyy-MM-dd&#125;-spring-%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  到期自动清理日志文件  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  最大日志保留时间  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  最大单个日志文件大小  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>10MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置完成后，我们可以看到日志文件也能自动生成了。</p><p>我们也可以魔改官方提供的日志格式，官方文档：<a href="https://logback.qos.ch/manual/layouts.html">https://logback.qos.ch/manual/layouts.html</a></p><p>这里需要提及的是MDC机制，Logback内置的日志字段还是比较少，如果我们需要打印有关业务的更多的内容，包括自定义的一些数据，需要借助logback MDC机制，MDC为“Mapped Diagnostic Context”（映射诊断上下文），即将一些运行时的上下文数据通过logback打印出来；此时我们需要借助org.sl4j.MDC类。</p><p>比如我们现在需要记录是哪个用户访问我们网站的日志，只要是此用户访问我们网站，都会在日志中携带该用户的ID，我们希望每条日志中都携带这样一段信息文本，而官方提供的字段无法实现此功能，这时就需要使用MDC机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//这里就用Session代替ID吧</span><br>        MDC.put(<span class="hljs-string">&quot;reqId&quot;</span>, request.getSession().getId());<br>        log.info(<span class="hljs-string">&quot;用户访问了一次登陆界面&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，我们就可以向日志中传入自定义参数了，我们日志中添加这样一个占位符<code>%X&#123;键值&#125;</code>，名字保持一致：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">%clr([%X&#123;reqId&#125;])&#123;faint&#125; <br></code></pre></td></tr></table></figure><p>这样当我们向MDC中添加信息后，只要是当前线程（本质是ThreadLocal实现）下输出的日志，都会自动替换占位符。</p><h3 id="自定义Banner"><a href="#自定义Banner" class="headerlink" title="自定义Banner"></a>自定义Banner</h3><p>我们在之前发现，实际上Banner部分和日志部分是独立的，SpringBoot启动后，会先打印Banner部分，那么这个Banner部分是否可以自定义呢？答案是可以的。</p><p>我们可以直接来配置文件所在目录下创建一个名为<code>banner.txt</code>的文本文档，内容随便你：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs txt">//                          _ooOoo_                               //<br>//                         o8888888o                              //<br>//                         88&quot; . &quot;88                              //<br>//                         (| ^_^ |)                              //<br>//                         O\  =  /O                              //<br>//                      ____/`---&#x27;\____                           //<br>//                    .&#x27;  \\|     |//  `.                         //<br>//                   /  \\|||  :  |||//  \                        //<br>//                  /  _||||| -:- |||||-  \                       //<br>//                  |   | \\\  -  /// |   |                       //<br>//                  | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |                       //<br>//                  \  .-\__  `-`  ___/-. /                       //<br>//                ___`. .&#x27;  /--.--\  `. . ___                     //<br>//              .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.                  //<br>//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //<br>//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //<br>//      ========`-.____`-.___\_____/___.-`____.-&#x27;========         //<br>//                           `=---=&#x27;                              //<br>//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //<br>//             佛祖保佑          永无BUG         永不修改             //<br></code></pre></td></tr></table></figure><p>可以使用在线生成网站进行生成自己的个性Banner：<a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a></p><p>我们甚至还可以使用颜色代码来为文本切换颜色：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$&#123;AnsiColor.BRIGHT_GREEN&#125;</span>  <span class="hljs-regexp">//</span>绿色<br></code></pre></td></tr></table></figure><p>也可以获取一些常用的变量信息：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-variable">$&#123;AnsiColor</span>.YELLOW&#125; 当前 Spring <span class="hljs-keyword">Boot</span> 版本：<span class="hljs-variable">$&#123;spring</span>-<span class="hljs-keyword">boot</span>.<span class="hljs-keyword">version</span>&#125;<br></code></pre></td></tr></table></figure><p>玩的开心！</p><hr><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>在日常开发中，我们项目会有多个环境。例如开发环境（develop）也就是我们研发过程中疯狂敲代码修BUG阶段，生产环境（production ）项目开发得差不多了，可以放在服务器上跑了。不同的环境下，可能我们的配置文件也存在不同，但是我们不可能切换环境的时候又去重新写一次配置文件，所以我们可以将多个环境的配置文件提前写好，进行自由切换。</p><p>由于SpringBoot只会读取<code>application.properties</code>或是<code>application.yml</code>文件，那么怎么才能实现自由切换呢？SpringBoot给我们提供了一种方式，我们可以通过配置文件指定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>接着我们分别创建两个环境的配置文件，<code>application-dev.yml</code>和<code>application-prod.yml</code>分别表示开发环境和生产环境的配置文件，比如开发环境我们使用的服务器端口为8080，而生产环境下可能就需要设置为80或是443端口，那么这个时候就需要不同环境下的配置文件进行区分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>这样我们就可以灵活切换生产环境和开发环境下的配置文件了。</p><p>SpringBoot自带的Logback日志系统也是支持多环境配置的，比如我们想在开发环境下输出日志到控制台，而生产环境下只需要输出到文件即可，这时就需要进行环境配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意<code>springProfile</code>是区分大小写的！</p><p>那如果我们希望生产环境中不要打包开发环境下的配置文件呢，我们目前虽然可以切换开发环境，但是打包的时候依然是所有配置文件全部打包，这样总感觉还欠缺一点完美，因此，打包的问题就只能找Maven解决了，Maven也可以设置多环境：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--分别设置开发，生产环境--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开发环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 生产环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着，我们需要根据环境的不同，排除其他环境的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-comment">&lt;!--排除配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--先排除所有的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据激活条件引入打包所需的配置和文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--引入所需环境的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--根据maven选择环境导入配置文件--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;environment&#125;.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着，我们可以直接将Maven中的<code>environment</code>属性，传递给SpringBoot的配置文件，在构建时替换为对应的值：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">&#x27;@environment@&#x27;</span>  <span class="hljs-comment">#注意YAML配置文件需要加单引号，否则会报错</span><br></code></pre></td></tr></table></figure><p>这样，根据我们Maven环境的切换，SpringBoot的配置文件也会进行对应的切换。</p><p>最后我们打开Maven栏目，就可以自由切换了，直接勾选即可，注意切换环境之后要重新加载一下Maven项目，不然不会生效！</p><hr><h2 id="打包运行"><a href="#打包运行" class="headerlink" title="打包运行"></a>打包运行</h2><p>现在我们的SpringBoot项目编写完成了，那么如何打包运行呢？非常简单，只需要点击Maven生命周期中的<code>package</code>即可，它会自动将其打包为可直接运行的Jar包，第一次打包可能会花费一些时间下载部分依赖的源码一起打包进Jar文件。</p><p>我们发现在打包的过程中还会完整的将项目跑一遍进行测试，如果我们不想测试直接打包，可以手动使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn package  -DskipTests<br></code></pre></td></tr></table></figure><p>打包后，我们会直接得到一个名为<code>springboot-study-0.0.1-SNAPSHOT.jar</code>的文件，这时在CMD窗口中输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar springboot-study-0.0.1-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p>输入后，可以看到我们的Java项目成功运行起来了，如果手动关闭窗口会导致整个项目终止运行。</p><hr><h2 id="再谈Spring框架"><a href="#再谈Spring框架" class="headerlink" title="再谈Spring框架"></a>再谈Spring框架</h2><p><strong>注意：</strong>开始本部分前，建议先完成SSM阶段的Spring源码讲解部分。</p><p>我们在SpringBoot阶段，需要继续扩充Spring框架的相关知识，来巩固和强化对于Spring框架的认识。</p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>为了执行某些任务，我们可能需要一些非常规的操作，比如我们希望使用多线程来处理我们的结果或是执行一些定时任务，到达指定时间再去执行。</p><p>这时我们首先想到的就是创建一个新的线程来处理，或是使用TimerTask来完成定时任务，但是我们有了Spring框架之后，就不用这样了，因为Spring框架为我们提供了更加便捷的方式进行任务调度。</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>需要使用Spring异步任务支持，我们需要在配置类上添加<code>@EnableAsync</code>或是在SpringBoot的启动类上添加也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootWebTestApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootWebTestApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们只需要在需要异步执行的方法上，添加<code>@Async</code>注解即可将此方法标记为异步，当此方法被调用时，会异步执行，也就是新开一个线程执行，不是在当前线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestService</span> &#123;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            System.out.println(<span class="hljs-string">&quot;我是异步任务！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>    service.test();<br>    System.out.println(<span class="hljs-string">&quot;我是同步任务！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这也是得益于AOP机制，通过线程池实现，但是也要注意，正是因为它是AOP机制的产物，所以它只能是在Bean中才会生效！</p><p>使用 @Async 注释的方法可以返回 ‘void’ 或 “Future” 类型，Future是一种用于接收任务执行结果的一种类型，我们会在Java并发编程中进行讲解，这里暂时不做介绍。</p><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>看完了异步任务，我们接着来看定时任务，定时任务其实就是指定在哪个时候再去执行，在JavaSE阶段我们使用过TimerTask来执行定时任务。</p><p>Spring中的定时任务是全局性质的，当我们的Spring程序启动后，那么定时任务也就跟着启动了，我们可以在配置类上添加<code>@EnableScheduling</code>或是在SpringBoot的启动类上添加也可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootWebTestApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringBootWebTestApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们可以创建一个定时任务配置类，在配置类里面编写定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduleConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Scheduled(fixedRate = 2000)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是定时任务！&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们注意到<code> @Scheduled</code>中有很多参数，我们需要指定’cron’, ‘fixedDelay(String)’, or ‘fixedRate(String)’的其中一个，否则无法创建定时任务，他们的区别如下：</p><ul><li>fixedDelay：在上一次定时任务执行完之后，间隔多久继续执行。</li><li>fixedRate：无论上一次定时任务有没有执行完成，两次任务之间的时间间隔。</li><li>cron：使用cron表达式来指定任务计划。</li></ul><p>这里重点讲解一下cron表达式：<a href="https://blog.csdn.net/sunnyzyq/article/details/98597252">https://blog.csdn.net/sunnyzyq/article/details/98597252</a></p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>监听器对我们来说也是一个比较陌生的概念，那么何谓监听呢？</p><p>监听实际上就是等待某个事件的触发，当事件触发时，对应事件的监听器就会被通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>        System.out.println(event.getApplicationContext());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过监听事件，我们就可以在对应的时机进行一些额外的处理，我们可以通过断点调试来查看一个事件是如何发生，以及如何通知监听器的。</p><p>通过阅读源码，我们得知，一个事件实际上就是通过<code>publishEvent</code>方法来进行发布的，我们也可以自定义我们自己项目中的事件，并注册对应的监听器进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> &#123;   <span class="hljs-comment">//需要继承ApplicationEvent</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestEvent</span><span class="hljs-params">(Object source)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;TestEvent&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(TestEvent event)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;自定义事件发生了：&quot;</span>+event.getSource());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>ApplicationContext context;<br><br><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>    context.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestEvent</span>(<span class="hljs-string">&quot;有人访问了登录界面！&quot;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就实现了自定义事件发布和监听。</p><h3 id="Aware系列接口"><a href="#Aware系列接口" class="headerlink" title="Aware系列接口"></a>Aware系列接口</h3><p>我们在之前讲解Spring源码时，经常会发现某些类的定义上，除了我们当时讲解的继承关系以外，还实现了一些接口，他们的名称基本都是<code>xxxxAware</code>，比如我们在讲解SpringSecurity的源码中，AbstractAuthenticationProcessingFilter类就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractAuthenticationProcessingFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericFilterBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationEventPublisherAware</span>, MessageSourceAware &#123;<br>    <span class="hljs-keyword">protected</span> ApplicationEventPublisher eventPublisher;<br>    <span class="hljs-keyword">protected</span> AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebAuthenticationDetailsSource</span>();<br>    <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;<br>    ...<br></code></pre></td></tr></table></figure><p>我们发现它除了继承自GenericFilterBean之外，还实现了ApplicationEventPublisherAware和MessageSourceAware接口，那么这些Aware接口到底是干嘛的呢？</p><p>Aware的中文意思为<strong>感知</strong>。简单来说，他就是一个标识，实现此接口的类会获得某些感知能力，Spring容器会在Bean被加载时，根据类实现的感知接口，会调用类中实现的对应感知方法。</p><p>比如AbstractAuthenticationProcessingFilter就实现了ApplicationEventPublisherAware接口，此接口的感知功能为事件发布器，在Bean加载时，会调用实现类中的<code>setApplicationEventPublisher</code>方法，而AbstractAuthenticationProcessingFilter类则利用此方法，在Bean加载阶段获得了容器的事件发布器，以便之后发布事件使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher eventPublisher)</span> &#123;<br>    <span class="hljs-built_in">this</span>.eventPublisher = eventPublisher;   <span class="hljs-comment">//直接存到成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SecurityContextHolder.createEmptyContext();<br>    context.setAuthentication(authResult);<br>    SecurityContextHolder.setContext(context);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.debug(LogMessage.format(<span class="hljs-string">&quot;Set SecurityContextHolder to %s&quot;</span>, authResult));<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.rememberMeServices.loginSuccess(request, response, authResult);<br>  <span class="hljs-comment">//在这里使用</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.eventPublisher != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.eventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InteractiveAuthenticationSuccessEvent</span>(authResult, <span class="hljs-built_in">this</span>.getClass()));<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.successHandler.onAuthenticationSuccess(request, response, authResult);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，除了ApplicationEventPublisherAware接口外，我们再来演示一个接口，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BeanNameAware就是感知Bean名称的一个接口，当Bean被加载时，会调用<code>setBeanName</code>方法并将Bean名称作为参数传递。</p><p>有关所有的Aware这里就不一一列举了。</p><hr><h2 id="探究SpringBoot实现原理"><a href="#探究SpringBoot实现原理" class="headerlink" title="探究SpringBoot实现原理"></a>探究SpringBoot实现原理</h2><p><strong>注意：</strong>难度较大，本版块作为选学内容，在开始前，必须完成SSM阶段源码解析部分的学习。</p><p>我们在前面的学习中切实感受到了SpringBoot为我们带来的便捷，那么它为何能够实现如此快捷的开发模式，starter又是一个怎样的存在，它是如何进行自动配置的，我们现在就开始研究。</p><h3 id="启动原理"><a href="#启动原理" class="headerlink" title="启动原理"></a>启动原理</h3><p>首先我们来看看，SpringBoot项目启动之后，做了什么事情，SpringApplication中的静态<code>run</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;<br>    <span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;primarySource&#125;, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>套娃如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(primarySources)).run(args);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，这里直接new了一个新的SpringApplication对象，传入我们的主类作为构造方法参数，并调用了非static的<code>run</code>方法，我们先来看看构造方法里面做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;<br>    ...<br>    <span class="hljs-built_in">this</span>.resourceLoader = resourceLoader;<br>    Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.primarySources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>(Arrays.asList(primarySources));<br>  <span class="hljs-comment">//这里是关键，这里会判断当前SpringBoot应用程序是否为Web项目，并返回当前的项目类型</span><br>  <span class="hljs-comment">//deduceFromClasspath是根据类路径下判断是否包含SpringBootWeb依赖，如果不包含就是NONE类型，包含就是SERVLET类型</span><br>    <span class="hljs-built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>    <span class="hljs-built_in">this</span>.bootstrapRegistryInitializers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-built_in">this</span>.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));<br>  <span class="hljs-comment">//创建所有ApplicationContextInitializer实现类的对象</span><br>    <span class="hljs-built_in">this</span>.setInitializers(<span class="hljs-built_in">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>    <span class="hljs-built_in">this</span>.setListeners(<span class="hljs-built_in">this</span>.getSpringFactoriesInstances(ApplicationListener.class));<br>    <span class="hljs-built_in">this</span>.mainApplicationClass = <span class="hljs-built_in">this</span>.deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>关键就在这里了，它是如何知道哪些类是ApplicationContextInitializer的实现类的呢？</p><p>这里就要提到spring.factories了，它是 Spring 仿造Java SPI实现的一种类加载机制。它在 META-INF&#x2F;spring.factories 文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是 Spring Boot Starter 实现的基础。</p><p>SPI的常见例子：</p><ul><li>数据库驱动加载接口实现类的加载：JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载：SLF4J加载不同提供商的日志实现类</li></ul><p>说白了就是人家定义接口，但是实现可能有很多种，但是核心只提供接口，需要我们按需选择对应的实现，这种方式是高度解耦的。</p><p>我们来看看<code>getSpringFactoriesInstances</code>方法做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="hljs-title function_">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;<br>  <span class="hljs-comment">//获取当前的类加载器</span><br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClassLoader();<br>  <span class="hljs-comment">//获取所有依赖中 META-INF/spring.factories 中配置的对应接口类的实现类列表</span><br>    Set&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>  <span class="hljs-comment">//根据上方列表，依次创建实例对象  </span><br>  List&lt;T&gt; instances = <span class="hljs-built_in">this</span>.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);<br>  <span class="hljs-comment">//根据对应类上的Order接口或是注解进行排序</span><br>    AnnotationAwareOrderComparator.sort(instances);<br>  <span class="hljs-comment">//返回实例</span><br>    <span class="hljs-keyword">return</span> instances;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>SpringFactoriesLoader.loadFactoryNames</code>正是读取配置的核心部分，我们后面还会遇到。</p><p>接着我们来看run方法里面做了什么事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    <span class="hljs-type">DefaultBootstrapContext</span> <span class="hljs-variable">bootstrapContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.createBootstrapContext();<br>    <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-built_in">this</span>.configureHeadlessProperty();<br>  <span class="hljs-comment">//获取所有的SpringApplicationRunListener，并通知启动事件，默认只有一个实现类EventPublishingRunListener</span><br>  <span class="hljs-comment">//EventPublishingRunListener会将初始化各个阶段的事件转发给所有监听器</span><br>    <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getRunListeners(args);<br>    listeners.starting(bootstrapContext, <span class="hljs-built_in">this</span>.mainApplicationClass);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//环境配置</span><br>        <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(args);<br>        <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>        <span class="hljs-built_in">this</span>.configureIgnoreBeanInfo(environment);<br>      <span class="hljs-comment">//打印Banner</span><br>        <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.printBanner(environment);<br>      <span class="hljs-comment">//创建ApplicationContext，注意这里会根据是否为Web容器使用不同的ApplicationContext实现类</span><br>        context = <span class="hljs-built_in">this</span>.createApplicationContext();<br>        context.setApplicationStartup(<span class="hljs-built_in">this</span>.applicationStartup);<br>      <span class="hljs-comment">//初始化ApplicationContext</span><br>        <span class="hljs-built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>      <span class="hljs-comment">//执行ApplicationContext的refresh方法</span><br>        <span class="hljs-built_in">this</span>.refreshContext(context);<br>        <span class="hljs-built_in">this</span>.afterRefresh(context, applicationArguments);<br>        <span class="hljs-type">Duration</span> <span class="hljs-variable">timeTakenToStartup</span> <span class="hljs-operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass)).logStarted(<span class="hljs-built_in">this</span>.getApplicationLog(), timeTakenToStartup);<br>        &#125;<br>        ....<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，实际上SpringBoot就是Spring的一层壳罢了，离不开最关键的ApplicationContext，也就是说，在启动后会自动配置一个ApplicationContext，只不过是进行了大量的扩展。</p><p>我们来看ApplicationContext是怎么来的，打开<code>createApplicationContext</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title function_">createApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.applicationContextFactory.create(<span class="hljs-built_in">this</span>.webApplicationType);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现在构造方法中<code>applicationContextFactory</code>直接使用的是DEFAULT：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.applicationContextFactory = ApplicationContextFactory.DEFAULT;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContextFactory</span> <span class="hljs-variable">DEFAULT</span> <span class="hljs-operator">=</span> (webApplicationType) -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">switch</span>(webApplicationType) &#123;<br>        <span class="hljs-keyword">case</span> SERVLET:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigServletWebServerApplicationContext</span>();<br>        <span class="hljs-keyword">case</span> REACTIVE:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigReactiveWebServerApplicationContext</span>();<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception var2) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unable create a default ApplicationContext instance, you may need a custom ApplicationContextFactory&quot;</span>, var2);<br>    &#125;<br>&#125;;<br><br>ConfigurableApplicationContext <span class="hljs-title function_">create</span><span class="hljs-params">(WebApplicationType webApplicationType)</span>;<br></code></pre></td></tr></table></figure><p>DEFAULT是直接编写的一个匿名内部类，其实已经很明确了，正是根据<code>webApplicationType</code>类型进行判断，如果是SERVLET，那么久返回专用于Web环境的AnnotationConfigServletWebServerApplicationContext对象（SpringBoot中新增的），否则返回普通的AnnotationConfigApplicationContext对象，也就是到这里为止，Spring的容器就基本已经确定了。</p><p>注意AnnotationConfigApplicationContext是Spring框架提供的类，从这里开始相当于我们在讲Spring的底层源码了，我们继续深入，AnnotationConfigApplicationContext对象在创建过程中会创建<code>AnnotatedBeanDefinitionReader</code>，它是用于通过注解解析Bean定义的工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StartupStep</span> <span class="hljs-variable">createAnnotatedBeanDefReader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getApplicationStartup().start(<span class="hljs-string">&quot;spring.context.annotated-bean-reader.create&quot;</span>);<br>    <span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedBeanDefinitionReader</span>(<span class="hljs-built_in">this</span>);<br>    createAnnotatedBeanDefReader.end();<br>    <span class="hljs-built_in">this</span>.scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathBeanDefinitionScanner</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotatedBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;<br>    ...<br>    <span class="hljs-comment">//这里会注册很多的后置处理器</span><br>    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-built_in">this</span>.registry);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title function_">registerAnnotationConfigProcessors</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> &#123;<br>    <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> unwrapDefaultListableBeanFactory(registry);<br>    ....<br>    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>(<span class="hljs-number">8</span>);<br>    RootBeanDefinition def;<br>    <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(<span class="hljs-string">&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;</span>)) &#123;<br>      <span class="hljs-comment">//注册了ConfigurationClassPostProcessor用于处理@Configuration、@Import等注解</span><br>      <span class="hljs-comment">//注意这里是关键，之后Selector还要讲到它</span><br>      <span class="hljs-comment">//它是继承自BeanDefinitionRegistryPostProcessor，所以它的执行时间在Bean定义加载完成后，Bean初始化之前</span><br>        def = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);<br>        def.setSource(source);<br>        beanDefs.add(registerPostProcessor(registry, def, <span class="hljs-string">&quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(<span class="hljs-string">&quot;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&quot;</span>)) &#123;<br>      <span class="hljs-comment">//AutowiredAnnotationBeanPostProcessor用于处理@Value等注解自动注入</span><br>        def = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(AutowiredAnnotationBeanPostProcessor.class);<br>        def.setSource(source);<br>        beanDefs.add(registerPostProcessor(registry, def, <span class="hljs-string">&quot;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&quot;</span>));<br>    &#125;<br>  <br>  ...<br></code></pre></td></tr></table></figure><p>回到SpringBoot，我们最后来看，<code>prepareContext</code>方法中又做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareContext</span><span class="hljs-params">(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;<br>  <span class="hljs-comment">//环境配置</span><br>    context.setEnvironment(environment);<br>    <span class="hljs-built_in">this</span>.postProcessApplicationContext(context);<br>    <span class="hljs-built_in">this</span>.applyInitializers(context);<br>    listeners.contextPrepared(context);<br>    bootstrapContext.close(context);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>        <span class="hljs-built_in">this</span>.logStartupInfo(context.getParent() == <span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.logStartupProfileInfo(context);<br>    &#125;<br><br>  <span class="hljs-comment">//将Banner注册为Bean</span><br>    <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> context.getBeanFactory();<br>    beanFactory.registerSingleton(<span class="hljs-string">&quot;springApplicationArguments&quot;</span>, applicationArguments);<br>    <span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-literal">null</span>) &#123;<br>        beanFactory.registerSingleton(<span class="hljs-string">&quot;springBootBanner&quot;</span>, printedBanner);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> AbstractAutowireCapableBeanFactory) &#123;<br>        ((AbstractAutowireCapableBeanFactory)beanFactory).setAllowCircularReferences(<span class="hljs-built_in">this</span>.allowCircularReferences);<br>        <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<br>            ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(<span class="hljs-built_in">this</span>.allowBeanDefinitionOverriding);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.lazyInitialization) &#123;<br>        context.addBeanFactoryPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyInitializationBeanFactoryPostProcessor</span>());<br>    &#125;<br><br>  <span class="hljs-comment">//这里会获取我们一开始传入的项目主类</span><br>    Set&lt;Object&gt; sources = <span class="hljs-built_in">this</span>.getAllSources();<br>    Assert.notEmpty(sources, <span class="hljs-string">&quot;Sources must not be empty&quot;</span>);<br>  <span class="hljs-comment">//这里会将我们的主类直接注册为Bean，这样就可以通过注解加载了</span><br>    <span class="hljs-built_in">this</span>.load(context, sources.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]));<br>    listeners.contextLoaded(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，在<code>prepareContext</code>执行完成之后，我们的主类成功完成Bean注册，接下来，就该类上注解大显身手了。</p><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p>既然主类已经在初始阶段注册为Bean，那么在加载时，就会根据注解定义，进行更多的额外操作。所以我们来看看主类上的<code>@SpringBootApplication</code>注解做了什么事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">), @Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br></code></pre></td></tr></table></figure><p>我们发现，<code>@SpringBootApplication</code>上添加了<code>@ComponentScan</code>注解，此注解我们此前已经认识过了，但是这里并没有配置具体扫描的包，因此它会自动将声明此接口的类所在的包作为basePackage，因此当添加<code>@SpringBootApplication</code>之后也就等于直接开启了自动扫描，但是一定注意不能在主类之外的包进行Bean定义，否则无法扫描到，需要手动配置。</p><p>接着我们来看第二个注解<code>@EnableAutoConfiguration</code>，它就是自动配置的核心了，我们来看看它是如何定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br></code></pre></td></tr></table></figure><p>老套路了，直接一手<code>@Import</code>，通过这种方式来将一些外部的Bean加载到容器中。我们来看看AutoConfigurationImportSelector做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeferredImportSelector</span>, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到它实现了很多接口，包括大量的Aware接口，实际上就是为了感知某些必要的对象，并将其存到当前类中。</p><p>其中最核心的是<code>DeferredImportSelector</code>接口，它是<code>ImportSelector</code>的子类，它定义了<code>selectImports</code>方法，用于返回需要加载的类名称，在Spring加载ImportSelector类型的Bean时，会调用此方法来获取更多需要加载的类，并将这些类一并注册为Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br>    String[] selectImports(AnnotationMetadata importingClassMetadata);<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">default</span> Predicate&lt;String&gt; <span class="hljs-title function_">getExclusionFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到目前为止，我们了解了两种使用<code>@Import</code>有特殊机制的接口：ImportSelector（这里用到的）和ImportBeanDefinitionRegistrar（之前Mybatis-spring源码有讲）当然还有普通的<code>@Configuration</code>配置类。</p><p>我们可以来阅读一下<code>ConfigurationClassPostProcessor</code>的源码，看看它到底是如何处理<code>@Import</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>  <span class="hljs-comment">//注意这个阶段仅仅是已经完成扫描了所有的Bean，得到了所有的BeanDefinition，但是还没有进行任何区分</span><br>  <span class="hljs-comment">//candidate是候选者的意思，一会会将标记了@Configuration的类作为ConfigurationClass加入到configCandidates中</span><br>    String[] candidateNames = registry.getBeanDefinitionNames();<br>    String[] var4 = candidateNames;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> candidateNames.length;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var6 &lt; var5; ++var6) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> var4[var6];<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDef</span> <span class="hljs-operator">=</span> registry.getBeanDefinition(beanName);<br>        <span class="hljs-keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-built_in">this</span>.metadataReaderFactory)) &#123;   <span class="hljs-comment">//判断是否添加了@Configuration注解</span><br>            configCandidates.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(beanDef, beanName));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!configCandidates.isEmpty()) &#123;<br>        <span class="hljs-comment">//...省略</span><br><br>      <span class="hljs-comment">//这里创建了一个ConfigurationClassParser用于解析配置类</span><br>        <span class="hljs-type">ConfigurationClassParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurationClassParser</span>(<span class="hljs-built_in">this</span>.metadataReaderFactory, <span class="hljs-built_in">this</span>.problemReporter, <span class="hljs-built_in">this</span>.environment, <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.componentScanBeanNameGenerator, registry);<br>      <span class="hljs-comment">//所有配置类的BeanDefinitionHolder列表</span><br>        Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>(configCandidates);<br>      <span class="hljs-comment">//已经解析完成的类</span><br>        <span class="hljs-type">HashSet</span> <span class="hljs-variable">alreadyParsed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>(configCandidates.size());<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">//这里省略，直到所有的配置类全部解析完成</span><br>          <span class="hljs-comment">//注意在循环过程中可能会由于@Import新增更多的待解析配置类，一律丢进candidates集合中</span><br>        &#125; <span class="hljs-keyword">while</span>(!candidates.isEmpty());<br><br>        ...<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看，<code>ConfigurationClassParser</code>是如何进行解析的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-comment">//@Conditional相关注解处理</span><br>  <span class="hljs-comment">//后面会讲</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;<br>        ...<br>        &#125;<br><br>        ConfigurationClassParser.<span class="hljs-type">SourceClass</span> <span class="hljs-variable">sourceClass</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.asSourceClass(configClass, filter);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>          <span class="hljs-comment">//核心</span><br>            sourceClass = <span class="hljs-built_in">this</span>.doProcessConfigurationClass(configClass, sourceClass, filter);<br>        &#125; <span class="hljs-keyword">while</span>(sourceClass != <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-built_in">this</span>.configurationClasses.put(configClass, configClass);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们再来看最核心的<code>doProcessConfigurationClass</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title function_">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span><br>    ...<br><br>    processImports(configClass, sourceClass, getImports(sourceClass), <span class="hljs-literal">true</span>);    <span class="hljs-comment">// 处理Import注解</span><br><br>...<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processImports</span><span class="hljs-params">(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, <span class="hljs-type">boolean</span> checkForCircularImports)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!importCandidates.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (checkForCircularImports &amp;&amp; <span class="hljs-built_in">this</span>.isChainedImportOnStack(configClass)) &#123;<br>            <span class="hljs-built_in">this</span>.problemReporter.error(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurationClassParser</span>.CircularImportProblem(configClass, <span class="hljs-built_in">this</span>.importStack));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.importStack.push(configClass);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Iterator</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> importCandidates.iterator();<br><br>                <span class="hljs-keyword">while</span>(var6.hasNext()) &#123;<br>                    ConfigurationClassParser.<span class="hljs-type">SourceClass</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> (ConfigurationClassParser.SourceClass)var6.next();<br>                    Class candidateClass;<br>                  <span class="hljs-comment">//如果是ImportSelector类型，继续进行运行</span><br>                    <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;<br>                        candidateClass = candidate.loadClass();<br>                        <span class="hljs-type">ImportSelector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> (ImportSelector)ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, <span class="hljs-built_in">this</span>.environment, <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.registry);<br>                        Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();<br>                        <span class="hljs-keyword">if</span> (selectorFilter != <span class="hljs-literal">null</span>) &#123;<br>                            exclusionFilter = exclusionFilter.or(selectorFilter);<br>                        &#125;<br><span class="hljs-comment">//如果是DeferredImportSelector的实现类，那么会走deferredImportSelectorHandler的handle方法</span><br>                        <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> DeferredImportSelector) &#123;<br>                            <span class="hljs-built_in">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector);<br>                          <span class="hljs-comment">//否则就按照正常的ImportSelector类型进行加载</span><br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                          <span class="hljs-comment">//调用selectImports方法获取所有需要加载的类</span><br>                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());<br>                            Collection&lt;ConfigurationClassParser.SourceClass&gt; importSourceClasses = <span class="hljs-built_in">this</span>.asSourceClasses(importClassNames, exclusionFilter);<br>                          <span class="hljs-comment">//递归处理，直到没有</span><br>                            <span class="hljs-built_in">this</span>.processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, <span class="hljs-literal">false</span>);<br>                        &#125;<br>                      <span class="hljs-comment">//判断是否为ImportBeanDefinitionRegistrar类型</span><br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;<br>                        candidateClass = candidate.loadClass();<br>                        <span class="hljs-type">ImportBeanDefinitionRegistrar</span> <span class="hljs-variable">registrar</span> <span class="hljs-operator">=</span> (ImportBeanDefinitionRegistrar)ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, <span class="hljs-built_in">this</span>.environment, <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.registry);<br>                      <span class="hljs-comment">//往configClass丢ImportBeanDefinitionRegistrar信息进去，之后再处理</span><br>                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());<br>                      <span class="hljs-comment">//否则按普通的配置类进行处理</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">this</span>.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());<br>                        <span class="hljs-built_in">this</span>.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException var17) &#123;<br>                <span class="hljs-keyword">throw</span> var17;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var18) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<span class="hljs-string">&quot;Failed to process import candidates for configuration class [&quot;</span> + configClass.getMetadata().getClassName() + <span class="hljs-string">&quot;]&quot;</span>, var18);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-built_in">this</span>.importStack.pop();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不难注意到，虽然这里额外处理了<code>ImportSelector</code>对象，但是还针对<code>ImportSelector</code>的子接口<code>DeferredImportSelector</code>进行了额外处理，Deferred是延迟的意思，它是一个延迟执行的<code>ImportSelector</code>，并不会立即进处理，而是丢进DeferredImportSelectorHandler，并且在<code>parse</code>方法的最后进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;<br>     ...<br><br>    <span class="hljs-built_in">this</span>.deferredImportSelectorHandler.process();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看<code>DeferredImportSelector</code>正好就有一个<code>process</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeferredImportSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">default</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DeferredImportSelector</span>.Group&gt; getImportGroup() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Group</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(AnnotationMetadata metadata, DeferredImportSelector selector)</span>;<br><br>        Iterable&lt;DeferredImportSelector.Group.Entry&gt; selectImports();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>          ...<br></code></pre></td></tr></table></figure><p>最后经过ConfigurationClassParser处理完成后，通过<code>parser.getConfigurationClasses()</code>就能得到通过配置类导入了哪些额外的配置类。最后将这些配置类全部注册BeanDefinition，然后就可以交给接下来的Bean初始化过程去处理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.reader.loadBeanDefinitions(configClasses);<br></code></pre></td></tr></table></figure><p>最后我们再去看<code>loadBeanDefinitions</code>是如何运行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> &#123;<br>    ConfigurationClassBeanDefinitionReader.<span class="hljs-type">TrackedConditionEvaluator</span> <span class="hljs-variable">trackedConditionEvaluator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurationClassBeanDefinitionReader</span>.TrackedConditionEvaluator();<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> configurationModel.iterator();<br><br>    <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>        <span class="hljs-type">ConfigurationClass</span> <span class="hljs-variable">configClass</span> <span class="hljs-operator">=</span> (ConfigurationClass)var3.next();<br>        <span class="hljs-built_in">this</span>.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitionsForConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;<br>    <span class="hljs-keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> configClass.getBeanName();<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-built_in">this</span>.registry.containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-built_in">this</span>.registry.removeBeanDefinition(beanName);<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (configClass.isImported()) &#123;<br>            <span class="hljs-built_in">this</span>.registerBeanDefinitionForImportedConfigurationClass(configClass);  <span class="hljs-comment">//注册配置类自己</span><br>        &#125;<br><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> configClass.getBeanMethods().iterator();<br><br>        <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>            <span class="hljs-type">BeanMethod</span> <span class="hljs-variable">beanMethod</span> <span class="hljs-operator">=</span> (BeanMethod)var3.next();<br>            <span class="hljs-built_in">this</span>.loadBeanDefinitionsForBeanMethod(beanMethod); <span class="hljs-comment">//注册@Bean注解标识的方法</span><br>        &#125;<br><br>      <span class="hljs-comment">//注册`@ImportResource`引入的XML配置文件中读取的bean定义</span><br>        <span class="hljs-built_in">this</span>.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());<br>      <span class="hljs-comment">//注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition</span><br>        <span class="hljs-built_in">this</span>.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，整个<code>@Configuration</code>配置类的底层配置流程我们就大致了解了。接着我们来看AutoConfigurationImportSelector是如何实现自动配置的，可以看到内部类AutoConfigurationGroup的process方法，它是父接口的实现，因为父接口是<code>DeferredImportSelector</code>，那么很容易得知，实际上最后会调用<code>process</code>方法获取所有的自动配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> &#123;<br>    Assert.state(deferredImportSelector <span class="hljs-keyword">instanceof</span> AutoConfigurationImportSelector, () -&gt; &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Only %s implementations are supported, got %s&quot;</span>, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName());<br>    &#125;);<br>  <span class="hljs-comment">//获取所有的Entry，其实就是，读取spring.factories来查看有哪些自动配置类</span><br>    AutoConfigurationImportSelector.<span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> ((AutoConfigurationImportSelector)deferredImportSelector).getAutoConfigurationEntry(annotationMetadata);<br>    <span class="hljs-built_in">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> autoConfigurationEntry.getConfigurations().iterator();<br><br>    <span class="hljs-keyword">while</span>(var4.hasNext()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">importClassName</span> <span class="hljs-operator">=</span> (String)var4.next();<br>        <span class="hljs-built_in">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看<code>getAutoConfigurationEntry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br>  <span class="hljs-comment">//判断是否开启了自动配置，是的，自动配置可以关</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//根据注解定义获取一些属性</span><br>        <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAttributes(annotationMetadata);<br>      <span class="hljs-comment">//得到spring.factories文件中所有需要自动配置的类</span><br>        List&lt;String&gt; configurations = <span class="hljs-built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>        ... 这里先看前半部分<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里并不是spring.factories文件中所有的自动配置类都会被加载，它会根据@Condition注解的条件进行加载。这样就能实现我们需要什么模块添加对应依赖就可以实现自动配置了。</p><p>所有的源码看不懂，都源自于你的心中没有形成一个完整的闭环！一旦一条线推到头，闭环形成，所有疑惑迎刃而解。</p><h3 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h3><p>我们仿照Mybatis来编写一个自己的starter，Mybatis的starter包含两个部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  starter本身只做依赖集中管理，不编写任何代码  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module.name</span>&gt;</span>org.mybatis.spring.boot.starter<span class="hljs-tag">&lt;/<span class="hljs-name">module.name</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  编写的专用配置模块   --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>因此我们也将我们自己的starter这样设计：</p><p>我们设计三个模块：</p><ul><li>spring-boot-hello：基础业务功能模块</li><li>spring-boot-starter-hello：启动器</li><li>spring-boot-autoconifgurer-hello：自动配置依赖</li></ul><p>首先是基础业务功能模块，这里我们随便创建一个类就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldService</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>启动器主要做依赖管理，这里就不写任何代码，只写pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigurer-hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入autoconfigurer模块作为依赖即可，接着我们去编写autoconfigurer模块，首先导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着创建一个HelloWorldAutoConfiguration作为自动配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span><br><span class="hljs-meta">@ConditionalOnClass(HelloWorldService.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(HelloWorldProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldAutoConfiguration</span> &#123;<br><br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-built_in">this</span>.getClass().getName());<br><br>    <span class="hljs-meta">@Resource</span><br>    HelloWorldProperties properties;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HelloWorldService <span class="hljs-title function_">helloWorldService</span><span class="hljs-params">()</span>&#123;<br>        logger.info(<span class="hljs-string">&quot;自定义starter项目已启动！&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;读取到自定义配置：&quot;</span>+properties.getValue());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloWorldService</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的配置读取类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;hello.world&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再编写<code>spring.factories</code>文件，并将我们的自动配置类添加即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">  com.hello.autoconfigurer.HelloWorldAutoConfiguration</span><br></code></pre></td></tr></table></figure><p>最后再Maven根项目执行<code>install</code>安装到本地仓库，完成。接着就可以在其他项目中使用我们编写的自定义starter了。</p><h3 id="Runner接口"><a href="#Runner接口" class="headerlink" title="Runner接口"></a>Runner接口</h3><p>在项目中，可能会遇到这样一个问题：我们需要在项目启动完成之后，紧接着执行一段代码。</p><p>我们可以编写自定义的ApplicationRunner来解决，它会在项目启动完成后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是自定义执行！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以使用CommandLineRunner，它也支持使用@Order或是实现Ordered接口来支持优先级执行。</p><p>实际上它就是run方法的最后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>    ....<br><br>        listeners.started(context, timeTakenToStartup);<br>  <span class="hljs-comment">//这里已经完成整个SpringBoot项目启动，所以执行所有的Runner</span><br>        <span class="hljs-built_in">this</span>.callRunners(context, applicationArguments);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var12) &#123;<br>        <span class="hljs-built_in">this</span>.handleRunFailure(context, var12, listeners);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(var12);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Duration</span> <span class="hljs-variable">timeTakenToReady</span> <span class="hljs-operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);<br>        listeners.ready(context, timeTakenToReady);<br>        <span class="hljs-keyword">return</span> context;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var11) &#123;<br>        <span class="hljs-built_in">this</span>.handleRunFailure(context, var11, (SpringApplicationRunListeners)<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(var11);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下一章，我们将继续讲解几乎程序员必会的Git版本控制。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/10/02/Git/"/>
    <url>/2022/10/02/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git版本控制"><a href="#Git版本控制" class="headerlink" title="Git版本控制"></a>Git版本控制</h1><p><strong>注意：</strong>开始学习之前，确保自己的网络可以畅通的连接Github：<a href="https://github.com,这个是一个国外网站,连起来特别卡,至于用什么方式实现流畅访问,懂的都懂./">https://github.com，这个是一个国外网站，连起来特别卡，至于用什么方式实现流畅访问，懂的都懂。</a></p><p>其实版本控制在我们的生活中无处不在，比如你的期末或是毕业答辩论文，由于你写得不规范或是老师不满意，你的老师可能会让你改了又改，于是就会出现下面这种情况：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20200417%2F1e63ac0f4d8442cb8c9ab1cb73f510c4.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644370473&t=fa8742db0b4f8db635ec003e37bca76c" alt="点击查看源网页"></p><p>我们手里的论文可能会经过多次版本迭代，最终我们会选取一个最好的版本作为最终提交的论文。使用版本控制不仅仅是为了去记录版本迭代历史，更是为了能够随时回退到之前的版本，实现时间回溯。同时，可能我们的论文是多个人一同完成，那么多个人如何去实现同步，如何保证每个人提交的更改都能够正常汇总，如何解决冲突，这些问题都需要一个优秀的版本控制系统来解决。</p><h2 id="走进Git"><a href="#走进Git" class="headerlink" title="走进Git"></a>走进Git</h2><p>我们开发的项目，也需要一个合适的版本控制系统来协助我们更好地管理版本迭代，而Git正是因此而诞生的（有关Git的历史，这里就不多做阐述了，感兴趣的小伙伴可以自行了解，是一位顶级大佬在一怒之下只花了2周时间用C语言开发的，之后的章节还会遇到他）</p><p>首先我们来了解一下Git是如何工作的：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F932856%2F202004%2F932856-20200423143251346-796113044.jpg&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644374894&t=7c2044128f7851ecd92de3c01f0187ca" alt="点击查看源网页"></p><p>可以看到，它大致分为4个板块：</p><ul><li>工作目录：存放我们正在写的代码（当我们新版本开发完成之后，就可以进行新版本的提交）</li><li>暂存区：暂时保存待提交的内容（新版本提交后会存放到本地仓库）</li><li>本地仓库：位于我们电脑上的一个版本控制仓库（存放的就是当前项目各个版本代码的增删信息）</li><li>远程仓库：位于服务器上的版本控制仓库（服务器上的版本信息可以由本地仓库推送上去，也可以从服务器抓取到本地仓库）</li></ul><p>它是一个分布式的控制系统，因此一般情况下我们每个人的电脑上都有一个本地仓库，由大家共同向远程仓库去推送版本迭代信息。</p><p>通过这一系列操作，我们就可以实现每开发完一个版本或是一个功能，就提交一次新版本，这样，我们就可以很好地控制项目的版本迭代，想回退到之前的版本随时都可以回退，想查看新版本添加或是删除了什么代码，随时都可以查看。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>首先请前往Git官网去下载最新的安装包：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>这手把手演示一下如何安装Git环境。</p><p>安装完成后，需要设定用户名和邮箱来区分不同的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;Your Name&quot;<br>git config --global user.email &quot;email@example.com&quot;<br></code></pre></td></tr></table></figure><h2 id="基本命令介绍"><a href="#基本命令介绍" class="headerlink" title="基本命令介绍"></a>基本命令介绍</h2><h3 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h3><p>我们可以将任意一个文件夹作为一个本地仓库，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure><p>输入后，会自动生成一个<code>.git</code>目录，注意这个目录是一个隐藏目录，而当前目录就是我们的工作目录。</p><p>创建成功后，我们可以查看一下当前的一个状态，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status<br></code></pre></td></tr></table></figure><p>如果已经成功配置为Git本地仓库，那么输入后可以看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">On branch master<br><br>No commits yet<br></code></pre></td></tr></table></figure><p>这表示我们还没有向仓库中提交任何内容，也就是一个空的状态。</p><h3 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h3><p>接着我们来看看，如何使用git来管理我们文档的版本，我们创建一个文本文档，随便写入一点内容，接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status<br></code></pre></td></tr></table></figure><p>我们会得到如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br>hello.txt<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p>其中Untracked files是未追踪文件的意思，也就是说，如果一个文件处于未追踪状态，那么git不会记录它的变化，始终将其当做一个新创建的文件，这里我们将其添加到暂存区，那么它会自动变为被追踪状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add hello.txt #也可以 add . 一次性添加目录下所有的<br></code></pre></td></tr></table></figure><p>再次查看当前状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Changes to be committed:<br>  (use <span class="hljs-string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)<br>new file:   hello.txt<br></code></pre></td></tr></table></figure><p>现在文件名称的颜色变成了绿色，并且是处于Changes to be committed下面，因此，我们的hello.txt现在已经被添加到暂存区了。</p><p>接着我们来尝试将其提交到Git本地仓库中，注意需要输入提交的描述以便后续查看，比如你这次提交修改了或是新增了哪些内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git commit -m <span class="hljs-string">&#x27;Hello World&#x27;</span><br></code></pre></td></tr></table></figure><p>接着我们可以查看我们的提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">log</span><br>git <span class="hljs-built_in">log</span> --graph<br></code></pre></td></tr></table></figure><p>我们还可以查看最近一次变更的详细内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git show [也可以加上commit ID查看指定的提交记录]<br></code></pre></td></tr></table></figure><p>再次查看当前状态，已经是清空状态了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><p>接着我们可以尝试修改一下我们的文本文档，由于当前文件已经是被追踪状态，那么git会去跟踪它的变化，如果说文件发生了修改，那么我们再次查看状态会得到下面的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>modified:   hello.txt<br></code></pre></td></tr></table></figure><p>也就是说现在此文件是处于已修改状态，我们如果修改好了，就可以提交我们的新版本到本地仓库中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git add .<br>git commit -m <span class="hljs-string">&#x27;Modify Text&#x27;</span><br></code></pre></td></tr></table></figure><p>接着我们来查询一下提交记录，可以看到一共有两次提交记录。</p><p>我们可以创建一个<code>.gitignore</code>文件来确定一个文件忽略列表，如果忽略列表中的文件存在且不是被追踪状态，那么git不会对其进行任何检查：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 这样就会匹配所有以txt结尾的文件</span><br><span class="hljs-string">*.txt</span><br><span class="hljs-comment"># 虽然上面排除了所有txt结尾的文件，但是这个不排除</span><br><span class="hljs-type">!666.txt</span><br><span class="hljs-comment"># 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略</span><br><span class="hljs-string">test/</span><br><span class="hljs-comment"># 目录中所有以txt结尾的文件，但不包括子目录</span><br><span class="hljs-string">xxx/*.txt</span><br><span class="hljs-comment"># 目录中所有以txt结尾的文件，包括子目录</span><br><span class="hljs-string">xxx/**/*.txt</span><br></code></pre></td></tr></table></figure><p>创建后，我们来看看是否还会检测到我们忽略的文件。</p><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><p>当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reset --hard commitID<br></code></pre></td></tr></table></figure><p>执行后，会直接重置为那个时候的状态。再次查看提交日志，我们发现之后的日志全部消失了。</p><p>那么要是现在我又想回去呢？我们可以通过查看所有分支的所有操作记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reflog<br></code></pre></td></tr></table></figure><p>这样就能找到之前的commitID，再次重置即可。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支就像我们树上的一个树枝一样，它们可能一开始的时候是同一根树枝，但是长着长着就开始分道扬镳了，这就是分支。我们的代码也是这样，可能一开始写基础功能的时候使用的是单个分支，但是某一天我们希望基于这些基础的功能，把我们的项目做成两个不同方向的项目，比如一个方向做Web网站，另一个方向做游戏服务端。</p><p>因此，我们可以在一个主干上分出N个分支，分别对多个分支的代码进行维护。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>我们可以通过以下命令来查看当前仓库中存在的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch<br></code></pre></td></tr></table></figure><p>我们发现，默认情况下是有一个master分支的，并且我们使用的也是master分支，一般情况下master分支都是正式版本的更新，而其他分支一般是开发中才频繁更新的。我们接着来基于当前分支创建一个新的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git branch <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 对应的删除分支是</span><br>git branch -d yyds<br></code></pre></td></tr></table></figure><p>现在我们修改一下文件，提交，再查看一下提交日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git commit -a -m <span class="hljs-string">&#x27;branch master commit&#x27;</span><br></code></pre></td></tr></table></figure><p>通过添加-a来自动将未放入暂存区的已修改文件放入暂存区并执行提交操作。查看日志，我们发现现在我们的提交只生效于master分支，而新创建的分支并没有发生修改。</p><p>我们将分支切换到另一个分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>我们会发现，文件变成了此分支创建的时的状态，也就是说，在不同分支下我们的文件内容是相互隔离的。</p><p>我们现在再来提交一次变更，会发现它只生效在yyds分支上。我们可以看看当前的分支状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">log</span> --all --graph<br></code></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>我们也可以将两个分支更新的内容最终合并到同一个分支上，我们先切换回主分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout master<br></code></pre></td></tr></table></figure><p>接着使用分支合并命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git merge <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>会得到如下提示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Auto-merging hello.txt<br><span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> hello.txt<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.<br></code></pre></td></tr></table></figure><p>在合并过程中产生了冲突，因为两个分支都对hello.txt文件进行了修改，那么现在要合并在一起，到底保留谁的hello文件呢？</p><p>我们可以查看一下是哪里发生了冲突：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git diff<br></code></pre></td></tr></table></figure><p>因此，现在我们将master分支的版本回退到修改hello.txt之前或是直接修改为最新版本的内容，这样就不会有冲突了，接着再执行一次合并操作，现在两个分支成功合并为同一个分支。</p><h3 id="变基分支"><a href="#变基分支" class="headerlink" title="变基分支"></a>变基分支</h3><p>除了直接合并分支以外，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将yyds变基到master上，那么yyds会将分支起点移动到master最后一次提交位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git rebase master<br></code></pre></td></tr></table></figure><p>变基后，yyds分支相当于同步了此前master分支的全部提交。</p><h3 id="优选"><a href="#优选" class="headerlink" title="优选"></a>优选</h3><p>我们还可以选择其将他分支上的提交作用于当前分支上，这种操作称为cherrypick：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git cherry-pick &lt;commit <span class="hljs-built_in">id</span>&gt;:单独合并一个提交<br></code></pre></td></tr></table></figure><p>这里我们在master分支上创建一个新的文件，提交此次更新，接着通过cherry-pick的方式将此次更新作用于test分支上。</p><hr><h2 id="使用IDEA版本控制"><a href="#使用IDEA版本控制" class="headerlink" title="使用IDEA版本控制"></a>使用IDEA版本控制</h2><p>虽然前面我们基本讲解了git的命令行使用方法，但是没有一个图形化界面，始终会感觉到很抽象，所以这里我们使用IDEA来演示，IDEA内部集成了git模块，它可以让我们的git版本管理图形化显示，当然除了IDEA也有一些独立的软件比如：SourceTree（挺好用）</p><p>打开IDEA后，找到版本控模块，我们直接点击创建本地仓库，它会自动将当前项目的根目录作为我们的本地仓库，而我们编写的所有代码和项目目录下其他的文件都可以进行版本控制。</p><p>我们发现所有项目中正在编写的类文件全部变红了，也就是处于未追踪状态，接着我们进行第一次初始化提交，提交之后我们可以在下方看到所有的本地仓库提交记录。</p><p>接着我们来整合一下Web环境，创建新的类之后，IDEA会提示我们是否将文件添加到Git，也就是是否放入暂存区并开启追踪，我们可以直接对比两次代码的相同和不同之处。</p><p>接着我们来演示一下分支创建和分支管理。</p><hr><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库实际上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且可以实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。</p><p>远程仓库有公有和私有的，公有的远程仓库有GitHub、码云、Coding等，他们都是对外开放的，我们注册账号之后就可以使用远程仓库进行版本控制，其中最大的就是GitHub，但是它服务器在国外，我们国内连接可能会有一点卡。私有的一般是GitLab这种自主搭建的远程仓库私服，在公司中比较常用，它只对公司内部开放，不对外开放。</p><p>这里我们以GitHub做讲解，官网：<a href="https://github.com,首先完成用户注册./">https://github.com，首先完成用户注册。</a></p><h3 id="远程账户认证和推送"><a href="#远程账户认证和推送" class="headerlink" title="远程账户认证和推送"></a>远程账户认证和推送</h3><p>接着我们就可以创建一个自定义的远程仓库了。</p><p>创建仓库后，我们可以通过推送来将本地仓库中的内容推送到远程仓库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote add 名称 远程仓库地址<br>git push 远程仓库名称 本地分支名称[:远端分支名称]<br></code></pre></td></tr></table></figure><p>注意<code>push</code>后面两个参数，一个是远端名称，还有一个就是本地分支名称，但是如果本地分支名称和远端分支名称一致，那么不用指定远端分支名称，但是如果我们希望推送的分支在远端没有同名的，那么需要额外指定。推送前需要登陆账户，GitHub现在不允许使用用户名密码验证，只允许使用个人AccessToken来验证身份，所以我们需要先去生成一个Token才可以。</p><p>推送后，我们发现远程仓库中的内容已经与我们本地仓库中的内容保持一致了，注意，远程仓库也可以有很多个分支。</p><p>但是这样比较麻烦，我们每次都需要去输入用户名和密码，有没有一劳永逸的方法呢？当然，我们也可以使用SSH来实现一次性校验，我们可以在本地生成一个rsa公钥：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh-keygen -t rsa<br><span class="hljs-built_in">cat</span> ~/.ssh/github.pub<br></code></pre></td></tr></table></figure><p>接着我们需要在GitHub上上传我们的公钥，当我们再次去访问GitHub时，会自动验证，就无需进行登录了，之后在Linux部分我们会详细讲解SSH的原理。</p><p>接着我们修改一下工作区的内容，提交到本地仓库后，再推送到远程仓库，提交的过程中我们注意观察提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">git commit -a -m <span class="hljs-string">&#x27;Modify files&#x27;</span><br>git <span class="hljs-built_in">log</span> --all --oneline --graph<br>git push origin master <br>git <span class="hljs-built_in">log</span> --all --oneline --graph<br></code></pre></td></tr></table></figure><p>我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git push --set-upstream origin master:master<br>git push origin<br></code></pre></td></tr></table></figure><p>在一个本地仓库对应一个远程仓库的情况下，远程仓库基本上就是纯粹的代码托管了（云盘那种感觉，就纯粹是存你代码的）</p><h3 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h3><p>如果我们已经存在一个远程仓库的情况下，我们需要在远程仓库的代码上继续编写代码，这个时候怎么办呢？</p><p>我们可以使用克隆操作来将远端仓库的内容全部复制到本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> 远程仓库地址<br></code></pre></td></tr></table></figure><p>这样本地就能够直接与远程保持同步。</p><h3 id="抓取、拉取和冲突解决"><a href="#抓取、拉取和冲突解决" class="headerlink" title="抓取、拉取和冲突解决"></a>抓取、拉取和冲突解决</h3><p>我们接着来看，如果这个时候，出现多个本地仓库对应一个远程仓库的情况下，比如一个团队里面，N个人都在使用同一个远程仓库，但是他们各自只负责编写和推送自己业务部分的代码，也就是我们常说的协同工作，那么这个时候，我们就需要协调。</p><p>比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员的提交记录，因此程序员B的本地仓库和远程仓库不一致，这时就需要有先进行pull操作，获取远程仓库中最新的提交：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git fetch 远程仓库 <span class="hljs-comment">#抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交</span><br>git pull 远程仓库 <span class="hljs-comment">#拉取：获取+合并</span><br></code></pre></td></tr></table></figure><p>在程序员B拉取了最新的版本后，再编写自己的代码然后提交就可以实现多人合作编写项目了，并且在拉取过程中就能将别人提交的内容同步到本地，开发效率大大提升。</p><p>如果工作中存在不协调的地方，比如现在我们本地有两个仓库，一个仓库去修改hello.txt并直接提交，另一个仓库也修改hello.txt并直接提交，会得到如下错误：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">To <span class="hljs-keyword">https</span>://github.com/xx/xxx.git<br> ! [rejected]        master -&gt; master (fetch <span class="hljs-keyword">first</span>)<br>error: failed <span class="hljs-built_in">to</span> push some refs <span class="hljs-built_in">to</span> <span class="hljs-string">&#x27;https://github.com/xx/xxx.git&#x27;</span><br>hint: Updates were rejected because <span class="hljs-keyword">the</span> remote <span class="hljs-keyword">contains</span> work that you <span class="hljs-built_in">do</span><br>hint: <span class="hljs-keyword">not</span> have locally. This is usually caused <span class="hljs-keyword">by</span> another repository pushing<br>hint: <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> same ref. You may want <span class="hljs-built_in">to</span> <span class="hljs-keyword">first</span> integrate <span class="hljs-keyword">the</span> remote changes<br>hint: (e.g., <span class="hljs-string">&#x27;git pull ...&#x27;</span>) <span class="hljs-keyword">before</span> pushing again.<br>hint: See <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>一旦一个本地仓库推送了代码，那么另一个本地仓库的推送会被拒绝，原因是当前文件已经被其他的推送给修改了，我们这边相当于是另一个版本，和之前两个分支合并一样，产生了冲突，因此我们只能去解决冲突问题。</p><p>如果远程仓库中的提交和本地仓库中的提交没有去编写同一个文件，那么就可以直接拉取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git pull 远程仓库<br></code></pre></td></tr></table></figure><p>拉取后会自动进行合并，合并完成之后我们再提交即可。</p><p>但是如果两次提交都修改了同一个文件，那么就会遇到和多分支合并一样的情况，在合并时会产生冲突，这时就需要我们自己去解决冲突了。</p><p>我们可以在IDEA中演示一下，实际开发场景下可能会遇到的问题。</p><hr><p>至此，Git版本控制就讲解到这里，下一章我们会继续认识一个全新的数据库：Redis。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-054d8ff6135b3638aca543eff7424f98_1200x500.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644402012&t=79c30b8002d088850e33bd90492419b2" alt="点击查看源网页"></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2022/09/26/netty/"/>
    <url>/2022/09/26/netty/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a>1、什么是Netty</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Netty <span class="hljs-keyword">is</span> an asynchronous event-driven network <span class="hljs-built_in">application</span> framework<br><span class="hljs-keyword">for</span> rapid development <span class="hljs-keyword">of</span> maintainable high performance protocol servers &amp; clients.<br></code></pre></td></tr></table></figure><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p><h2 id="2、Netty的优势"><a href="#2、Netty的优势" class="headerlink" title="2、Netty的优势"></a>2、Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p><ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>因为bug的存在，epoll 空轮询导致 CPU 100%</li></ul><p>Netty 对 API 进行增强，使之更易用，如 </p><ul><li>FastThreadLocal &#x3D;&gt; ThreadLocal</li><li>ByteBuf &#x3D;&gt; ByteBuffer</li></ul><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a>1、服务器端代码</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1、启动器，负责装配netty组件，启动服务器</span><br>        <span class="hljs-keyword">new</span> ServerBootstrap()<br>                <span class="hljs-comment">// 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector</span><br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                <span class="hljs-comment">// 3、选择服务器的 ServerSocketChannel 实现</span><br>                .channel(NioServerSocketChannel.class)<br>                <span class="hljs-comment">// 4、child 负责处理读写，该方法决定了 child 执行哪些操作</span><br>            <span class="hljs-comment">// ChannelInitializer 处理器（仅执行一次）</span><br>            <span class="hljs-comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span><br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(NioSocketChannel nioSocketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf=&gt;String</span><br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringDecoder());<br>                        <span class="hljs-comment">// 6、SocketChannel的业务处理，使用上一个处理器的处理结果</span><br>                        nioSocketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                                System.out.println(s);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                    <span class="hljs-comment">// 7、ServerSocketChannel绑定8080端口</span><br>                &#125;).bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a>2、客户端代码</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClient</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                <span class="hljs-comment">// 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现</span><br>                .channel(NioSocketChannel.class)<br>                <span class="hljs-comment">// ChannelInitializer 处理器（仅执行一次）</span><br>                <span class="hljs-comment">// 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</span><br>                .<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">// 消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 编码发出</span><br>                        channel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 指定要连接的服务器和端口</span><br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                <span class="hljs-comment">// Netty 中很多方法都是异步的，如 connect</span><br>                <span class="hljs-comment">// 这时需要使用 sync 方法等待 connect 建立连接完毕</span><br>                .sync()<br>                <span class="hljs-comment">// 获取 channel 对象，它即为通道抽象，可以进行数据读写操作</span><br>                .channel()<br>                <span class="hljs-comment">// 写入消息并清空缓冲区</span><br>                .writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a>3、运行流程</h2><p><strong>左：客户端        右：服务器端</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png" alt="img"></a></p><h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a>组件解释</h3><ul><li><p>channel 可以理解为数据的通道</p></li><li><p>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</p></li><li><p>handler 可以理解为数据的处理工序</p><ul><li><p>工序有多道，</p><p>合在一起就是 pipeline（传递途径）</p><p>，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</p><ul><li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li></ul></li><li><p>handler 分 Inbound 和 Outbound 两类</p><ul><li>Inbound 入站</li><li>Outbound 出站</li></ul></li></ul></li><li><p>eventLoop 可以理解为处理数据的工人</p><ul><li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li><li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li></ul></li></ul><h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h1><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a>1、EventLoop</h2><p><strong>事件循环对象</strong>  EventLoop</p><p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p><p>它的继承关系如下</p><ul><li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>继承自 netty 自己的 OrderedEventExecutor<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><p><strong>事件循环组</strong> EventLoopGroup</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register  方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io  事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TestEventLoop &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程</span><br>        EventLoopGroup <span class="hljs-keyword">group</span> = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 通过next方法可以获得下一个 EventLoop</span><br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">group</span>.<span class="hljs-keyword">next</span>());<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">group</span>.<span class="hljs-keyword">next</span>());<br><br>        <span class="hljs-comment">// 通过EventLoop执行普通任务</span><br>        <span class="hljs-keyword">group</span>.<span class="hljs-keyword">next</span>().execute(()-&gt;&#123;<br>            System.out.<span class="hljs-keyword">println</span>(Thread.currentThread().getName() + <span class="hljs-string">&quot; hello&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过EventLoop执行定时任务</span><br>        <span class="hljs-keyword">group</span>.<span class="hljs-keyword">next</span>().scheduleAtFixedRate(()-&gt;&#123;<br>            System.out.<span class="hljs-keyword">println</span>(Thread.currentThread().getName() + <span class="hljs-string">&quot; hello2&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 优雅地关闭</span><br>        <span class="hljs-keyword">group</span>.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">io</span>.netty.channel.nio.NioEventLoop@<span class="hljs-number">7</span>bb11784<br><span class="hljs-attribute">io</span>.netty.channel.nio.NioEventLoop@<span class="hljs-number">33</span>a10788<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">1</span> hello<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello2<br></code></pre></td></tr></table></figure><p><strong>关闭 EventLoopGroup</strong></p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MyServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">socketChannel</span>)</span> throws Exception &#123;<br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; &quot;</span> + buf.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(StandardCharsets.UTF_8)</span>);<br><br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClient</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        Channel channel = <span class="hljs-keyword">new</span> Bootstrap()<br>                .group(<span class="hljs-keyword">new</span> NioEventLoopGroup())<br>                .channel(NioSocketChannel.class)<br>                .<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                .sync()<br>                .channel();<br>        System.out.println(channel);<br>        <span class="hljs-comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ServerBootstrap</span>()<br>            <span class="hljs-comment">// 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-type">NioEventLoopGroup</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-type">NioEventLoopGroup</span>(<span class="hljs-number">2</span>))<br>            <br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个客户端分别发送 <code>hello</code>  结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">1</span> hello1<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">1</span> hello3<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello4<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello4<br></code></pre></td></tr></table></figure><p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png" alt="img"></a></p><h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MyServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 增加自定义的非NioEventLoopGroup</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultEventLoopGroup()</span>;<br>        <br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup(1)</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup(2)</span>)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">socketChannel</span>)</span> throws Exception &#123;<br>                        <span class="hljs-comment">// 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理</span><br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;nioHandler&quot;</span>,<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; &quot;</span> + buf.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(StandardCharsets.UTF_8)</span>);<br>                                <span class="hljs-comment">// 调用下一个handler</span><br>                                ctx.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">msg</span>)</span>;<br>                            &#125;<br>                        &#125;)<br>                        <span class="hljs-comment">// 该handler绑定自定义的Group</span><br>                        .add<span class="hljs-constructor">Last(<span class="hljs-params">group</span>, <span class="hljs-string">&quot;myHandler&quot;</span>, <span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                ByteBuf buf = (ByteBuf) msg;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; &quot;</span> + buf.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(StandardCharsets.UTF_8)</span>);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动四个客户端发送数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">1</span> hello1<br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">1</span> hello1<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">1</span> hello3<br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">3</span> hello3<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">2</span> hello4<br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">4</span> hello4<br></code></pre></td></tr></table></figure><p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png" alt="img"></a></p><h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p><p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void invoke<span class="hljs-constructor">ChannelRead(<span class="hljs-params">final</span> AbstractChannelHandlerContext <span class="hljs-params">next</span>, Object <span class="hljs-params">msg</span>)</span> &#123;<br>    final Object m = next.pipeline.touch(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectUtil</span>.</span></span>check<span class="hljs-constructor">NotNull(<span class="hljs-params">msg</span>, <span class="hljs-string">&quot;msg&quot;</span>)</span>, next);<br>    <span class="hljs-comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span><br>    EventExecutor executor = next.executor<span class="hljs-literal">()</span>;<br>    <br>    <span class="hljs-comment">// 如果下一个EventLoop 在当前的 EventLoopGroup中</span><br>    <span class="hljs-keyword">if</span> (executor.<span class="hljs-keyword">in</span><span class="hljs-constructor">EventLoop()</span>) &#123;<br>        <span class="hljs-comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span><br>        next.invoke<span class="hljs-constructor">ChannelRead(<span class="hljs-params">m</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span><br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>            public void run<span class="hljs-literal">()</span> &#123;<br>                next.invoke<span class="hljs-constructor">ChannelRead(<span class="hljs-params">m</span>)</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li></ul><h2 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h2><p>Channel 的常用方法</p><ul><li>close() 可以用来关闭Channel</li><li>closeFuture() 用来处理 Channel 的关闭<ul><li>sync 方法作用是同步等待 Channel 关闭</li><li>而 addListener 方法是异步等待 Channel 关闭</li></ul></li><li>pipeline() 方法用于添加处理器</li><li>write() 方法将数据写入<ul><li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li><li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li></ul></li><li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p><strong>拆分客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>            <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br>        <span class="hljs-comment">// 该方法用于等待连接真正建立</span><br>        channelFuture.sync();<br>        <br>        <span class="hljs-comment">// 获取客户端-服务器之间的Channel对象</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>        channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p><p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p><p><strong>addListener方法</strong></p><p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>                <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br><span class="hljs-comment">// 当connect方法执行完毕后，也就是连接真正建立后</span><br>        <span class="hljs-comment">// 会在NIO线程中调用operationComplete方法</span><br>        channelFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>                channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建EventLoopGroup，使用完毕后关闭</span><br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                .group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        channelFuture.sync();<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 创建一个线程用于输入并向服务器发送</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.next();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(msg)) &#123;<br>                    <span class="hljs-comment">// 关闭操作是异步的，在NIO线程中执行</span><br>                    channel.close();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                channel.writeAndFlush(msg);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;inputThread&quot;</span>).start();<br><br>        <span class="hljs-comment">// 获得closeFuture对象</span><br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">closeFuture</span> <span class="hljs-operator">=</span> channel.closeFuture();<br>        System.out.println(<span class="hljs-string">&quot;waiting close...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 同步等待NIO线程执行完close操作</span><br>        closeFuture.sync();<br>        <br>        <span class="hljs-comment">// 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的</span><br>        System.out.println(<span class="hljs-string">&quot;关闭之后执行一些额外操作...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 关闭EventLoopGroup</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关闭channel</strong></p><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p><p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p><ul><li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获得closeFuture对象<br>ChannelFuture closeFuture = channel.closeFuture();<br><br><span class="hljs-regexp">//</span> 同步等待NIO线程执行完close操作<br>closeFuture.sync();<br></code></pre></td></tr></table></figure></li></ul><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">closeFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 等待channel关闭后才执行的操作</span><br>        System.out.println(<span class="hljs-string">&quot;关闭之后执行一些额外操作...&quot;</span>);<br>        <span class="hljs-comment">// 关闭EventLoopGroup</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3、Future与Promise"><a href="#3、Future与Promise" class="headerlink" title="3、Future与Promise"></a>3、Future与Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p><p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li></ul><table><thead><tr><th>功能&#x2F;名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkFuture</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) throws ExecutionException, InterruptedException &#123;<br>        ThreadFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadFactory</span>() &#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> Thread <span class="hljs-keyword">new</span><span class="hljs-type">Thread</span>(Runnable r) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(r, <span class="hljs-string">&quot;JdkFuture&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 创建线程池</span><br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>,<span class="hljs-number">10</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>), factory);<br><br>        <span class="hljs-comment">// 获得Future对象</span><br>        Future&lt;Integer&gt; future = executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-type">Callable</span>&lt;Integer&gt;() &#123;<br><br>            @Override<br>            <span class="hljs-keyword">public</span> Integer call() throws Exception &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过阻塞的方式，获得运行结果</span><br>        System.out.println(future.<span class="hljs-keyword">get</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> NettyFuture &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws ExecutionException, InterruptedException &#123;<br>        NioEventLoopGroup <span class="hljs-keyword">group</span> = <span class="hljs-built_in">new</span> NioEventLoopGroup();<br><br>        // 获得 EventLoop 对象<br>        EventLoop eventLoop = <span class="hljs-keyword">group</span>.next();<br>        Future&lt;<span class="hljs-type">Integer</span>&gt; future = eventLoop.submit(<span class="hljs-built_in">new</span> Callable&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">Integer</span> <span class="hljs-keyword">call</span>() throws <span class="hljs-keyword">Exception</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        // 主线程中获取结果<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;getNow &quot; + future.getNow());<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;get &quot; + future.<span class="hljs-keyword">get</span>());<br><br>        // NIO线程中异步获取结果<br>        future.addListener(<span class="hljs-built_in">new</span> GenericFutureListener&lt;Future&lt;? super <span class="hljs-type">Integer</span>&gt;&gt;() &#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> operationComplete(Future&lt;? super <span class="hljs-type">Integer</span>&gt; future) throws <span class="hljs-keyword">Exception</span> &#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;getNow &quot; + future.getNow());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">main</span> 获取结果<br><span class="hljs-attribute">getNow</span> null<br><span class="hljs-attribute">get</span> <span class="hljs-number">50</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">1</span> 获取结果<br><span class="hljs-attribute">getNow</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p><ul><li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li><li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li><li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li></ul><h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyPromise</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws ExecutionException, InterruptedException &#123;<br>        <span class="hljs-regexp">// 创建EventLoop</span><br><span class="hljs-regexp">        NioEventLoopGroup group = new NioEventLoopGroup();</span><br><span class="hljs-regexp">        EventLoop eventLoop = group.next();</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        //</span> 创建<span class="hljs-built_in">Promise</span>对象，用于存放结果<br>        DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(eventLoop);<br><br>        <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-regexp">// 自定义线程向Promise中存放结果</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">            promise.setSuccess(50);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">        &#125;).start();</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"></span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">        //</span> 主线程从<span class="hljs-built_in">Promise</span>中获取结果</span></span><br><span class="hljs-params"><span class="hljs-function">        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + promise.get());</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><h2 id="4、Handler与Pipeline"><a href="#4、Handler与Pipeline" class="headerlink" title="4、Handler与Pipeline"></a>4、Handler与Pipeline</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> PipeLineServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">socketChannel</span>)</span> throws Exception &#123;<br>                        <span class="hljs-comment">// 在socketChannel的pipeline中添加handler</span><br>                        <span class="hljs-comment">// pipeline中handler是带有head与tail节点的双向链表，的实际结构为</span><br>     <span class="hljs-comment">// head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail</span><br>                        <span class="hljs-comment">// Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法</span><br>                        <span class="hljs-comment">// 入站时，handler是从head向后调用的</span><br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;handler1&quot;</span> ,<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; Inbound handler 1&quot;</span>);<br>                                <span class="hljs-comment">// 父类该方法内部会调用fireChannelRead</span><br>                                <span class="hljs-comment">// 将数据传递给下一个handler</span><br>                                super.channel<span class="hljs-constructor">Read(<span class="hljs-params">ctx</span>, <span class="hljs-params">msg</span>)</span>;<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;handler2&quot;</span>, <span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                            @Override<br>                            public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; Inbound handler 2&quot;</span>);<br>                                <span class="hljs-comment">// 执行write操作，使得Outbound的方法能够得到调用</span><br>          socketChannel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">ctx</span>.<span class="hljs-params">alloc</span>()</span>.buffer<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;Server...&quot;</span>.<span class="hljs-params">getBytes</span>(StandardCharsets.UTF_8)</span>));<br>                                super.channel<span class="hljs-constructor">Read(<span class="hljs-params">ctx</span>, <span class="hljs-params">msg</span>)</span>;<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法</span><br>                        <span class="hljs-comment">// 出站时，handler的调用是从tail向前调用的</span><br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;handler3&quot;</span> ,<span class="hljs-params">new</span> ChannelOutboundHandlerAdapter()</span>&#123;<br>                            @Override<br>                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; Outbound handler 1&quot;</span>);<br>                                super.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-string">&quot;handler4&quot;</span> ,<span class="hljs-params">new</span> ChannelOutboundHandlerAdapter()</span>&#123;<br>                            @Override<br>                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;<br>                                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; Outbound handler 2&quot;</span>);<br>                                super.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果如下</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Inbound handler <span class="hljs-number">1</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Inbound handler <span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Outbound handler <span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Outbound handler <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p><p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p><ul><li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul><li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li></ul></li><li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li><li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li></ul><p><strong>具体结构如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png" alt="img"></a></p><p><strong>调用顺序如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png" alt="img"></a></p><h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png" alt="img"></a></p><h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png" alt="img"></a></p><h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEmbeddedChannel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ChannelInboundHandlerAdapter</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>                <span class="hljs-built_in">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">ChannelInboundHandlerAdapter</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                <span class="hljs-built_in">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">ChannelOutboundHandlerAdapter</span> <span class="hljs-variable">h3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>                <span class="hljs-built_in">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">ChannelOutboundHandlerAdapter</span> <span class="hljs-variable">h4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>                <span class="hljs-built_in">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 用于测试Handler的Channel</span><br>        <span class="hljs-type">EmbeddedChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbeddedChannel</span>(h1, h2, h3, h4);<br>        <br>        <span class="hljs-comment">// 执行Inbound操作 </span><br>        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>        <span class="hljs-comment">// 执行Outbound操作</span><br>        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、ByteBuf"><a href="#5、ByteBuf" class="headerlink" title="5、ByteBuf"></a>5、ByteBuf</h2><p><strong>调试工具方法</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static void log(ByteBuf buffer) &#123;<br>    <span class="hljs-built_in">int</span> length = buffer.readable<span class="hljs-constructor">Bytes()</span>;<br>    <span class="hljs-built_in">int</span> rows = length<span class="hljs-operator"> / </span><span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;<br>    StringBuilder buf = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">rows</span> <span class="hljs-operator">*</span> 80 <span class="hljs-operator">*</span> 2)</span><br>        .append(<span class="hljs-string">&quot;read index:&quot;</span>).append(buffer.reader<span class="hljs-constructor">Index()</span>)<br>        .append(<span class="hljs-string">&quot; write index:&quot;</span>).append(buffer.writer<span class="hljs-constructor">Index()</span>)<br>        .append(<span class="hljs-string">&quot; capacity:&quot;</span>).append(buffer.capacity<span class="hljs-literal">()</span>)<br>        .append(NEWLINE);<br>    append<span class="hljs-constructor">PrettyHexDump(<span class="hljs-params">buf</span>, <span class="hljs-params">buffer</span>)</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(buf.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法可以帮助我们更为详细地查看ByteBuf中的内容</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufStudy</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            sb.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>        buffer.<span class="hljs-built_in">writeBytes</span>(sb.<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">getBytes</span>(StandardCharsets.UTF_8));<br><br>        <span class="hljs-comment">// 查看写入结果</span><br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:0 capacity:16<br><br>read index:0 write index:20 capacity:64<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|<br><span class="hljs-section">|00000010| 61 61 61 61                                     |aaaa            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p><p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p><p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p><h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">ByteBuf <span class="hljs-keyword">buffer</span> = ByteBufAllocator.<span class="hljs-keyword">DEFAULT</span>.<span class="hljs-keyword">buffer</span>(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ByteBuf buffer <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ByteBuf buffer <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>验证</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufStudy</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>);<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">getClass</span>());<br><br>        buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">heapBuffer</span>(<span class="hljs-number">16</span>);<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">getClass</span>());<br><br>        buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">directBuffer</span>(<span class="hljs-number">16</span>);<br>        System.out.<span class="hljs-built_in">println</span>(buffer.<span class="hljs-built_in">getClass</span>());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用池化的直接内存</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeDirectByteBuf<br>    <br><span class="hljs-comment">// 使用池化的堆内存    </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeHeapByteBuf<br>    <br><span class="hljs-comment">// 使用池化的直接内存    </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeDirectByteBuf<br></code></pre></td></tr></table></figure><h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">-<span class="hljs-type">Dio</span>.netty.allocator.<span class="hljs-keyword">type</span>=&#123;unpooled|pooled&#125;<br></code></pre></td></tr></table></figure><ul><li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p><ul><li><p>最大容量与当前容量</p><ul><li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li><p>读写操作不同于ByteBuffer只用position进行控制，</p><p>ByteBuf分别由读指针和写指针两个指针控制</p><p>。进行读写操作时，无需进行模式的切换</p><ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png" alt="img"></a></p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td><strong>用一字节 01|00 代表 true|false</strong></td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 <strong>ByteBuffer</strong></td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li><li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li></ul></blockquote><p><strong>使用方法</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufStudy</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.<span class="hljs-built_in">writeBytes</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        buffer.<span class="hljs-built_in">writeInt</span>(<span class="hljs-number">5</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        buffer.<span class="hljs-built_in">writeIntLE</span>(<span class="hljs-number">6</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br><br>        buffer.<span class="hljs-built_in">writeLong</span>(<span class="hljs-number">7</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:0 capacity:16<br><br>read index:0 write index:4 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>read index:0 write index:8 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>read index:0 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>read index:0 write index:20 capacity:20<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|<br><span class="hljs-section">|00000010| 00 00 00 07                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">buffer.writeLong(7);<br>ByteBufUtil.log(buffer);<br><span class="hljs-comment">// 扩容前</span><br>read index:0 write index:12 capacity:16<br><span class="hljs-bullet">...</span><br><span class="hljs-bullet"></span><br><span class="hljs-bullet"></span><span class="hljs-comment">// 扩容后</span><br>read index:0 write index:20 capacity:20<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|<br><span class="hljs-section">|00000010| 00 00 00 07                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h4><ul><li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p><ul><li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li></ul></li><li><p>如果写入后数据大小超过 512 字节，则选择下一个  2</p><p>n</p><ul><li>例如写入后大小为 513 字节，则扩容后 capacity 是 210&#x3D;1024 字节（29&#x3D;512 已经不够了）</li></ul></li><li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IndexOutOfBoundsException: writer<span class="hljs-constructor">Index(20)</span> + min<span class="hljs-constructor">WritableBytes(8)</span> exceeds max<span class="hljs-constructor">Capacity(20)</span>: <span class="hljs-constructor">PooledUnsafeDirectByteBuf(<span class="hljs-params">ridx</span>: 0, <span class="hljs-params">widx</span>: 20, <span class="hljs-params">cap</span>: 20<span class="hljs-operator">/</span>20)</span><br>...<br></code></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p><p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">public class ByteBufStudy &#123;<br><span class="hljs-code">    public static void main(String[] args) &#123;</span><br><span class="hljs-code">        // 创建ByteBuf</span><br><span class="hljs-code">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(16, 20);</span><br><br><span class="hljs-code">        // 向buffer中写入数据</span><br><span class="hljs-code">        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);</span><br><span class="hljs-code">        buffer.writeInt(5);</span><br><br><span class="hljs-code">        // 读取4个字节</span><br><span class="hljs-code">        System.out.println(buffer.readByte());</span><br><span class="hljs-code">        System.out.println(buffer.readByte());</span><br><span class="hljs-code">        System.out.println(buffer.readByte());</span><br><span class="hljs-code">        System.out.println(buffer.readByte());</span><br><span class="hljs-code">        ByteBufUtil.log(buffer);</span><br><br><span class="hljs-code">        // 通过mark与reset实现重复读取</span><br><span class="hljs-code">        buffer.markReaderIndex();</span><br><span class="hljs-code">        System.out.println(buffer.readInt());</span><br><span class="hljs-code">        ByteBufUtil.log(buffer);</span><br><br><span class="hljs-code">        // 恢复到mark标记处</span><br><span class="hljs-code">        buffer.resetReaderIndex();</span><br><span class="hljs-code">        ByteBufUtil.log(buffer);</span><br><span class="hljs-code">    &#125;</span><br>&#125;<br>1<br>2<br>3<br>4<br>read index:4 write index:8 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 05                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>5<br>read index:8 write index:8 capacity:16<br><br>read index:4 write index:8 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 05                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler  中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf  已完成了它的使命，那么便无须再传递）</p><p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p><ul><li><p>起点，对于 NIO 实现来讲，在  io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建  ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p></li><li><p>入站 ByteBuf 处理原则</p><ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li><li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li><li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li><li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 ByteBuf 处理原则</p><ul><li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li></ul></li><li><p>异常处理原则</p><ul><li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">buffer</span>.release()) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p><p><strong>TailConext中释放ByteBuf的源码</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onUnhandledInboundMessage</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> msg</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 具体的释放方法</span><br>        <span class="hljs-title class_">ReferenceCountUtil</span>.<span class="hljs-title function_">release</span>(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断传过来的是否为ByteBuf，是的话才需要释放</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">release</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> msg</span>) &#123;<br><span class="hljs-keyword">return</span> msg <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ReferenceCounted</span> ? ((<span class="hljs-title class_">ReferenceCounted</span>)msg).<span class="hljs-title function_">release</span>() : <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p><p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p><p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png" alt="img"></a></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSlice</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.<span class="hljs-built_in">writeBytes</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br><br>        <span class="hljs-comment">// 将buffer分成两部分</span><br>        ByteBuf slice1 = buffer.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        ByteBuf slice2 = buffer.<span class="hljs-built_in">slice</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 需要让分片的buffer引用计数加一</span><br>        <span class="hljs-comment">// 避免原Buffer释放导致分片buffer无法使用</span><br>        slice1.<span class="hljs-built_in">retain</span>();<br>        slice2.<span class="hljs-built_in">retain</span>();<br>        <br>        ByteBufUtil.<span class="hljs-built_in">log</span>(slice1);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(slice2);<br><br>        <span class="hljs-comment">// 更改原始buffer中的值</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;===========修改原buffer中的值===========&quot;</span>);<br>        buffer.<span class="hljs-built_in">setByte</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;===========打印slice1===========&quot;</span>);<br>        ByteBufUtil.<span class="hljs-built_in">log</span>(slice1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>===========修改原buffer中的值===========<br>===========打印slice1===========<br>read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 05 02 03 04 05                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li><li>可以<strong>自动扩容</strong></li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如<ul><li>slice、duplicate、CompositeByteBuf</li></ul></li></ul><h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><h2 id="1、粘包与半包"><a href="#1、粘包与半包" class="headerlink" title="1、粘包与半包"></a>1、粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudyServer</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">// 连接建立时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-built_in">super</span>.channelActive(ctx);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">// 连接断开时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-built_in">super</span>.channelInactive(ctx);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">8080</span>);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());<br>            channelFuture.sync();<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>            log.debug(<span class="hljs-string">&quot;stopped&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudyServer</span>().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudyClient</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(StudyClient.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    log.debug(<span class="hljs-string">&quot;connected...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            <span class="hljs-comment">// 每次发送16个字节的数据，共发送10次</span><br>                            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>                                buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>                                ctx.writeAndFlush(buffer);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务器接收结果</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:/127.0.0.1:8080 - R:/127.0.0.1:53797] READ: 160B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000010|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000020|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000030|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000040|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000050|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000060|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000070|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000080|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000090|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p><h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p><p><strong>服务器代码</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 调整channel的容量<br>serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote><p><strong>服务器接收结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 36B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br><span class="hljs-section">|00000020| 00 01 02 03                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br><span class="hljs-section">|00000020| 04 05 06 07 08 09 0a 0b                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|<br>|00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|<br><span class="hljs-section">|00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br><span class="hljs-section">|00000020| 04 05 06 07 08 09 0a 0b                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 4B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 0c 0d 0e 0f                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul><li>现象<ul><li>发送 abc def，接收 abcdef</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul></li></ul><h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul><li>现象<ul><li>发送 abcdef，接收 abc def</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul></li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p><p><strong>客户端代码改进</strong></p><p>修改channelActive方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> throws Exception </span>&#123;<br>    log.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;sending...&quot;</span>);<br>    ByteBuf buffer = ctx.<span class="hljs-built_in">alloc</span>().<span class="hljs-built_in">buffer</span>(<span class="hljs-number">16</span>);<br>    buffer.<span class="hljs-built_in">writeBytes</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>    ctx.<span class="hljs-built_in">writeAndFlush</span>(buffer);<br>    <span class="hljs-comment">// 使用短链接，每次发送完毕后就断开连接</span><br>    ctx.<span class="hljs-built_in">channel</span>().<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 发送10次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">send</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] ACTIVE<br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 ! R:/127.0.0.1:65024] INACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] ACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 ! R:/127.0.0.1:65057] INACTIVE<br><br>...<br></code></pre></td></tr></table></figure><p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p><h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p><p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">FixedLengthFrameDecoder</span>(<span class="hljs-number">16</span>));<br></code></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><p>客户端发送数据的代码如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 约定最大长度为16</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxLength = <span class="hljs-number">16</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">// 向服务器发送10个报文</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    ByteBuf buffer = ctx.<span class="hljs-built_in">alloc</span>().<span class="hljs-built_in">buffer</span>(maxLength);<br>    <span class="hljs-comment">// 定长byte数组，未使用部分会以0进行填充</span><br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-type">byte</span>[maxLength];<br>    <span class="hljs-comment">// 生成长度为0~15的数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-type">int</span>)(Math.<span class="hljs-built_in">random</span>()*(maxLength<span class="hljs-number">-1</span>)); j++) &#123;<br>        bytes[j] = (<span class="hljs-type">byte</span>) c;<br>    &#125;<br>    buffer.<span class="hljs-built_in">writeBytes</span>(bytes);<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.<span class="hljs-built_in">writeAndFlush</span>(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务器代码</strong></p><p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 通过定长解码器对粘包数据进行拆分</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">FixedLengthFrameDecoder</span>(<span class="hljs-number">16</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">LoggingHandler</span>(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>...<br></code></pre></td></tr></table></figure><h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p><strong>以换行符 \n 为分隔符</strong></p><p>客户端代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 约定最大长度为 64</span><br>final <span class="hljs-built_in">int</span> maxLength = <span class="hljs-number">64</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-built_in">char</span> c = <span class="hljs-character">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    ByteBuf buffer = ctx.alloc<span class="hljs-literal">()</span>.buffer(maxLength);<br>    <span class="hljs-comment">// 生成长度为0~62的数据</span><br>    Random random = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random()</span>;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-built_in">int</span>)(random.next<span class="hljs-constructor">Int(<span class="hljs-params">maxLength</span>-2)</span>); j++) &#123;<br>        sb.append(c);<br>    &#125;<br>    <span class="hljs-comment">// 数据以 \n 结尾</span><br>    sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-params">sb</span>.<span class="hljs-params">toString</span>()</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>);<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">buffer</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \n 为分隔符</span><br><span class="hljs-comment">// 需要指定最大长度</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">DelimiterBasedFrameDecoder</span>(<span class="hljs-number">64</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">LoggingHandler</span>(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 10B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 2B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63                                           |cc              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>...<br></code></pre></td></tr></table></figure><p><strong>以自定义分隔符 \c 为分隔符</strong></p><p>客户端代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">...<br>    <br><span class="hljs-comment">// 数据以 \c 结尾</span><br>sb.append(<span class="hljs-string">&quot;\\c&quot;</span>);<br>buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-params">sb</span>.<span class="hljs-params">toString</span>()</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>);<br><br>...<br></code></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 将分隔符放入ByteBuf中</span><br>ByteBuf bufSet = ch.alloc<span class="hljs-literal">()</span>.buffer<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;\\c&quot;</span>.<span class="hljs-params">getBytes</span>(StandardCharsets.UTF_8)</span>);<br><span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \c 为分隔符</span><br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> DelimiterBasedFrameDecoder(64, <span class="hljs-params">ch</span>.<span class="hljs-params">alloc</span>()</span>.buffer<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-params">bufSet</span>)</span>));<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LoggingHandler(LogLevel.DEBUG)</span>);<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 14B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><br>8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 3B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62                                        |bbb             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>...<br></code></pre></td></tr></table></figure><h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> maxFrameLength,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> lengthFieldOffset, <span class="hljs-type">int</span> lengthFieldLength,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> lengthAdjustment, <span class="hljs-type">int</span> initialBytesToStrip)</span><br></code></pre></td></tr></table></figure><p><strong>参数解析</strong></p><ul><li>maxFrameLength 数据最大长度<ul><li>表示数据的最大长度（包括附加信息、长度标识等内容）</li></ul></li><li>lengthFieldOffset  <strong>数据长度标识的起始偏移量</strong><ul><li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li></ul></li><li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul><li>数据中用于表示有用数据长度的标识所占的字节数</li></ul></li><li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul><li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li></ul></li><li>initialBytesToStrip <strong>数据读取起点</strong><ul><li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li></ul></li></ul><p><strong>参数图解</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png" alt="img"></a></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0 (= do not strip header)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)<br>+--------+----------------+      +--------+----------------+<br>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+--------+----------------+      +--------+----------------+<br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节</p><p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 2 (= the length of the Length field)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)<br>+--------+----------------+      +----------------+<br>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+--------+----------------+      +----------------+<br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p><p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 2 (= the length of Header 1)<br>lengthFieldLength   = 3<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+----------+----------+----------------+      +----------+----------+----------------+<br></code></pre></td></tr></table></figure><p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p><p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 0<br>lengthFieldLength   = 3<br>lengthAdjustment    = 2 (= the length of Header 1)<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+----------+----------+----------------+      +----------+----------+----------------+<br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p><p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 1 (= the length of HDR1)<br>lengthFieldLength   = 2<br>lengthAdjustment    = 1 (= the length of HDR2)<br>initialBytesToStrip = 3 (= the length of HDR1 + LEN)<br>  <br>BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)<br>+------+--------+------+----------------+      +------+----------------+<br>|<span class="hljs-string"> HDR1 </span>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> HDR2 </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> HDR2 </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0xCA </span>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> 0xFE </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0xFE </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+------+--------+------+----------------+      +------+----------------+<br></code></pre></td></tr></table></figure><p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p><hr><p><strong>使用</strong></p><p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderStudy</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 模拟服务器</span><br>        <span class="hljs-comment">// 使用EmbeddedChannel测试handler</span><br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EmbeddedChannel</span>(<br>                <span class="hljs-comment">// 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-built_in">LengthFieldBasedFrameDecoder</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-built_in">LoggingHandler</span>(LogLevel.DEBUG)<br>        );<br><br>        <span class="hljs-comment">// 模拟客户端，写入数据</span><br>        ByteBuf buffer = ByteBufAllocator.<span class="hljs-literal">DEFAULT</span>.<span class="hljs-built_in">buffer</span>();<br>        <span class="hljs-built_in">send</span>(buffer, <span class="hljs-string">&quot;Hello&quot;</span>);<br>        channel.<span class="hljs-built_in">writeInbound</span>(buffer);<br>        <span class="hljs-built_in">send</span>(buffer, <span class="hljs-string">&quot;World&quot;</span>);<br>        channel.<span class="hljs-built_in">writeInbound</span>(buffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ByteBuf buf, <span class="hljs-type">String</span> msg)</span> </span>&#123;<br>        <span class="hljs-comment">// 得到数据的长度</span><br>        <span class="hljs-type">int</span> length = msg.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">byte</span>[] bytes = msg.<span class="hljs-built_in">getBytes</span>(StandardCharsets.UTF_8);<br>        <span class="hljs-comment">// 将数据信息写入buf</span><br>        <span class="hljs-comment">// 写入长度标识前的其他信息</span><br>        buf.<span class="hljs-built_in">writeByte</span>(<span class="hljs-number">0xCA</span>);<br>        <span class="hljs-comment">// 写入数据长度标识</span><br>        buf.<span class="hljs-built_in">writeInt</span>(length);<br>        <span class="hljs-comment">// 写入长度标识后的其他信息</span><br>        buf.<span class="hljs-built_in">writeByte</span>(<span class="hljs-number">0xFE</span>);<br>        <span class="hljs-comment">// 写入具体的数据</span><br>        buf.<span class="hljs-built_in">writeBytes</span>(bytes);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h2 id="2、协议设计与解析"><a href="#2、协议设计与解析" class="headerlink" title="2、协议设计与解析"></a>2、协议设计与解析</h2><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP&#x2F;IP 中消息传输基于流的方式，没有边界</p><p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 该指令一共有<span class="hljs-number">3</span>部分，每条指令之后都要添加回车与换行符<br>*<span class="hljs-number">3</span>\r\n<br><span class="hljs-regexp">//</span> 第一个指令的长度是<span class="hljs-number">3</span><br><span class="hljs-variable">$3</span>\r\n<br><span class="hljs-regexp">//</span> 第一个指令是set指令<br>set\r\n<br><span class="hljs-regexp">//</span> 下面的指令以此类推<br><span class="hljs-variable">$4</span>\r\n<br>name\r\n<br><span class="hljs-variable">$5</span>\r\n<br>Nyima\r\n<br></code></pre></td></tr></table></figure><p><strong>客户端代码如下</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> RedisClient &#123;<br>    static final Logger log = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(StudyServer.<span class="hljs-params">class</span>)</span>;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup group =  <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture channelFuture = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span><br>                    .group(group)<br>                    .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>                        @Override<br>                        protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> &#123;<br>                            <span class="hljs-comment">// 打印日志</span><br>                            ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LoggingHandler(LogLevel.DEBUG)</span>);<br>                            ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>                                @Override<br>                                public void channel<span class="hljs-constructor">Active(ChannelHandlerContext <span class="hljs-params">ctx</span>)</span> throws Exception &#123;<br>                                    <span class="hljs-comment">// 回车与换行符</span><br>                                    final byte<span class="hljs-literal">[]</span> LINE = &#123;<span class="hljs-character">&#x27;\r&#x27;</span>,<span class="hljs-character">&#x27;\n&#x27;</span>&#125;;<br>                                    <span class="hljs-comment">// 获得ByteBuf</span><br>                                    ByteBuf buffer = ctx.alloc<span class="hljs-literal">()</span>.buffer<span class="hljs-literal">()</span>;<br>                                    <span class="hljs-comment">// 连接建立后，向Redis中发送一条指令，注意添加回车与换行</span><br>                                    <span class="hljs-comment">// set name Nyima</span><br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;*3&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;$3&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;set&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;$4&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;$5&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    buffer.write<span class="hljs-constructor">Bytes(<span class="hljs-string">&quot;Nyima&quot;</span>.<span class="hljs-params">getBytes</span>()</span>);<br>                                    buffer.write<span class="hljs-constructor">Bytes(LINE)</span>;<br>                                    ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">buffer</span>)</span>;<br>                                &#125;<br><br>                            &#125;);<br>                        &#125;<br>                    &#125;)<br>                    .connect(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, 6379)</span>);<br>            channelFuture.sync<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel<span class="hljs-literal">()</span>.close<span class="hljs-literal">()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            <span class="hljs-comment">// 关闭group</span><br>            group.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制台打印结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">1600 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x28c994f1, L:/127.0.0.1:60792 - R:localhost/127.0.0.1:6379] WRITE: 34B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.|<br>|00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 4e 79 69 6d 61 |.name..$5..Nyima|<br><span class="hljs-section">|00000020| 0d 0a                                           |..              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p><strong>Redis中查询执行结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png" alt="img"></a></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder</span><br><span class="hljs-comment">// Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器</span><br>public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServerCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler&lt;HttpRequestDecoder</span>, <span class="hljs-title">HttpResponseEncoder&gt;</span></span><br>        implements <span class="hljs-type">HttpServerUpgradeHandler</span>.<span class="hljs-type">SourceCodec</span><br></code></pre></td></tr></table></figure><p><strong>服务器代码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> HttpServer &#123;<br>    static final Logger log = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(StudyServer.<span class="hljs-params">class</span>)</span>;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span><br>                .group(group)<br>                .channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>)<br>                .child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                    @Override<br>                    protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> &#123;<br>                        ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LoggingHandler(LogLevel.DEBUG)</span>);<br>                        <span class="hljs-comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span><br>                        ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> HttpServerCodec()</span>);<br>                        <span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>                        ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;()</span> &#123;<br>                            @Override<br>                            protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, HttpRequest <span class="hljs-params">msg</span>)</span> &#123;<br>                                <span class="hljs-comment">// 获得请求uri</span><br>                                log.debug(msg.uri<span class="hljs-literal">()</span>);<br><br>                                <span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br>                                DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultFullHttpResponse(<span class="hljs-params">msg</span>.<span class="hljs-params">protocolVersion</span>()</span>, HttpResponseStatus.OK);<br>                                <span class="hljs-comment">// 设置响应内容</span><br>                                byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>;<br>                                <span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>                                response.headers<span class="hljs-literal">()</span>.set<span class="hljs-constructor">Int(CONTENT_LENGTH, <span class="hljs-params">bytes</span>.<span class="hljs-params">length</span>)</span>;<br>                                <span class="hljs-comment">// 设置响应体</span><br>                                response.content<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-params">bytes</span>)</span>;<br><br>                                <span class="hljs-comment">// 写回响应</span><br>                                ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">response</span>)</span>;<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;()<br></code></pre></td></tr></table></figure><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br>DefaultFullHttpResponse response = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultFullHttpResponse(<span class="hljs-params">msg</span>.<span class="hljs-params">protocolVersion</span>()</span>, HttpResponseStatus.OK);<br><span class="hljs-comment">// 设置响应内容</span><br>byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.get<span class="hljs-constructor">Bytes(StandardCharsets.UTF_8)</span>;<br><span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>response.headers<span class="hljs-literal">()</span>.set<span class="hljs-constructor">Int(CONTENT_LENGTH, <span class="hljs-params">bytes</span>.<span class="hljs-params">length</span>)</span>;<br><span class="hljs-comment">// 设置响应体</span><br>response.content<span class="hljs-literal">()</span>.write<span class="hljs-constructor">Bytes(<span class="hljs-params">bytes</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>浏览器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png" alt="img"></a></p><p>控制台</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs tap">// 请求内容<br>1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] READ: 688B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 47 </span>45<span class="hljs-number"> 54 </span>20 2f<span class="hljs-number"> 66 </span>61<span class="hljs-number"> 76 </span>69<span class="hljs-number"> 63 </span>6f 6e 2e<span class="hljs-number"> 69 </span>63 6f |GET /favicon.ico|<br>|00000010|<span class="hljs-number"> 20 </span>48<span class="hljs-number"> 54 </span>54<span class="hljs-number"> 50 </span>2f<span class="hljs-number"> 31 </span>2e<span class="hljs-number"> 31 </span>0d 0a<span class="hljs-number"> 48 </span>6f<span class="hljs-number"> 73 </span>74 3a | HTTP/1.1..Host:|<br>|00000020|<span class="hljs-number"> 20 </span>6c 6f<span class="hljs-number"> 63 </span>61 6c<span class="hljs-number"> 68 </span>6f<span class="hljs-number"> 73 </span>74 3a<span class="hljs-number"> 38 </span>30<span class="hljs-number"> 38 </span>30 0d | localhost:8080.|<br>|00000030| 0a<span class="hljs-number"> 43 </span>6f 6e 6e<span class="hljs-number"> 65 </span>63<span class="hljs-number"> 74 </span>69 6f 6e 3a<span class="hljs-number"> 20 </span>6b<span class="hljs-number"> 65 </span>65 |.Connection: kee|<br>|00000040|<span class="hljs-number"> 70 </span>2d<span class="hljs-number"> 61 </span>6c<span class="hljs-number"> 69 </span>76<span class="hljs-number"> 65 </span>0d 0a<span class="hljs-number"> 50 </span>72<span class="hljs-number"> 61 </span>67 6d<span class="hljs-number"> 61 </span>3a |p-alive..Pragma:|<br>....<br><br>// 响应内容<br>1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:55503] WRITE: 61B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 48 </span>54<span class="hljs-number"> 54 </span>50 2f<span class="hljs-number"> 31 </span>2e<span class="hljs-number"> 31 </span>20<span class="hljs-number"> 32 </span>30<span class="hljs-number"> 30 </span>20 4f 4b 0d |HTTP/1.1<span class="hljs-number"> 200 </span>OK.|<br>|00000010| 0a<span class="hljs-number"> 43 </span>6f 6e<span class="hljs-number"> 74 </span>65 6e<span class="hljs-number"> 74 </span>2d 4c<span class="hljs-number"> 65 </span>6e<span class="hljs-number"> 67 </span>74<span class="hljs-number"> 68 </span>3a |.Content-Length:|<br>|00000020|<span class="hljs-number"> 20 </span>32<span class="hljs-number"> 32 </span>0d 0a 0d 0a 3c<span class="hljs-number"> 68 </span>31 3e<span class="hljs-number"> 48 </span>65 6c 6c 6f | 22....&lt;h1&gt;Hello|<br>|00000030| 2c<span class="hljs-number"> 20 </span>57 6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>21 3c 2f<span class="hljs-number"> 68 </span>31 3e          |, World!&lt;/h1&gt;   |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul><li><p><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</p></li><li><p><strong>版本号</strong>：可以支持协议的升级</p></li><li><p>序列化算法</p><p>：消息正文到底采用哪种序列化反序列化方式</p><ul><li>如：json、protobuf、hessian、jdk</li></ul></li><li><p><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</p></li><li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p></li><li><p><strong>正文长度</strong></p></li><li><p><strong>消息正文</strong></p></li></ul><h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;<br><br>    @Override<br>    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;<br>        <span class="hljs-comment">// 设置魔数 4个字节</span><br>        out.write<span class="hljs-constructor">Bytes(<span class="hljs-params">new</span> <span class="hljs-params">byte</span>[]&#123;&#x27;N&#x27;,&#x27;Y&#x27;,&#x27;I&#x27;,&#x27;M&#x27;&#125;)</span>;<br>        <span class="hljs-comment">// 设置版本号 1个字节</span><br>        out.write<span class="hljs-constructor">Byte(1)</span>;<br>        <span class="hljs-comment">// 设置序列化方式 1个字节</span><br>        out.write<span class="hljs-constructor">Byte(1)</span>;<br>        <span class="hljs-comment">// 设置指令类型 1个字节</span><br>        out.write<span class="hljs-constructor">Byte(<span class="hljs-params">msg</span>.<span class="hljs-params">getMessageType</span>()</span>);<br>        <span class="hljs-comment">// 设置请求序号 4个字节</span><br>        out.write<span class="hljs-constructor">Int(<span class="hljs-params">msg</span>.<span class="hljs-params">getSequenceId</span>()</span>);<br>        <span class="hljs-comment">// 为了补齐为16个字节，填充1个字节的数据</span><br>        out.write<span class="hljs-constructor">Byte(0xff)</span>;<br><br>        <span class="hljs-comment">// 获得序列化后的msg</span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ByteArrayOutputStream()</span>;<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectOutputStream(<span class="hljs-params">bos</span>)</span>;<br>        oos.write<span class="hljs-constructor">Object(<span class="hljs-params">msg</span>)</span>;<br>        byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = bos.<span class="hljs-keyword">to</span><span class="hljs-constructor">ByteArray()</span>;<br><br>        <span class="hljs-comment">// 获得并设置正文长度 长度用4个字节标识</span><br>        out.write<span class="hljs-constructor">Int(<span class="hljs-params">bytes</span>.<span class="hljs-params">length</span>)</span>;<br>        <span class="hljs-comment">// 设置消息正文</span><br>        out.write<span class="hljs-constructor">Bytes(<span class="hljs-params">bytes</span>)</span>;<br>    &#125;<br><br>    @Override<br>    protected void decode(ChannelHandlerContext ctx, ByteBuf <span class="hljs-keyword">in</span>, List&lt;Object&gt; out) throws Exception &#123;<br>        <span class="hljs-comment">// 获取魔数</span><br>        <span class="hljs-built_in">int</span> magic = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Int()</span>;<br>        <span class="hljs-comment">// 获取版本号</span><br>        byte version = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Byte()</span>;<br>        <span class="hljs-comment">// 获得序列化方式</span><br>        byte seqType = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Byte()</span>;<br>        <span class="hljs-comment">// 获得指令类型</span><br>        byte messageType = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Byte()</span>;<br>        <span class="hljs-comment">// 获得请求序号</span><br>        <span class="hljs-built_in">int</span> sequenceId = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Int()</span>;<br>        <span class="hljs-comment">// 移除补齐字节</span><br>        <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Byte()</span>;<br>        <span class="hljs-comment">// 获得正文长度</span><br>        <span class="hljs-built_in">int</span> length = <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Int()</span>;<br>        <span class="hljs-comment">// 获得正文</span><br>        byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-keyword">new</span> byte<span class="hljs-literal">[<span class="hljs-identifier">length</span>]</span>;<br>        <span class="hljs-keyword">in</span>.read<span class="hljs-constructor">Bytes(<span class="hljs-params">bytes</span>, 0, <span class="hljs-params">length</span>)</span>;<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectInputStream(<span class="hljs-params">new</span> ByteArrayInputStream(<span class="hljs-params">bytes</span>)</span>);<br>        Message message = (Message) ois.read<span class="hljs-constructor">Object()</span>;<br><span class="hljs-comment">// 将信息放入List中，传递给下一个handler</span><br>        out.add(message);<br>        <br>        <span class="hljs-comment">// 打印获得的信息正文</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========魔数===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(magic);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========版本号===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(version);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========序列化方法===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(seqType);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========指令类型===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(messageType);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========请求序号===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(sequenceId);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========正文长度===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(length);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===========正文===========&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec&lt;Message&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</li><li>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</li></ul><p><strong>编写测试类</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCodec</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> final org.slf4j.Logger log = LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) throws Exception &#123;<br>        EmbeddedChannel channel = <span class="hljs-keyword">new</span> <span class="hljs-type">EmbeddedChannel</span>();<br>        <span class="hljs-comment">// 添加解码器，避免粘包半包问题</span><br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">LengthFieldBasedFrameDecoder</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">LoggingHandler</span>(LogLevel.DEBUG));<br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">MessageCodec</span>());<br>        LoginRequestMessage user = <span class="hljs-keyword">new</span> <span class="hljs-type">LoginRequestMessage</span>(<span class="hljs-string">&quot;Nyima&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br><br>        <span class="hljs-comment">// 测试编码与解码</span><br>        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer();<br>        <span class="hljs-keyword">new</span> <span class="hljs-type">MessageCodec</span>().encode(<span class="hljs-literal">null</span>, user, byteBuf);<br>        channel.writeInbound(byteBuf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li><li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li></ul><p>运行结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png" alt="img"></a></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.DEBUG)</span>;<br><span class="hljs-comment">// 不同的channel中使用同一个handler对象，提高复用率</span><br>channel1.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br>channel2.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br></code></pre></td></tr></table></figure><p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p><ul><li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li><li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li></ul><p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p><p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p><h4 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p><p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p><p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p><ul><li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png" alt="img"></a></p><p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p><ul><li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li></ul></li></ul><p><strong>如果想要共享，需要怎么办呢？</strong></p><p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@ChannelHandler</span>.<span class="hljs-type">Sharable</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageSharableCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageCodec&lt;ByteBuf</span>, <span class="hljs-title">Message&gt;</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void encode(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">Message</span> msg, <span class="hljs-type">List</span>&lt;<span class="hljs-type">Object</span>&gt; out) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void decode(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">ByteBuf</span> msg, <span class="hljs-type">List</span>&lt;<span class="hljs-type">Object</span>&gt; out) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、在线聊天室"><a href="#3、在线聊天室" class="headerlink" title="3、在线聊天室"></a>3、在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 登录成功返回 true, 否则返回 false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">login</span>(<span class="hljs-title class_">String</span> username, <span class="hljs-title class_">String</span> password);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Session</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 会话绑定用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">bind</span>(<span class="hljs-title class_">Channel</span> channel, <span class="hljs-title class_">String</span> username);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解绑会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要解绑会话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">unbind</span>(<span class="hljs-title class_">Channel</span> channel);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">Object</span> <span class="hljs-title function_">getAttribute</span>(<span class="hljs-title class_">Channel</span> channel, <span class="hljs-title class_">String</span> name);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">setAttribute</span>(<span class="hljs-title class_">Channel</span> channel, <span class="hljs-title class_">String</span> name, <span class="hljs-title class_">Object</span> value);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户名获取 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> <span class="hljs-variable">channel</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">Channel</span> <span class="hljs-title function_">getChannel</span>(<span class="hljs-title class_">String</span> username);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">public</span> interface <span class="hljs-title class_">GroupSession</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> members 成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功时返回组对象, 失败返回 null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">Group</span> <span class="hljs-title function_">createGroup</span>(<span class="hljs-title class_">String</span> <span class="hljs-variable">name</span>, <span class="hljs-title class_">Set</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">members</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加入聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">Group</span> <span class="hljs-title function_">joinMember</span>(<span class="hljs-title class_">String</span> <span class="hljs-variable">name</span>, <span class="hljs-title class_">String</span> <span class="hljs-variable">member</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">Group</span> <span class="hljs-title function_">removeMember</span>(<span class="hljs-title class_">String</span> <span class="hljs-variable">name</span>, <span class="hljs-title class_">String</span> <span class="hljs-variable">member</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">Group</span> <span class="hljs-title function_">removeGroup</span>(<span class="hljs-title class_">String</span> <span class="hljs-variable">name</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员集合, 如果群不存在或没有成员会返回 empty set</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">Set</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-title function_">getMembers</span>(<span class="hljs-title class_">String</span> <span class="hljs-variable">name</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员 channel 集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">List</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Channel</span><span class="hljs-operator">&gt;</span> <span class="hljs-title function_">getMembersChannel</span>(<span class="hljs-title class_">String</span> <span class="hljs-variable">name</span>);<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断群聊是否一被创建</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 群聊名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">boolean</span> <span class="hljs-title function_">isCreated</span>(<span class="hljs-title class_">String</span> <span class="hljs-variable">name</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png" alt="img"></a></p><ul><li>client包：存放客户端相关类</li><li>message包：存放各种类型的消息</li><li>protocol包：存放自定义协议</li><li>server包：存放服务器相关类<ul><li>service包：存放用户相关类</li><li>session包：单聊及群聊相关会话类</li></ul></li></ul><h4 id="客户端代码结构"><a href="#客户端代码结构" class="headerlink" title="客户端代码结构"></a>客户端代码结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatClient</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(ChatClient.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">loggingHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br>        <span class="hljs-type">MessageSharableCodec</span> <span class="hljs-variable">messageSharableCodec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageSharableCodec</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.group(group);<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtocolFrameDecoder</span>());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> bootstrap.connect().sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务器代码结构"><a href="#服务器代码结构" class="headerlink" title="服务器代码结构"></a>服务器代码结构</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ChatServer &#123;<br>    static final Logger log = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(ChatServer.<span class="hljs-params">class</span>)</span>;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.DEBUG)</span>;<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageSharableCodec()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span>;<br>            bootstrap.group(boss, worker);<br>            bootstrap.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>);<br>            bootstrap.child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                @Override<br>                protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ProtocolFrameDecoder()</span>);<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">messageSharableCodec</span>)</span>;<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.bind(<span class="hljs-number">8080</span>).sync<span class="hljs-literal">()</span>.channel<span class="hljs-literal">()</span>;<br>            channel.close<span class="hljs-constructor">Future()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            boss.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>            worker.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ChannelInboundHandlerAdapter()</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建连接时执行的处理器，用于执行登陆操作</span><br><span class="hljs-comment">     */</span><br>    @Override<br>    public void channel<span class="hljs-constructor">Active(ChannelHandlerContext <span class="hljs-params">ctx</span>)</span> throws Exception &#123;<br>        <span class="hljs-comment">// 开辟额外线程，用于用户登陆及后续操作</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt;&#123;<br>            Scanner scanner = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scanner(System.<span class="hljs-params">in</span>)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;请输入用户名&quot;</span>);<br>            String username = scanner.next<span class="hljs-literal">()</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;请输入密码&quot;</span>);<br>            String password = scanner.next<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 创建包含登录信息的请求体</span><br>            LoginRequestMessage message = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoginRequestMessage(<span class="hljs-params">username</span>, <span class="hljs-params">password</span>)</span>;<br>            <span class="hljs-comment">// 发送到channel中</span><br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">message</span>)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;等待后续操作...&quot;</span>);<br>            <span class="hljs-comment">// 阻塞，直到登陆成功后CountDownLatch被设置为0</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                waitLogin.await<span class="hljs-literal">()</span>;<br>            &#125; catch (InterruptedException e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>            &#125;<br>            <span class="hljs-comment">// 执行后续操作</span><br>            <span class="hljs-keyword">if</span> (!loginStatus.get<span class="hljs-literal">()</span>) &#123;<br>                <span class="hljs-comment">// 登陆失败，关闭channel并返回</span><br>                ctx.channel<span class="hljs-literal">()</span>.close<span class="hljs-literal">()</span>;<br>                return;<br>            &#125;<br>            <span class="hljs-comment">// 登录成功后，执行其他操作</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;send [username] [content]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gsend [group name] [content]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gmembers [group name]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gjoin [group name]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;gquit [group name]&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;quit&quot;</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                String command = scanner.next<span class="hljs-constructor">Line()</span>;<br>                <span class="hljs-comment">// 获得指令及其参数，并发送对应类型消息</span><br>                String<span class="hljs-literal">[]</span> commands = command.split(<span class="hljs-string">&quot; &quot;</span>);<br>                switch (commands<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>)&#123;<br>                    case <span class="hljs-string">&quot;send&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> ChatRequestMessage(<span class="hljs-params">username</span>, <span class="hljs-params">commands</span>[1], <span class="hljs-params">commands</span>[2])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gsend&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupChatRequestMessage(<span class="hljs-params">username</span>,<span class="hljs-params">commands</span>[1], <span class="hljs-params">commands</span>[2])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gcreate&quot;</span>:<br>                        <span class="hljs-comment">// 分割，获得群员名</span><br>                        String<span class="hljs-literal">[]</span> members = commands<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.split(<span class="hljs-string">&quot;,&quot;</span>);<br>                        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">members</span>)</span>);<br>                        <span class="hljs-comment">// 把自己加入到群聊中</span><br>                        set.add(username);<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupCreateRequestMessage(<span class="hljs-params">commands</span>[1],<span class="hljs-params">set</span>)</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gmembers&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupMembersRequestMessage(<span class="hljs-params">commands</span>[1])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gjoin&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupJoinRequestMessage(<span class="hljs-params">username</span>, <span class="hljs-params">commands</span>[1])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;gquit&quot;</span>:<br>                        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupQuitRequestMessage(<span class="hljs-params">username</span>, <span class="hljs-params">commands</span>[1])</span>);<br>                        break;<br>                    case <span class="hljs-string">&quot;quit&quot;</span>:<br>                        ctx.channel<span class="hljs-literal">()</span>.close<span class="hljs-literal">()</span>;<br>                        return;<br>                    default:<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;指令有误，请重新输入&quot;</span>);<br>                        continue;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;login channel&quot;</span>).start<span class="hljs-literal">()</span>;<br>    &#125;<br><br>    @Override<br>    public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-keyword">if</span> (msg instanceof LoginResponseMessage) &#123;<br>            <span class="hljs-comment">// 如果是登录响应信息</span><br>            LoginResponseMessage message = (LoginResponseMessage) msg;<br>            boolean isSuccess = message.is<span class="hljs-constructor">Success()</span>;<br>            <span class="hljs-comment">// 登录成功，设置登陆标记</span><br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                loginStatus.set(<span class="hljs-literal">true</span>);<br>            &#125;<br>            <span class="hljs-comment">// 登陆后，唤醒登陆线程</span><br>            waitLogin.count<span class="hljs-constructor">Down()</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@ChannelHandler.Sharable <span class="hljs-comment">// 必须添加该注解</span><br>public <span class="hljs-keyword">class</span> LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, LoginRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        <span class="hljs-comment">// 获得登录信息</span><br>        String username = msg.get<span class="hljs-constructor">Username()</span>;<br>        String password = msg.get<span class="hljs-constructor">Password()</span>;<br>        <span class="hljs-comment">// 校验登录信息</span><br>        boolean login = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserServiceFactory</span>.</span></span>get<span class="hljs-constructor">UserService()</span>.login(username, password);<br>        LoginResponseMessage message;<br>        <span class="hljs-keyword">if</span> (login) &#123;<br>            message = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoginResponseMessage(<span class="hljs-params">true</span>, <span class="hljs-string">&quot;登陆成功&quot;</span>)</span>;<br>            <span class="hljs-comment">// 绑定channel与user</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SessionFactory</span>.</span></span>get<span class="hljs-constructor">Session()</span>.bind(ctx.channel<span class="hljs-literal">()</span>, username);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            message = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoginResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;登陆失败&quot;</span>)</span>;<br>        &#125;<br>        ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">message</span>)</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理登录请求</span><br>LoginRequestMessageHandler loginRequestMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoginRequestMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> LoginRequestMessageHandler()</span>);<br></code></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">5665</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.MessageSharableCodec</span>  - <span class="hljs-number">1314474317</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">279</span><br><span class="hljs-number">5667</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.MessageSharableCodec</span>  - message:AbstractResponseMessage&#123;success=true, reason=<span class="hljs-string">&#x27;登陆成功&#x27;</span>&#125;<br><span class="hljs-number">5667</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-string">&#x27;登陆成功&#x27;</span>&#125;<br>success<br></code></pre></td></tr></table></figure><p><strong>服务器</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tap">11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - 1314474317, 1, 1, 0, 0, 217<br>11919 [nioEventLoopGroup-3-1] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:LoginRequestMessage&#123;username=&#x27;Nyima&#x27;, password=&#x27;123&#x27;&#125;<br><br>7946 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x8e7c07f6, L:/127.0.0.1:8080 - R:/127.0.0.1:60572] WRITE: 295B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 4e<span class="hljs-number"> 59 </span>49 4d<span class="hljs-number"> 01 </span>01<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 01 </span>17 |NYIM............|<br>|00000010| ac ed<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 73 </span>72<span class="hljs-number"> 00 </span>31<span class="hljs-number"> 63 </span>6e 2e 6e<span class="hljs-number"> 79 </span>69 6d<span class="hljs-number"> 61 </span>|....sr.1cn.nyima|<br>|00000020|<span class="hljs-number"> 63 </span>2e<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 75 </span>64<span class="hljs-number"> 79 </span>2e<span class="hljs-number"> 64 </span>61<span class="hljs-number"> 79 </span>38 2e 6d<span class="hljs-number"> 65 </span>73 |c.study.day8.mes|<br>|00000030|<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 2e 4c 6f<span class="hljs-number"> 67 </span>69 6e<span class="hljs-number"> 52 </span>65<span class="hljs-number"> 73 </span>70 6f 6e |sage.LoginRespon|<br>|00000040|<span class="hljs-number"> 73 </span>65 4d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 e2<span class="hljs-number"> 34 </span>49<span class="hljs-number"> 24 </span>72<span class="hljs-number"> 52 </span>f3 |seMessage.4I$rR.|<br>|00000050|<span class="hljs-number"> 07 </span>02<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 78 </span>72<span class="hljs-number"> 00 </span>34<span class="hljs-number"> 63 </span>6e 2e 6e<span class="hljs-number"> 79 </span>69 6d<span class="hljs-number"> 61 </span>|....xr.4cn.nyima|<br>|00000060|<span class="hljs-number"> 63 </span>2e<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 75 </span>64<span class="hljs-number"> 79 </span>2e<span class="hljs-number"> 64 </span>61<span class="hljs-number"> 79 </span>38 2e 6d<span class="hljs-number"> 65 </span>73 |c.study.day8.mes|<br>|00000070|<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 2e<span class="hljs-number"> 41 </span>62<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 72 </span>61<span class="hljs-number"> 63 </span>74<span class="hljs-number"> 52 </span>65<span class="hljs-number"> 73 </span>|sage.AbstractRes|<br>|00000080|<span class="hljs-number"> 70 </span>6f 6e<span class="hljs-number"> 73 </span>65 4d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 b3 7e<span class="hljs-number"> 19 </span>32 |ponseMessage.~.2|<br>|00000090| 9b<span class="hljs-number"> 88 </span>4d 7b<span class="hljs-number"> 02 </span>00<span class="hljs-number"> 02 </span>5a<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 73 </span>75<span class="hljs-number"> 63 </span>63<span class="hljs-number"> 65 </span>73 |..M&#123;...Z..succes|<br>|000000a0|<span class="hljs-number"> 73 </span>4c<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 72 </span>65<span class="hljs-number"> 61 </span>73 6f 6e<span class="hljs-number"> 74 </span>00<span class="hljs-number"> 12 </span>4c 6a<span class="hljs-number"> 61 </span>|sL..reasont..Lja|<br>|000000b0|<span class="hljs-number"> 76 </span>61 2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69 6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 78 </span>|va/lang/String;x|<br>|000000c0|<span class="hljs-number"> 72 </span>00<span class="hljs-number"> 24 </span>63 6e 2e 6e<span class="hljs-number"> 79 </span>69 6d<span class="hljs-number"> 61 </span>63 2e<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 75 </span>|r.$cn.nyimac.stu|<br>|000000d0|<span class="hljs-number"> 64 </span>79 2e<span class="hljs-number"> 64 </span>61<span class="hljs-number"> 79 </span>38 2e 6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 2e |dy.day8.message.|<br>|000000e0| 4d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 dd e9<span class="hljs-number"> 84 </span>b7<span class="hljs-number"> 21 </span>db<span class="hljs-number"> 18 </span>52<span class="hljs-number"> 02 </span>|Message....!..R.|<br>|000000f0|<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 49 </span>00 0b 6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65<span class="hljs-number"> 54 </span>79<span class="hljs-number"> 70 </span>65 |..I..messageType|<br>|00000100|<span class="hljs-number"> 49 </span>00 0a<span class="hljs-number"> 73 </span>65<span class="hljs-number"> 71 </span>75<span class="hljs-number"> 65 </span>6e<span class="hljs-number"> 63 </span>65<span class="hljs-number"> 49 </span>64<span class="hljs-number"> 78 </span>70<span class="hljs-number"> 00 </span>|I..sequenceIdxp.|<br>|00000110|<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 74 </span>00 0c e7<span class="hljs-number"> 99 </span>bb e9<span class="hljs-number"> 99 </span>|........t.......|<br>|00000120|<span class="hljs-number"> 86 </span>e6<span class="hljs-number"> 88 </span>90 e5 8a 9f                            |.......         |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@ChannelHandler.Sharable <span class="hljs-comment">// 必须添加该注解</span><br>public <span class="hljs-keyword">class</span> ChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;ChatRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, ChatRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        <span class="hljs-comment">// 获得user所在的channel</span><br>        Channel channel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SessionFactory</span>.</span></span>get<span class="hljs-constructor">Session()</span>.get<span class="hljs-constructor">Channel(<span class="hljs-params">msg</span>.<span class="hljs-params">getTo</span>()</span>);<br>        <span class="hljs-comment">// 如果双方都在线</span><br>        <span class="hljs-keyword">if</span> (channel != null) &#123;<br>            <span class="hljs-comment">// 通过接收方与服务器之间的channel发送信息</span><br>            channel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> ChatResponseMessage(<span class="hljs-params">msg</span>.<span class="hljs-params">getFrom</span>()</span>, msg.get<span class="hljs-constructor">Content()</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 通过发送方与服务器之间的channel发送消息</span><br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> ChatResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;对方用户不存在或离线，发送失败&quot;</span>)</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理单聊请求</span><br>ChatRequestMessageHandler chatRequestMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChatRequestMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">chatRequestMessageHandler</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方（zhangsan）</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">send</span> Nyima hello<br></code></pre></td></tr></table></figure><p>接收方（Nyima）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 收到zhangsan发来的消息</span><br><span class="hljs-number">20230</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - ChatResponseMessage&#123;from=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;hello&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> GroupCreateMessageHandler extends SimpleChannelInboundHandler&lt;GroupCreateRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, GroupCreateRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        <span class="hljs-comment">// 获得要创建的群聊名</span><br>        String groupName = msg.get<span class="hljs-constructor">GroupName()</span>;<br>        <span class="hljs-comment">// 获得要创建的群聊的成员组</span><br>        Set&lt;String&gt; members = msg.get<span class="hljs-constructor">Members()</span>;<br>        <span class="hljs-comment">// 判断该群聊是否创建过，未创建返回null并创建群聊</span><br>        Group group = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>.create<span class="hljs-constructor">Group(<span class="hljs-params">groupName</span>, <span class="hljs-params">members</span>)</span>;<br>        <span class="hljs-keyword">if</span> (group<span class="hljs-operator"> == </span>null) &#123;<br>            <span class="hljs-comment">// 发送创建成功消息</span><br>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupCreateResponseMessage(<span class="hljs-params">true</span>, <span class="hljs-params">groupName</span> + <span class="hljs-string">&quot;创建成功&quot;</span>)</span>;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">groupCreateResponseMessage</span>)</span>;<br>            <span class="hljs-comment">// 获得在线群员的channel，给群员发送入群聊消息</span><br>            List&lt;Channel&gt; membersChannel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>.get<span class="hljs-constructor">MembersChannel(<span class="hljs-params">groupName</span>)</span>;<br>            groupCreateResponseMessage = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupCreateResponseMessage(<span class="hljs-params">true</span>, <span class="hljs-string">&quot;您已被拉入&quot;</span>+<span class="hljs-params">groupName</span>)</span>;<br>            <span class="hljs-comment">// 给每个在线群员发送消息</span><br>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;<br>                channel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">groupCreateResponseMessage</span>)</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 发送失败消息</span><br>            GroupCreateResponseMessage groupCreateResponseMessage = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupCreateResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-params">groupName</span> + <span class="hljs-string">&quot;已存在&quot;</span>)</span>;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">groupCreateResponseMessage</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理创建群聊请求</span><br>GroupCreateMessageHandler groupCreateMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupCreateMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">groupCreateMessageHandler</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>创建者客户端</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 首次创建</span><br>gcreate Netty学习 zhangsan,lisi<br><br><span class="hljs-number">31649</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-string">&#x27;Netty学习创建成功&#x27;</span>&#125;<br><span class="hljs-number">15244</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-string">&#x27;您已被拉入Netty学习&#x27;</span>&#125;<br><br><br><span class="hljs-comment">// 再次创建</span><br>gcreate Netty学习 zhangsan,lisi<br><span class="hljs-number">40771</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - AbstractResponseMessage&#123;success=false, reason=<span class="hljs-string">&#x27;Netty学习已存在&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>群员客户端</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">28788 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-comment">&#x27;您已被拉入Netty学习&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> GroupChatMessageHandler extends SimpleChannelInboundHandler&lt;GroupChatRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, GroupChatRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        String groupName = msg.get<span class="hljs-constructor">GroupName()</span>;<br>        GroupSession groupSession = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>;<br>        <span class="hljs-comment">// 判断群聊是否存在</span><br>        boolean isCreated = groupSession.is<span class="hljs-constructor">Created(<span class="hljs-params">groupName</span>)</span>;<br>        <span class="hljs-keyword">if</span> (isCreated) &#123;<br>            <span class="hljs-comment">// 给群员发送信息</span><br>            List&lt;Channel&gt; membersChannel = groupSession.get<span class="hljs-constructor">MembersChannel(<span class="hljs-params">groupName</span>)</span>;<br>            <span class="hljs-keyword">for</span>(Channel channel : membersChannel) &#123;<br>                channel.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupChatResponseMessage(<span class="hljs-params">msg</span>.<span class="hljs-params">getFrom</span>()</span>, msg.get<span class="hljs-constructor">Content()</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupChatResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;群聊不存在&quot;</span>)</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理群聊聊天</span><br>GroupChatMessageHandler groupChatMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupChatMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">groupChatMessageHandler</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方（群聊存在）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gsend Netty学习 你们好<br><br><span class="hljs-number">45408</span> <span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG cn<span class="hljs-selector-class">.nyimac</span><span class="hljs-selector-class">.study</span><span class="hljs-selector-class">.day8</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span>  - GroupChatResponseMessage&#123;from=<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attribute">content</span>=<span class="hljs-string">&#x27;你们好&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>接收方</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">48082 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from=<span class="hljs-comment">&#x27;zhangsan&#x27;, content=&#x27;你们好&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>发送方（群聊不存在）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">gsend Spring学习 你们好<br><br>25140 [nioEventLoopGroup-2-1] <span class="hljs-built_in">DEBUG</span> cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;<span class="hljs-attribute">success</span>=<span class="hljs-literal">false</span>, <span class="hljs-attribute">reason</span>=<span class="hljs-string">&#x27;群聊不存在&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> GroupJoinMessageHandler extends SimpleChannelInboundHandler&lt;GroupJoinRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, GroupJoinRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        GroupSession groupSession = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>;<br>        <span class="hljs-comment">// 判断该用户是否在群聊中</span><br>        Set&lt;String&gt; members = groupSession.get<span class="hljs-constructor">Members(<span class="hljs-params">msg</span>.<span class="hljs-params">getGroupName</span>()</span>);<br>        boolean joinFlag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 群聊存在且用户未加入，才能加入</span><br>        <span class="hljs-keyword">if</span> (!members.contains(msg.get<span class="hljs-constructor">Username()</span>)<span class="hljs-operator"> &amp;&amp; </span>groupSession.is<span class="hljs-constructor">Created(<span class="hljs-params">msg</span>.<span class="hljs-params">getGroupName</span>()</span>)) &#123;<br>            joinFlag = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 加入群聊</span><br>            groupSession.join<span class="hljs-constructor">Member(<span class="hljs-params">msg</span>.<span class="hljs-params">getGroupName</span>()</span>, msg.get<span class="hljs-constructor">Username()</span>);<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupJoinResponseMessage(<span class="hljs-params">true</span>,<span class="hljs-string">&quot;加入&quot;</span>+<span class="hljs-params">msg</span>.<span class="hljs-params">getGroupName</span>()</span>+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupJoinResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;加入失败，群聊未存在或您已加入该群聊&quot;</span>)</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理加入群聊</span><br>GroupJoinMessageHandler groupJoinMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupJoinMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">groupJoinMessageHandler</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>正常加入群聊</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">94921 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-comment">&#x27;加入Netty学习成功&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>加入不能存在或已加入的群聊</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">44025 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=<span class="hljs-comment">&#x27;加入失败，群聊未存在或您已加入该群聊&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> GroupQuitMessageHandler extends SimpleChannelInboundHandler&lt;GroupQuitRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, GroupQuitRequestMessage <span class="hljs-params">msg</span>)</span> throws Exception &#123;<br>        GroupSession groupSession = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GroupSessionFactory</span>.</span></span>get<span class="hljs-constructor">GroupSession()</span>;<br>        String groupName = msg.get<span class="hljs-constructor">GroupName()</span>;<br>        Set&lt;String&gt; members = groupSession.get<span class="hljs-constructor">Members(<span class="hljs-params">groupName</span>)</span>;<br>        String username = msg.get<span class="hljs-constructor">Username()</span>;<br>        <span class="hljs-comment">// 判断用户是否在群聊中以及群聊是否存在</span><br>        boolean joinFlag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (groupSession.is<span class="hljs-constructor">Created(<span class="hljs-params">groupName</span>)</span><span class="hljs-operator"> &amp;&amp; </span>members.contains(username)) &#123;<br>            <span class="hljs-comment">// 可以退出</span><br>            joinFlag = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (joinFlag) &#123;<br>            <span class="hljs-comment">// 退出成功</span><br>            groupSession.remove<span class="hljs-constructor">Member(<span class="hljs-params">groupName</span>, <span class="hljs-params">username</span>)</span>;<br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupQuitResponseMessage(<span class="hljs-params">true</span>, <span class="hljs-string">&quot;退出&quot;</span>+<span class="hljs-params">groupName</span>+<span class="hljs-string">&quot;成功&quot;</span>)</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 退出失败</span><br>            ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">new</span> GroupQuitResponseMessage(<span class="hljs-params">false</span>, <span class="hljs-string">&quot;群聊不存在或您未加入该群，退出&quot;</span>+<span class="hljs-params">groupName</span>+<span class="hljs-string">&quot;失败&quot;</span>)</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理退出群聊</span><br>GroupQuitMessageHandler groupQuitMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GroupQuitMessageHandler()</span>;<br>ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">groupQuitMessageHandler</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>正常退出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">32282 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=true, reason=<span class="hljs-comment">&#x27;退出Netty学习成功&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>退出不存在或未加入的群聊</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">67404 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=false, reason=<span class="hljs-comment">&#x27;群聊不存在或您未加入该群，退出Netty失败&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@ChannelHandler</span>.<span class="hljs-type">Sharable</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupMembersMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler&lt;GroupMembersRequestMessage&gt;</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void channelRead0(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">GroupMembersRequestMessage</span> msg) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-type">GroupMembersResponseMessage</span>(<span class="hljs-type">GroupSessionFactory</span>.getGroupSession().getMembers(msg.getGroupName())));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理查看成员</span><br><span class="hljs-type">GroupMembersMessageHandler</span> groupMembersMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-type">GroupMembersMessageHandler</span>();<br>ch.pipeline().addLast(groupMembersMessageHandler);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">46557 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupMembersResponseMessage&#123;members=[zhangsan, Nyima]&#125;<br></code></pre></td></tr></table></figure><h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@ChannelHandler</span>.<span class="hljs-type">Sharable</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuitHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断开连接时触发 Inactive事件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    public void channelInactive(<span class="hljs-type">ChannelHandlerContext</span> ctx) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-comment">// 解绑</span><br>        <span class="hljs-type">SessionFactory</span>.getSession().unbind(ctx.channel());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常退出，需要解绑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    public void exceptionCaught(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">Throwable</span> cause) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-comment">// 解绑</span><br>        <span class="hljs-type">SessionFactory</span>.getSession().unbind(ctx.channel());<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该handler处理退出聊天室</span><br>ch.pipeline().addLast(quitHandler);<br><span class="hljs-type">GroupMembersMessageHandler</span> groupMembersMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-type">GroupMembersMessageHandler</span>();<br></code></pre></td></tr></table></figure><p><strong>退出时，客户端会关闭channel并返回</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br><span class="hljs-comment">// 关闭channel并返回</span><br>    ctx.channel().<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>原因</strong></p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p><strong>问题</strong></p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p><ul><li>readerIdleTimeSeconds 读空闲经过的秒数</li><li>writerIdleTimeSeconds 写空闲经过的秒数</li><li>allIdleTimeSeconds 读和写空闲经过的秒数</li></ul><p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png" alt="img"></a></p><ul><li>读空闲会触发<code>READER_IDLE</code></li><li>写空闲会触发<code>WRITE_IDLE</code></li><li>读和写空闲会触发<code>ALL_IDEL</code></li></ul><p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p><p><strong>服务器端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br><span class="hljs-comment">// 添加双向处理器，负责处理READER_IDLE事件</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelDuplexHandler</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获得事件</span><br>        <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> (IdleStateEvent) evt;<br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;<br>            <span class="hljs-comment">// 断开连接</span><br>            ctx.channel().close();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><p>使用<code>IdleStateHandler</code>进行空闲检测</p></li><li><p>使用双向处理器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ChannelDuplexHandler</span><br></code></pre></td></tr></table></figure><p>对入站与出站事件进行处理</p><ul><li><code>IdleStateHandler</code>中的事件为特殊事件，需要实现<code>ChannelDuplexHandler</code>的<code>userEventTriggered</code>方法，判断事件类型并自定义处理方式，来对事件进行处理</li></ul></li></ul><p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p><p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发送心跳包，让服务器知道客户端在线</span><br><span class="hljs-comment">// 3s未发生WRITER_IDLE，就像服务器发送心跳包</span><br><span class="hljs-comment">// 该值为服务器端设置的READER_IDLE触发时间的一半左右</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelDuplexHandler</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> (IdleStateEvent) evt;<br>        <span class="hljs-keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;<br>            <span class="hljs-comment">// 发送心跳包</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PingMessage</span>());<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h1><h2 id="1、拓展序列化算法"><a href="#1、拓展序列化算法" class="headerlink" title="1、拓展序列化算法"></a>1、拓展序列化算法</h2><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> object 被序列化的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 被序列化对象类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 序列化后的字节数组</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-keyword">byte</span>[] serialize(T object);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz 反序列化的目标类的Class对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes 被反序列化的字节数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 反序列化目标类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反序列化后的对象</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-keyword">byte</span>[] bytes)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SerializerAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br>    <span class="hljs-comment">// Java的序列化和反序列化</span><br>    <span class="hljs-title class_">Java</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; byte[] <span class="hljs-title function_">serialize</span>(<span class="hljs-params">T <span class="hljs-built_in">object</span></span>) &#123;<br>            <span class="hljs-comment">// 序列化后的字节数组</span><br>            byte[] bytes = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-title class_">ByteArrayOutputStream</span> bos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>                 <span class="hljs-title class_">ObjectOutputStream</span> oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos)) &#123;<br>                oos.<span class="hljs-title function_">writeObject</span>(<span class="hljs-built_in">object</span>);<br>                bytes = bos.<span class="hljs-title function_">toByteArray</span>();<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> e) &#123;<br>                e.<span class="hljs-title function_">printStackTrace</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> bytes;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">Class&lt;T&gt; clazz, byte[] bytes</span>) &#123;<br>            T target = <span class="hljs-literal">null</span>;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">toString</span>(bytes));<br>            <span class="hljs-keyword">try</span> (<span class="hljs-title class_">ByteArrayInputStream</span> bis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>                 <span class="hljs-title class_">ObjectInputStream</span> ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis)) &#123;<br>                target = (T) ois.<span class="hljs-title function_">readObject</span>();<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> | <span class="hljs-title class_">ClassNotFoundException</span> e) &#123;<br>                e.<span class="hljs-title function_">printStackTrace</span>();<br>            &#125;<br>            <span class="hljs-comment">// 返回反序列化后的对象</span><br>            <span class="hljs-keyword">return</span> target;<br>        &#125;<br>    &#125;<br>    <br>     <span class="hljs-comment">// Json的序列化和反序列化</span><br>    <span class="hljs-title class_">Json</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; byte[] <span class="hljs-title function_">serialize</span>(<span class="hljs-params">T <span class="hljs-built_in">object</span></span>) &#123;<br>            <span class="hljs-title class_">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>().<span class="hljs-title function_">toJson</span>(<span class="hljs-built_in">object</span>);<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s);<br>            <span class="hljs-comment">// 指定字符集，获得字节数组</span><br>            <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">getBytes</span>(<span class="hljs-title class_">StandardCharsets</span>.<span class="hljs-property">UTF_8</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span>(<span class="hljs-params">Class&lt;T&gt; clazz, byte[] bytes</span>) &#123;<br>            <span class="hljs-title class_">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-title class_">StandardCharsets</span>.<span class="hljs-property">UTF_8</span>);<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(s);<br>            <span class="hljs-comment">// 此处的clazz为具体类型的Class对象，而不是父类Message的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>().<span class="hljs-title function_">fromJson</span>(s, clazz);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获得序列化后的msg<br><span class="hljs-regexp">//</span> 使用指定的序列化方式<br>SerializerAlgorithm[] values = SerializerAlgorithm.values();<br><span class="hljs-regexp">//</span> 获得序列化后的对象<br>byte[] bytes = values[out.getByte(<span class="hljs-number">5</span>)-<span class="hljs-number">1</span>].serialize(msg);<br></code></pre></td></tr></table></figure><p><strong>解码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 获得反序列化方式</span><br>SerializerAlgorithm<span class="hljs-literal">[]</span> values = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SerializerAlgorithm</span>.</span></span>values<span class="hljs-literal">()</span>;<br><span class="hljs-comment">// 通过指定方式进行反序列化</span><br><span class="hljs-comment">// 需要通过Message的方法获得具体的消息类型</span><br>Message message = values<span class="hljs-literal">[<span class="hljs-identifier">seqType</span>-<span class="hljs-number">1</span>]</span>.deserialize(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Message</span>.</span></span>get<span class="hljs-constructor">MessageClass(<span class="hljs-params">messageType</span>)</span>, <span class="hljs-built_in">bytes</span>);<br></code></pre></td></tr></table></figure><h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li>属于 <strong>SocketChannal</strong> 的参数</li><li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li><li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestParam</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">Bootstrap</span>().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>        <br>        <span class="hljs-comment">// ServerSocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ServerBootstrap</span>().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,<span class="hljs-number">5000</span>);<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-type">ServerBootstrap</span>().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong> </p></li><li><p>服务器通过 </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ServerBootstrap</span><br></code></pre></td></tr></table></figure><p>来配置参数，但是对于不同的 Channel 需要选择不同的方法</p><ul><li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li><li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li></ul></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p><p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(</span><br><span class="hljs-params">                <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// Schedule connect timeout.</span><br>    <span class="hljs-comment">// 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">connectTimeoutMillis</span> <span class="hljs-operator">=</span> config().getConnectTimeoutMillis();<br>    <span class="hljs-comment">// 如果超时时间大于0</span><br>    <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行</span><br>        <span class="hljs-comment">// schedule(Runnable command, long delay, TimeUnit unit)</span><br>        connectTimeoutFuture = eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 判断是否建立连接，Promise进行NIO线程与主线程之间的通信</span><br>                <span class="hljs-comment">// 如果超时，则通过tryFailure方法将异常放入Promise中</span><br>                <span class="hljs-comment">// 在主线程中抛出</span><br>                <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">connectPromise</span> <span class="hljs-operator">=</span> AbstractNioChannel.<span class="hljs-built_in">this</span>.connectPromise;<br>                <span class="hljs-type">ConnectTimeoutException</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectTimeoutException</span>(<span class="hljs-string">&quot;connection timed out: &quot;</span> + remoteAddress);<br>                <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-literal">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;<br>                    close(voidPromise());<br>                &#125;<br>            &#125;<br>        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>   ...<br>        <br>&#125;<br></code></pre></td></tr></table></figure><p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p><ul><li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li><li>如果指定时间内没有建立连接，则会执行其中的任务<ul><li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li></ul></li></ul><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p><h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png" alt="img"></a></p><p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png" alt="img"></a></p><p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png" alt="img"></a></p><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p><ul><li>半连接队列 - sync queue<ul><li>大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li>全连接队列 - accept queue<ul><li>其大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p><p><strong>设置方式如下</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 设置全连接队列，大小为2</span><br>new <span class="hljs-built_in">ServerBootstrap</span>()<span class="hljs-selector-class">.option</span>(ChannelOption.SO_BACKLOG, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind(SocketAddress <span class="hljs-params">localAddress</span>)</span> throws Exception &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PlatformDependent</span>.</span></span>java<span class="hljs-constructor">Version()</span> &gt;= <span class="hljs-number">7</span>) &#123;<br>        java<span class="hljs-constructor">Channel()</span>.bind(localAddress, config.get<span class="hljs-constructor">Backlog()</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        java<span class="hljs-constructor">Channel()</span>.socket<span class="hljs-literal">()</span>.bind(localAddress, config.get<span class="hljs-constructor">Backlog()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> backlog = NetUtil.SOMAXCONN;<br></code></pre></td></tr></table></figure><p>具体的赋值操作如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">SOMAXCONN = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AccessController</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Privileged(<span class="hljs-params">new</span> PrivilegedAction&lt;Integer&gt;()</span> &#123;<br>    @Override<br>    public Integer run<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-comment">// Determine the default somaxconn (server socket backlog) value of the platform.</span><br>        <span class="hljs-comment">// The known defaults:</span><br>        <span class="hljs-comment">// - Windows NT Server 4.0+: 200</span><br>        <span class="hljs-comment">// - Linux and Mac OS X: 128</span><br>        <span class="hljs-built_in">int</span> somaxconn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PlatformDependent</span>.</span></span>is<span class="hljs-constructor">Windows()</span> ? <span class="hljs-number">200</span> : <span class="hljs-number">128</span>;<br>        File file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-string">&quot;/proc/sys/net/core/somaxconn&quot;</span>)</span>;<br>        BufferedReader <span class="hljs-keyword">in</span> = null;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the</span><br>            <span class="hljs-comment">// try / catch block.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/4936</span><br>            <span class="hljs-keyword">if</span> (file.exists<span class="hljs-literal">()</span>) &#123;<br>                <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BufferedReader(<span class="hljs-params">new</span> FileReader(<span class="hljs-params">file</span>)</span>);<br>                <span class="hljs-comment">// 将somaxconn设置为Linux配置文件中设置的值</span><br>                somaxconn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">in</span>.<span class="hljs-params">readLine</span>()</span>);<br>                <span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">DebugEnabled()</span>) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, file, somaxconn);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">                ...</span><br><span class="hljs-operator">            </span>&#125;<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">        </span>&#125;  <br>        <span class="hljs-comment">// 返回backlog的值</span><br>        return somaxconn;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>backlog的值会根据操作系统的不同，来</p><p>选择不同的默认值</p><ul><li>Windows 200</li><li>Linux&#x2F;Mac OS 128</li></ul></li><li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p></li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li><li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li></ul><h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li><li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li><li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li></ul><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型</span><br><span class="hljs-comment">// 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型</span><br><span class="hljs-keyword">new</span> <span class="hljs-type">ServerBootstrap</span>().childOption(ChannelOption.ALLOCATOR, <span class="hljs-keyword">new</span> <span class="hljs-type">PooledByteBufAllocator</span>());<br></code></pre></td></tr></table></figure><p><strong>ByteBufAllocator类型</strong></p><ul><li><p>池化并使用直接内存</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// true表示使用直接内存</span><br><span class="hljs-keyword">new</span> <span class="hljs-type">PooledByteBufAllocator</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></li></ul><p>池化并使用堆内存</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> <span class="hljs-type">PooledByteBufAllocator</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>非池化并使用直接内存</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// ture表示使用直接内存</span><br><span class="hljs-keyword">new</span> <span class="hljs-type">UnpooledByteBufAllocator</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>非池化并使用堆内存</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> <span class="hljs-type">UnpooledByteBufAllocator</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li><strong>控制 Netty 接收缓冲区大小</strong></li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li></ul><h2 id="3、RPC框架"><a href="#3、RPC框架" class="headerlink" title="3、RPC框架"></a>3、RPC框架</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在聊天室代码的基础上进行一定的改进</p><p><strong>Message</strong>中添加如下代码</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_ inherited__">Serializable</span> &#123;<br><br>    ...<br><br>    <span class="hljs-comment">// 添加RPC消息类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> RPC_MESSAGE_TYPE_REQUEST = <span class="hljs-number">101</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span>  RPC_MESSAGE_TYPE_RESPONSE = <span class="hljs-number">102</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 将消息类型放入消息类对象Map中</span><br>        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.<span class="hljs-keyword">class</span>);<br>        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.<span class="hljs-keyword">class</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RPC请求消息</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRequestMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Message</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用的接口全限定名，服务端根据它找到实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> interfaceName;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用接口中的方法名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> methodName;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法返回类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Class</span>&lt;?&gt; returnType;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数类型数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Class</span>[] parameterTypes;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法参数值数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Object</span>[] parameterValue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">RpcRequestMessage</span>(int sequenceId, <span class="hljs-title class_">String</span> interfaceName, <span class="hljs-title class_">String</span> methodName, <span class="hljs-title class_">Class</span>&lt;?&gt; returnType, <span class="hljs-title class_">Class</span>[] parameterTypes, <span class="hljs-title class_">Object</span>[] parameterValue) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">setSequenceId</span>(sequenceId);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">interfaceName</span> = interfaceName;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodName</span> = methodName;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">returnType</span> = returnType;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">parameterTypes</span> = parameterTypes;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">parameterValue</span> = parameterValue;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int <span class="hljs-title function_">getMessageType</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">RPC_MESSAGE_TYPE_REQUEST</span>;<br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getInterfaceName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> interfaceName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getMethodName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> methodName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Class</span>&lt;?&gt; <span class="hljs-title function_">getReturnType</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> returnType;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Class</span>[] <span class="hljs-title function_">getParameterTypes</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> parameterTypes;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span>[] <span class="hljs-title function_">getParameterValue</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> parameterValue;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RpcRequestMessage&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;interfaceName=&#x27;&quot;</span> + interfaceName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, methodName=&#x27;&quot;</span> + methodName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, returnType=&quot;</span> + returnType +<br>                <span class="hljs-string">&quot;, parameterTypes=&quot;</span> + <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">toString</span>(parameterTypes) +<br>                <span class="hljs-string">&quot;, parameterValue=&quot;</span> + <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">toString</span>(parameterValue) +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要远程调用一个方法，必须知道以<strong>下五个信息</strong></p><ul><li>方法所在的全限定类名</li><li>方法名</li><li>方法返回值类型</li><li>方法参数类型</li><li>方法参数值</li></ul><p><strong>RPC响应消息</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcResponseMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Message</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Object</span> returnValue;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Exception</span> exceptionValue;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> int <span class="hljs-title function_">getMessageType</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">RPC_MESSAGE_TYPE_RESPONSE</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setReturnValue</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> returnValue</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">returnValue</span> = returnValue;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setExceptionValue</span>(<span class="hljs-params">Exception exceptionValue</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">exceptionValue</span> = exceptionValue;<br>    &#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">getReturnValue</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> returnValue;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Exception</span> <span class="hljs-title function_">getExceptionValue</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> exceptionValue;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RpcResponseMessage&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;returnValue=&quot;</span> + returnValue +<br>                <span class="hljs-string">&quot;, exceptionValue=&quot;</span> + exceptionValue +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>响应消息中只需要获取<strong>返回结果和异常值</strong></p><p><strong>服务器</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> RPCServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup boss = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        NioEventLoopGroup worker = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.DEBUG)</span>;<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageSharableCodec()</span>;<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcRequestMessageHandler rpcRequestMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RpcRequestMessageHandler()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span>;<br>            serverBootstrap.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;<br>                @Override<br>                protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ProtocolFrameDecoder()</span>);<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">messageSharableCodec</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">rpcRequestMessageHandler</span>)</span>;<br>                &#125;<br>            &#125;);<br>            Channel channel = serverBootstrap.bind(<span class="hljs-number">8080</span>).sync<span class="hljs-literal">()</span>.channel<span class="hljs-literal">()</span>;<br>            channel.close<span class="hljs-constructor">Future()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            boss.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>            worker.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器中添加了<strong>处理RPCRequest消息的handler</strong></p><p><strong>客户端</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> RPCClient &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;<br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.DEBUG)</span>;<br>        MessageSharableCodec messageSharableCodec = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageSharableCodec()</span>;<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RpcResponseMessageHandler()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span>;<br>            bootstrap.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>);<br>            bootstrap.group(group);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;<span class="hljs-literal">()</span> &#123;<br>                @Override<br>                protected void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> ProtocolFrameDecoder()</span>);<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">loggingHandler</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">messageSharableCodec</span>)</span>;<br>                    ch.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">rpcResponseMessageHandler</span>)</span>;<br>                &#125;<br>            &#125;);<br>            Channel channel = bootstrap.connect(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>, 8080)</span>).sync<span class="hljs-literal">()</span>.channel<span class="hljs-literal">()</span>;<br>            channel.close<span class="hljs-constructor">Future()</span>.sync<span class="hljs-literal">()</span>;<br>        &#125; catch (InterruptedException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125; finally &#123;<br>            group.shutdown<span class="hljs-constructor">Gracefully()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过接口Class获取实例对象的<strong>Factory</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServicesFactory</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">HashMap</span>&lt;Class&lt;?&gt;, <span class="hljs-built_in">Object</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">Object</span> <span class="hljs-title function_">getInstance</span>(Class&lt;?&gt; interfaceClass) <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException &#123;<br>        <span class="hljs-comment">// 根据Class创建实例</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.<span class="hljs-property">forName</span>(<span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>);<br>            <span class="hljs-built_in">Object</span> instance = Class.<span class="hljs-property">forName</span>(<span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloServiceImpl&quot;</span>).<span class="hljs-property">newInstance</span>();<br>           <br>            <span class="hljs-comment">// 放入 InterfaceClass -&gt; InstanceObject 的映射</span><br>            <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(clazz, instance);<br>        &#125; <span class="hljs-title function_">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;<br>            e.<span class="hljs-property">printStackTrace</span>();<br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-property">get</span>(interfaceClass);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RpcRequestMessageHandler"><a href="#RpcRequestMessageHandler" class="headerlink" title="RpcRequestMessageHandler"></a>RpcRequestMessageHandler</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@ChannelHandler.Sharable<br>public <span class="hljs-keyword">class</span> RpcRequestMessageHandler extends SimpleChannelInboundHandler&lt;RpcRequestMessage&gt; &#123;<br>    @Override<br>    protected void channel<span class="hljs-constructor">Read0(ChannelHandlerContext <span class="hljs-params">ctx</span>, RpcRequestMessage <span class="hljs-params">rpcMessage</span>)</span> &#123;<br>        RpcResponseMessage rpcResponseMessage = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RpcResponseMessage()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 设置返回值的属性</span><br>            rpcResponseMessage.set<span class="hljs-constructor">SequenceId(<span class="hljs-params">rpcMessage</span>.<span class="hljs-params">getSequenceId</span>()</span>);<br>            <span class="hljs-comment">// 返回一个实例</span><br>            HelloService service = (HelloService) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServicesFactory</span>.</span></span>get<span class="hljs-constructor">Instance(Class.<span class="hljs-params">forName</span>(<span class="hljs-params">rpcMessage</span>.<span class="hljs-params">getInterfaceName</span>()</span>));<br>            <br>            <span class="hljs-comment">// 通过反射调用方法，并获取返回值</span><br>            Method <span class="hljs-keyword">method</span> = service.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Method(<span class="hljs-params">rpcMessage</span>.<span class="hljs-params">getMethodName</span>()</span>, rpcMessage.get<span class="hljs-constructor">ParameterTypes()</span>);<br>            <span class="hljs-comment">// 获得返回值</span><br>            Object invoke = <span class="hljs-keyword">method</span>.invoke(service, rpcMessage.get<span class="hljs-constructor">ParameterValue()</span>);<br>            <span class="hljs-comment">// 设置返回值</span><br>            rpcResponseMessage.set<span class="hljs-constructor">ReturnValue(<span class="hljs-params">invoke</span>)</span>;<br>        &#125; catch (Exception e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>            <span class="hljs-comment">// 设置异常</span><br>            rpcResponseMessage.set<span class="hljs-constructor">ExceptionValue(<span class="hljs-params">e</span>)</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 向channel中写入Message</span><br>    ctx.write<span class="hljs-constructor">AndFlush(<span class="hljs-params">rpcResponseMessage</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>远程调用方法主要是通过反射实现的，大致步骤如下</p><ul><li>通过<strong>请求消息传入被调入方法的各个参数</strong></li><li>通过<strong>全限定接口名，在map中查询到对应的类并实例化对象</strong></li><li>通过反射获取Method，并调用其invoke方法的<strong>返回值，并放入响应消息中</strong></li><li>若有<strong>异常需要捕获，并放入响应消息中</strong></li></ul><h3 id="RpcResponseMessageHandler"><a href="#RpcResponseMessageHandler" class="headerlink" title="RpcResponseMessageHandler"></a>RpcResponseMessageHandler</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@ChannelHandler</span>.<span class="hljs-type">Sharable</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler&lt;RpcResponseMessage&gt;</span> </span>&#123;<br>    static <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> log = <span class="hljs-type">LoggerFactory</span>.getLogger(<span class="hljs-type">ChatServer</span>.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void channelRead0(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">RpcResponseMessage</span> msg) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-type">System</span>.out.println((<span class="hljs-type">String</span>)msg.getReturnValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RPCClient</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>...<br>           <br>        <span class="hljs-comment">// 创建请求并发送</span><br>RpcRequestMessage message = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RpcRequestMessage</span>(<span class="hljs-number">1</span>,<br>               <span class="hljs-string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>,<br>               <span class="hljs-string">&quot;sayHello&quot;</span>,<br>               <span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>,<br>               <span class="hljs-keyword">new</span> Class[]&#123;<span class="hljs-type">String</span>.<span class="hljs-keyword">class</span>&#125;,<br>               <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;Nyima&quot;</span>&#125;);<br><br>        channel.<span class="hljs-built_in">writeAndFlush</span>(message);   <br>            <br>        ...    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>客户端</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1606 </span>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue=你好，Nyima, exceptionValue=null&#125;<br></code></pre></td></tr></table></figure><h3 id="改进客户端"><a href="#改进客户端" class="headerlink" title="改进客户端"></a>改进客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RPCClientManager</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 产生SequenceId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">sequenceId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建代理对象</span><br>        <span class="hljs-type">HelloService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (HelloService) getProxy(HelloService.class);<br>        <span class="hljs-comment">// 通过代理对象执行方法</span><br>        System.out.println(service.sayHello(<span class="hljs-string">&quot;Nyima&quot;</span>));<br>        System.out.println(service.sayHello(<span class="hljs-string">&quot;Hulu&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例模式创建Channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title function_">getChannel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>                    init();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> channel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用代理模式，帮助我们创建请求消息并发送</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt; serviceClass)</span> &#123;<br>        Class&lt;?&gt;[] classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;serviceClass&#125;;<br>        <span class="hljs-comment">// 使用JDK代理，创建代理对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-comment">// 创建请求消息</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> sequenceId.getAndIncrement();<br>                <span class="hljs-type">RpcRequestMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcRequestMessage</span>(id, serviceClass.getName(),<br>                        method.getName(), method.getReturnType(),<br>                        method.getParameterTypes(),<br>                        args);<br>                <span class="hljs-comment">// 发送消息</span><br>                getChannel().writeAndFlush(message);<br><br>                <span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span><br>                DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPromise</span>&lt;&gt;(getChannel().eventLoop());<br>                <span class="hljs-comment">// 将Promise放入Map中</span><br>                RpcResponseMessageHandler.promiseMap.put(id, promise);<br>                <span class="hljs-comment">// 等待被放入Promise中结果</span><br>                promise.await();<br>                <span class="hljs-keyword">if</span> (promise.isSuccess()) &#123;<br>                    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span><br>                    <span class="hljs-keyword">return</span> promise.getNow();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 调用方法失败，抛出异常</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(promise.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">loggingHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br>        <span class="hljs-type">MessageSharableCodec</span> <span class="hljs-variable">messageSharableCodec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageSharableCodec</span>();<br><br>        <span class="hljs-comment">// PRC 请求消息处理器</span><br>        <span class="hljs-type">RpcResponseMessageHandler</span> <span class="hljs-variable">rpcResponseMessageHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcResponseMessageHandler</span>();<br><br>        <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        bootstrap.channel(NioSocketChannel.class);<br>        bootstrap.group(group);<br>        bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtocolFrameDecoder</span>());<br>                ch.pipeline().addLast(loggingHandler);<br>                ch.pipeline().addLast(messageSharableCodec);<br>                ch.pipeline().addLast(rpcResponseMessageHandler);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            channel = bootstrap.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>)).sync().channel();<br>            <span class="hljs-comment">// 异步关闭 group，避免Channel被阻塞</span><br>            channel.closeFuture().addListener(future -&gt; &#123;<br>                group.shutdownGracefully();<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获得Channel</strong></p><ul><li>建立连接，获取Channel的操作被封装到了<code>init</code>方法中，当连接断开时，通过<code>addListener</code>方<strong>法异步关闭group</strong></li><li>通过<strong>单例模式</strong>创建与获取Channel</li></ul><p><strong>远程调用方法</strong></p><ul><li>为了让方法的调用变得简洁明了，将<code>RpcRequestMessage</code>的<strong>创建与发送过程通过JDK的动态代理来完成</strong></li><li>通过返回的代理对象调用方法即可，<strong>方法参数为被调用方法接口的Class类</strong></li></ul><p><strong>远程调用方法返回值获取</strong></p><ul><li><p>调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。<strong>要在不同线程中进行返回值的传递，需要用到Promise</strong></p></li><li><p>在<code>RpcResponseMessageHandler</code>中创建一个Map</p><ul><li>Key为<strong>SequenceId</strong></li><li>Value为对应的<strong>Promise</strong></li></ul></li><li><p><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span><br>DefaultPromise&lt;Object&gt; promise = <span class="hljs-keyword">new</span> DefaultPromise&lt;&gt;(<span class="hljs-built_in">getChannel</span>().<span class="hljs-built_in">eventLoop</span>());<br><span class="hljs-comment">// 将Promise放入Map中</span><br>RpcResponseMessageHandler.promiseMap.<span class="hljs-built_in">put</span>(id, promise);<br><span class="hljs-comment">// 等待被放入Promise中结果</span><br>promise.<span class="hljs-built_in">await</span>();<br><span class="hljs-keyword">if</span> (promise.<span class="hljs-built_in">isSuccess</span>()) &#123;<br>    <span class="hljs-comment">// 调用方法成功，返回方法执行结果</span><br>    <span class="hljs-keyword">return</span> promise.<span class="hljs-built_in">getNow</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 调用方法失败，抛出异常</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RuntimeException</span>(promise.<span class="hljs-built_in">cause</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值</p><ul><li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li><li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span><br>Promise&lt;Object&gt; promise = promiseMap.remove(msg.get<span class="hljs-constructor">SequenceId()</span>);<br>Object returnValue = msg.get<span class="hljs-constructor">ReturnValue()</span>;<br>Exception <span class="hljs-keyword">exception</span> = msg.get<span class="hljs-constructor">ExceptionValue()</span>;<br><span class="hljs-keyword">if</span> (promise != null) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">exception</span> != null) &#123;<br>        <span class="hljs-comment">// 返回结果中有异常信息</span><br>        promise.set<span class="hljs-constructor">Failure(<span class="hljs-params">exception</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 方法正常执行，没有异常</span><br>        promise.set<span class="hljs-constructor">Success(<span class="hljs-params">returnValue</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="改进RpcResponseMessageHandler"><a href="#改进RpcResponseMessageHandler" class="headerlink" title="改进RpcResponseMessageHandler"></a>改进RpcResponseMessageHandler</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@ChannelHandler</span>.<span class="hljs-type">Sharable</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RpcResponseMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler&lt;RpcResponseMessage&gt;</span> </span>&#123;<br>    static <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> log = <span class="hljs-type">LoggerFactory</span>.getLogger(<span class="hljs-type">ChatServer</span>.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值</span><br><span class="hljs-comment">     */</span><br>    public static <span class="hljs-type">Map</span>&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">Object</span>&gt;&gt; promiseMap = <span class="hljs-keyword">new</span> <span class="hljs-type">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void channelRead0(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">RpcResponseMessage</span> msg) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        <span class="hljs-comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span><br>        <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">Object</span>&gt; promise = promiseMap.remove(msg.getSequenceId());<br>        <span class="hljs-type">Object</span> returnValue = msg.getReturnValue();<br>        <span class="hljs-type">Exception</span> exception = msg.getExceptionValue();<br>        <span class="hljs-keyword">if</span> (promise != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 返回结果中有异常信息</span><br>                promise.setFailure(exception);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 方法正常执行，没有异常</span><br>                promise.setSuccess(returnValue);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 拿到返回结果并打印</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h1><h2 id="1、启动流程"><a href="#1、启动流程" class="headerlink" title="1、启动流程"></a>1、启动流程</h2><p>Netty启动流程可以简化成如下代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span><br>Selector selector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Selector</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>; <br><br><span class="hljs-comment">// 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span><br>NioServerSocketChannel attachment = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioServerSocketChannel()</span>;<br><br><span class="hljs-comment">// 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span><br>ServerSocketChannel serverSocketChannel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>; <br>serverSocketChannel.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br><br><span class="hljs-comment">// 启动 nio boss 线程执行接下来的操作</span><br><br><span class="hljs-comment">//注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span><br>SelectionKey selectionKey = serverSocketChannel.register(selector, <span class="hljs-number">0</span>, attachment);<br><br><span class="hljs-comment">// head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span><br><br><span class="hljs-comment">// 绑定端口</span><br>serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(8080)</span>);<br><br><span class="hljs-comment">// 触发 channel active 事件，在 head 中关注 op_accept 事件</span><br>selectionKey.interest<span class="hljs-constructor">Ops(SelectionKey.OP_ACCEPT)</span>;<br></code></pre></td></tr></table></figure><ul><li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li><li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li><li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li><li>绑定端口</li><li>通过<code>interestOps</code>设置感兴趣的事件</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p><p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">public ChannelFuture <span class="hljs-built_in">bind</span>(SocketAddress localAddress) &#123;<br><span class="hljs-built_in">validate</span>();<br>return <span class="hljs-built_in">doBind</span>(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p><p><strong>dobind方法在主线程中执行</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind(<span class="hljs-params">final</span> SocketAddress <span class="hljs-params">localAddress</span>)</span> &#123;<br>    <span class="hljs-comment">// 负责NioServerSocketChannel和ServerSocketChannel的创建</span><br>    <span class="hljs-comment">// ServerSocketChannel的注册工作</span><br>    <span class="hljs-comment">// init由main线程完成，regisetr由NIO线程完成</span><br>    final ChannelFuture regFuture = init<span class="hljs-constructor">AndRegister()</span>;<br>    final Channel channel = regFuture.channel<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (regFuture.cause<span class="hljs-literal">()</span> != null) &#123;<br>        return regFuture;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为register操作是异步的</span><br>    <span class="hljs-comment">// 所以要判断主线程执行到这里时，register操作是否已经执行完毕</span><br>    <span class="hljs-keyword">if</span> (regFuture.is<span class="hljs-constructor">Done()</span>) &#123;<br>        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span><br>        ChannelPromise promise = channel.<span class="hljs-keyword">new</span><span class="hljs-constructor">Promise()</span>;<br>        <br>        <span class="hljs-comment">// 执行doBind0绑定操作</span><br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>        return promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>        <span class="hljs-comment">// 如果register操作还没执行完，就会到这个分支中来</span><br>        final PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PendingRegistrationPromise(<span class="hljs-params">channel</span>)</span>;<br>        <br>        <span class="hljs-comment">// 添加监听器，NIO线程异步进行doBind0操作</span><br>        regFuture.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>            @Override<br>            public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                Throwable cause = future.cause<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">if</span> (cause != null) &#123;<br>                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                    promise.set<span class="hljs-constructor">Failure(<span class="hljs-params">cause</span>)</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>                    promise.registered<span class="hljs-literal">()</span>;<br><br>                    <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        return promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li><li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</li><li><strong>doBind0</strong>则负责连接的创建工作</li></ul><h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><p>代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">final ChannelFuture <span class="hljs-title">initAndRegister</span>()</span> &#123;<br>    Channel channel = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        channel = channelFactory.newChannel();<br>        <span class="hljs-keyword">init</span>(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br>            channel.<span class="hljs-keyword">unsafe</span>().closeForcibly();<br>            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultChannelPromise(<span class="hljs-keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    ChannelFuture regFuture = config().<span class="hljs-keyword">group</span>().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.<span class="hljs-keyword">unsafe</span>().closeForcibly();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span><br>    <span class="hljs-comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span><br>    <span class="hljs-comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span><br>    <span class="hljs-comment">//    added to the event loop&#x27;s task queue for later execution.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span><br>    <span class="hljs-comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span><br>    <span class="hljs-comment">//         because register(), bind(), and connect() are all bound to the same thread.</span><br><br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Channel channel <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br>try &#123;<br>    // 通过反射初始化NioServerSocketChannel<br>    channel <span class="hljs-operator">=</span> channelFactory.newChannel()<span class="hljs-comment">;</span><br>    init(channel)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>newChannel方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe">@Override<br><span class="hljs-keyword">public</span> T <span class="hljs-keyword">new</span><span class="hljs-type">Channel</span>() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过反射调用NioServerSocketChannel的构造方法</span><br>        <span class="hljs-comment">// 创建NioServerSocketChannel对象</span><br>        <span class="hljs-keyword">return</span> constructor.<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ChannelException</span>(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioServerSocketChannel构造方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerSocketChannel</span>()</span> &#123;<br>    <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    <span class="hljs-keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));<br>&#125;<br></code></pre></td></tr></table></figure><p>newSocket方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-keyword">new</span><span class="hljs-type">Socket</span>(SelectorProvider provider) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ServerSocketChannel.open方法：</span><br>        <span class="hljs-comment">// SelectorProvider.provider().openServerSocketChannel()</span><br>    <span class="hljs-comment">// 所以此处相当于ServerSocketChannel.open()</span><br>        <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    <span class="hljs-keyword">return</span> provider.openServerSocketChannel();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ChannelException</span>(<span class="hljs-string">&quot;Failed to open a server socket.&quot;</span>, e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>init方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>   ...<br><br>    <span class="hljs-comment">// NioSocketChannl的Pipeline    </span><br>    ChannelPipeline p = channel.pipeline();<br><br>    ...<br><br>    <span class="hljs-comment">// 向Pipeline中添加了一个handler，该handler等待被调用</span><br>    p.addLast(<span class="hljs-keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// register之后才调用该方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>            <br>            <span class="hljs-comment">// 创建handler并加入到pipeline中</span><br>            ChannelHandler <span class="hljs-keyword">handler</span> = config.<span class="hljs-keyword">handler</span>();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> != <span class="hljs-keyword">null</span>) &#123;<br>                pipeline.addLast(<span class="hljs-keyword">handler</span>);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 添加新的handler，在发生Accept事件后建立连接</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>init主要完成了以下三个操作</strong></p><ul><li><p>创建NioServerSocketChannel</p></li><li><p>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</p></li><li><p>由</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">initChannel</span><br></code></pre></td></tr></table></figure><p>方法向NioServerSocketChannel中添加了两个handler，</p><p>添加操作在register之后被执行</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accepet事件后建立连接</li></ul></li></ul><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p><p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p><p><strong>promise.channel().unsafe().register(this, promise)</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;<br>    ...<br><br>    <span class="hljs-comment">// 获取EventLoop</span><br>    AbstractChannel.<span class="hljs-keyword">this</span>.eventLoop = eventLoop;<br><br>   <span class="hljs-comment">// 此处完成了由 主线程 到 NIO线程 的切换</span><br>    <span class="hljs-comment">// eventLoop.inEventLoop()用于判断当前线程是否为NIO线程</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 向NIO线程中添加任务</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">// 该方法中会执行doRegister</span><br>                    <span class="hljs-comment">// 执行真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>           ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>register0方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">register0</span>(<span class="hljs-params">ChannelPromise promise</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>       ...<br>            <br>        <span class="hljs-comment">// 执行真正的注册操作</span><br>        <span class="hljs-title function_">doRegister</span>();<br>        neverRegistered = <span class="hljs-literal">false</span>;<br>        registered = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        <br>        <span class="hljs-comment">// 调用init中的initChannel方法</span><br>        pipeline.<span class="hljs-title function_">invokeHandlerAddedIfNeeded</span>();<br><br>        ...<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> t) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>doRegister方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span><br>            <span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br>            <span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>           <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回调initChannel</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ChannelPipeline pipeline = ch.pipeline();<br>    ChannelHandler <span class="hljs-keyword">handler</span> = config.<span class="hljs-keyword">handler</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> != <span class="hljs-keyword">null</span>) &#123;<br>        pipeline.addLast(<span class="hljs-keyword">handler</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加新任务，任务负责添加handler</span><br>    <span class="hljs-comment">// 该handler负责发生Accepet事件后建立连接</span><br>    ch.eventLoop().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            pipeline.addLast(<span class="hljs-keyword">new</span> ServerBootstrapAcceptor(<br>                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>Register主要完成了以下三个操作</p><ul><li><p>完成了主线程到NIO的<strong>线程切换</strong></p><ul><li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li><li>切换的方式为让eventLoop执行register的操作</li><li><strong>register的操作在NIO线程中完成</strong></li></ul></li><li><p><strong>调用doRegister方法</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> javaChannel()即为ServerSocketChannel<br><span class="hljs-regexp">//</span> eventLoop().unwrappedSelector()获取eventLoop中的Selector<br><span class="hljs-regexp">//</span> this为NIOServerSocketChannel，作为附件<br>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, this);<br></code></pre></td></tr></table></figure></li><li><ul><li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li><li>此时还未关注事件</li><li>添加NioServerSocketChannel附件</li></ul></li><li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p><ul><li><p>initChannel方法主要创建了</p><p>两个handler</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accept事件后建立连接</li></ul></li></ul></li></ul><h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// initAndRegister为异步方法，会返回ChannelFuture对象</span><br>final ChannelFuture regFuture = init<span class="hljs-constructor">AndRegister()</span>;<br>regFuture.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>    @Override<br>    public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>        Throwable cause = future.cause<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">if</span> (cause != null) &#123;<br>            <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>            <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>            promise.set<span class="hljs-constructor">Failure(<span class="hljs-params">cause</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>            promise.registered<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 如果没有异常，则执行绑定操作</span><br>            <span class="hljs-keyword">do</span><span class="hljs-constructor">Bind0(<span class="hljs-params">regFuture</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">promise</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p><p>NioServerSocketChannel.doBind方法</p><p>通过该方法，绑定了对应的端口</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SuppressJava6Requirement</span>(reason = <span class="hljs-string">&quot;Usage guarded by java version check&quot;</span>)<br><span class="hljs-variable">@Override</span><br>protected void <span class="hljs-built_in">doBind</span>(SocketAddress localAddress) throws Exception &#123;<br>    <span class="hljs-selector-tag">if</span> (PlatformDependent.<span class="hljs-built_in">javaVersion</span>() &gt;= <span class="hljs-number">7</span>) &#123;<br>        <span class="hljs-comment">// 调用ServerSocketChannel的bind方法，绑定端口</span><br>        <span class="hljs-selector-tag">javaChannel</span>()<span class="hljs-selector-class">.bind</span>(localAddress, config.<span class="hljs-built_in">getBacklog</span>());<br>    &#125; <span class="hljs-selector-tag">else</span> &#123;<br>        <span class="hljs-selector-tag">javaChannel</span>()<span class="hljs-selector-class">.socket</span>()<span class="hljs-selector-class">.bind</span>(localAddress, config.<span class="hljs-built_in">getBacklog</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">if (!wasActive &amp;&amp; isActive()) &#123;<br>    <span class="hljs-built_in">invokeLater</span>(new Runnable() &#123;<br>        <span class="hljs-keyword">@Override</span><br>        public void run() &#123;<br>            pipeline<span class="hljs-selector-class">.fireChannelActive</span>();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Override<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> doBeginRead() throws Exception &#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    readPending = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>erestOps = selectionKey.<span class="hljs-built_in">int</span>erestOps();<br>    <span class="hljs-comment">// 如果ServerSocketChannel没有关注Accept事件</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">int</span>erestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 则让其关注Accepet事件</span><br>        <span class="hljs-comment">// readInterestOp 取值是 16</span><br>        <span class="hljs-comment">// 在 NioServerSocketChannel 创建时初始化</span><br>        selectionKey.<span class="hljs-built_in">int</span>erestOps(<span class="hljs-built_in">int</span>erestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p><ul><li><p>首先获取Channel所有感兴趣的事件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>erestOps = selectionKey.<span class="hljs-built_in">int</span>erestOps();<br></code></pre></td></tr></table></figure></li></ul><p>然后再设置其感兴趣的事件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">selectionKey.interest<span class="hljs-constructor">Ops(<span class="hljs-params">interestOps</span> | <span class="hljs-params">readInterestOp</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>各个事件对应的值</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png" alt="img"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p><ul><li>NioServerSocketChannel与ServerSocketChannel的创建</li><li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li><li>绑定了对应的端口</li><li>关注了Accept事件</li></ul><h2 id="2、NioEventLoop剖析"><a href="#2、NioEventLoop剖析" class="headerlink" title="2、NioEventLoop剖析"></a>2、NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p><ul><li><p><strong>Selector</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioEventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SingleThreadEventLoop</span> </span>&#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// selector中的selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// unwrappedSelector中的selectedKeys是基于HashSet的    </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Selector</span> selector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Selector</span> unwrappedSelector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SelectedSelectionKeySet</span> selectedKeys;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>Thread与TaskQueue</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleThreadEventExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractScheduledEventExecutor</span> <span class="hljs-title">implements</span> <span class="hljs-title">OrderedEventExecutor</span> </span>&#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Queue</span>&lt;<span class="hljs-type">Runnable</span>&gt; taskQueue;<br><br>    <span class="hljs-comment">// 线程</span><br>    <span class="hljs-keyword">private</span> volatile <span class="hljs-type">Thread</span> thread;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">NioEventLoop(NioEventLoopGroup <span class="hljs-params">parent</span>, Executor <span class="hljs-params">executor</span>, SelectorProvider <span class="hljs-params">selectorProvider</span>, SelectStrategy <span class="hljs-params">strategy</span>, RejectedExecutionHandler <span class="hljs-params">rejectedExecutionHandler</span>, EventLoopTaskQueueFactory <span class="hljs-params">queueFactory</span>)</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">           </span><br><span class="hljs-operator">        </span><span class="hljs-comment">// 初始化selector，初始化过程在openSelector中</span><br>        final SelectorTuple selectorTuple = <span class="hljs-keyword">open</span><span class="hljs-constructor">Selector()</span>;<br>        this.selector = selectorTuple.selector;<br>        this.unwrappedSelector = selectorTuple.unwrappedSelector;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-keyword">open</span><span class="hljs-constructor">Selector()</span> &#123;<br>    final Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 此处等同于 Selector.open()方法</span><br>        <span class="hljs-comment">// 创建了unwrappedSelector对象</span><br>        unwrappedSelector = provider.<span class="hljs-keyword">open</span><span class="hljs-constructor">Selector()</span>;<br>    &#125; catch (IOException e) &#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ChannelException(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, <span class="hljs-params">e</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p><p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">unwrappedSelector</span> <span class="hljs-operator">=</span> provider.openSelector()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>获得了Selector对象<code>unwrappedSelector</code></p><p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectorTuple</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">final</span> Selector selector;<br><br>    SelectorTuple(Selector unwrappedSelector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = unwrappedSelector;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 一般调用的是这个构造方法</span><br><span class="hljs-comment">    */</span><br>    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;<br>        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-keyword">this</span>.selector = selector;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p><h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p><ul><li>selector中的SelectedKeys是<strong>基于数组</strong>的</li><li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li></ul><p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title function_">openSelector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br><br>    ...<br>    <br>    <span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectedSelectionKeySet</span> <span class="hljs-variable">selectedKeySet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySet</span>();<br><br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">maybeException</span> <span class="hljs-operator">=</span> AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过反射拿到unwrappedSelector中的selectedKeys属性</span><br>                <span class="hljs-type">Field</span> <span class="hljs-variable">selectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>                <span class="hljs-type">Field</span> <span class="hljs-variable">publicSelectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br><br>                ...<br><br>                <span class="hljs-comment">// 暴力反射，修改私有属性</span><br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> ReflectionUtil.trySetAccessible(selectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br>                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br><br>                <span class="hljs-comment">// 替换为基于数组的selectedKeys实现</span><br>                selectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    selectedKeys = selectedKeySet;<br>    <br>    <span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectorTuple</span>(unwrappedSelector,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySetSelector</span>(unwrappedSelector, selectedKeySet));<br>&#125;<br></code></pre></td></tr></table></figure><p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p><ul><li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br>final SelectedSelectionKeySet selectedKeySet = <span class="hljs-keyword">new</span> <span class="hljs-type">SelectedSelectionKeySet</span>();<br><br>SelectedSelectionKeySet() &#123;<br>keys = <span class="hljs-keyword">new</span> <span class="hljs-type">SelectionKey</span>[<span class="hljs-number">1024</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p><p><strong>通过Selector的构造方法</strong>获得selector</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">SelectedSelectionKeySetSelector(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">selectedKeySet</span>)</span><br></code></pre></td></tr></table></figure><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>return <span class="hljs-keyword">new</span> <span class="hljs-constructor">SelectorTuple(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">new</span> SelectedSelectionKeySetSelector(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">selectedKeySet</span>)</span>);<br></code></pre></td></tr></table></figure><h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p><p><strong>测试代码</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNioEventLoop</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">EventLoop</span> eventLoop = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>().<span class="hljs-title function_">next</span>();<br>        <span class="hljs-comment">// 使用NioEventLoop执行任务</span><br>        eventLoop.<span class="hljs-title function_">execute</span>(()-&gt;&#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<code>execute</code>执行任务</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> execute(Runnable <span class="hljs-keyword">task</span>) &#123;<br>    <span class="hljs-comment">// 检测传入的任务是否为空，为空会抛出NullPointerException</span><br>    ObjectUtil.checkNotNull(<span class="hljs-keyword">task</span>, <span class="hljs-string">&quot;task&quot;</span>);<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-comment">// 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true</span><br>    execute(<span class="hljs-keyword">task</span>, !(<span class="hljs-keyword">task</span> <span class="hljs-keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(<span class="hljs-keyword">task</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>进入上述代码的<code>execute</code>方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk">private void execute(Runnable task, boolean immediate) &#123;<br>    <span class="hljs-regexp">//</span> 判断当前线程是否为NIO线程<br>    <span class="hljs-regexp">//</span> 判断方法为 return thread == this.thread;<br>    <span class="hljs-regexp">//</span> this.thread即为NIO线程，首次执行任务时，其为null<br>    boolean inEventLoop = inEventLoop();<br>    <br>    <span class="hljs-regexp">//</span> 向任务队列taskQueue中添加任务<br>    addTask(task);<br>    <br>    <span class="hljs-regexp">//</span> 当前线程不是NIO线程，则进入<span class="hljs-keyword">if</span>语句<br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        <span class="hljs-regexp">//</span> 启动NIO线程的核心方法<br>        startThread();<br>        <br>        ...<br>        <br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 有任务需要被执行时，唤醒阻塞的NIO线程<br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<code>startThread</code>方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void start<span class="hljs-constructor">Thread()</span> &#123;<br>    <span class="hljs-comment">// 查看NIO线程状态是否为未启动</span><br>    <span class="hljs-comment">// 该if代码块只会执行一次</span><br>    <span class="hljs-comment">// state一开始的值就是ST_NOT_STARTED</span><br>    <span class="hljs-comment">// private volatile int state = ST_NOT_STARTED;</span><br>    <span class="hljs-keyword">if</span> (state<span class="hljs-operator"> == </span>ST_NOT_STARTED) &#123;<br>        <span class="hljs-comment">// 通过原子属性更新器将状态更新为启动（ST_STARTED）</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">STATE_UPDATER</span>.</span></span>compare<span class="hljs-constructor">AndSet(<span class="hljs-params">this</span>, ST_NOT_STARTED, ST_STARTED)</span>) &#123;<br>            boolean success = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行启动线程</span><br>                <span class="hljs-keyword">do</span><span class="hljs-constructor">StartThread()</span>;<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; finally &#123;<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">STATE_UPDATER</span>.</span></span>compare<span class="hljs-constructor">AndSet(<span class="hljs-params">this</span>, ST_STARTED, ST_NOT_STARTED)</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doStartThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> thread == <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 创建NIO线程并执行任务</span><br>    executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// thread即为NIO线程</span><br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行内部run方法</span><br>                SingleThreadEventExecutor.<span class="hljs-keyword">this</span>.run();<br>                success = <span class="hljs-keyword">true</span>;<br>            &#125; <br>            <br>            ...<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p><p>该run方法是<strong>NioEvnetLoop的run方法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Override<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>    <span class="hljs-built_in">int</span> selectCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 执行各种任务</span><br>   <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">int</span> strategy;<br>            <span class="hljs-keyword">try</span> &#123;<br>                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br>                <span class="hljs-keyword">switch</span> (strategy) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                    <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    <span class="hljs-built_in">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();<br>                    <span class="hljs-keyword">if</span> (curDeadlineNanos == <span class="hljs-number">-1L</span>) &#123;<br>                        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>                    &#125;<br>                    nextWakeupNanos.<span class="hljs-keyword">set</span>(curDeadlineNanos);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>                            strategy = <span class="hljs-keyword">select</span>(curDeadlineNanos);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// This update is just to help block unnecessary selector wakeups</span><br>                        <span class="hljs-comment">// so use of lazySet is ok (no race condition)</span><br>                        nextWakeupNanos.lazySet(AWAKE);<br>                    &#125;<br>                    <span class="hljs-comment">// fall through</span><br>                <span class="hljs-literal">default</span>:<br>                &#125;<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> selectCnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 执行各种任务</span><br>   ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p><p>run方法中有SELECT分支</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">case</span> SelectStrategy.<span class="hljs-keyword">SELECT</span>:<br>long curDeadlineNanos = nextScheduledTaskDeadlineNanos();<br><span class="hljs-keyword">if</span> (curDeadlineNanos == <span class="hljs-number">-1</span>L) &#123;<br>        curDeadlineNanos = <span class="hljs-literal">NONE</span>; <span class="hljs-comment">// nothing on the calendar</span><br>    &#125;<br>nextWakeupNanos.<span class="hljs-built_in">set</span>(curDeadlineNanos);<br>try &#123;<br>    <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>            <span class="hljs-comment">// 执行select方法</span><br>            strategy = <span class="hljs-keyword">select</span>(curDeadlineNanos);<br>        &#125;<br>    &#125;<br><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deadlineNanos)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 如果没有指定阻塞事件，就调用select()</span><br>    <span class="hljs-keyword">if</span> (deadlineNanos == NONE) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> selector.<span class="hljs-title">select</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>    <span class="hljs-comment">// 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞</span><br>    <span class="hljs-comment">// Timeout will only be 0 if deadline is within 5 microsecs</span><br>    <span class="hljs-keyword">long</span> timeoutMillis = deadlineToDelayNanos(deadlineNanos + <span class="hljs-number">995000</span>L) / <span class="hljs-number">1000000</span>L;<br>    <span class="hljs-keyword">return</span> timeoutMillis &lt;= <span class="hljs-number">0</span> ? selector.selectNow() : selector.select(timeoutMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>但需要注意的是，**<code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**</p><p>唤醒是通过execute最后的if代码块来完成的</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br>if (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>    <span class="hljs-built_in">wakeup</span>(inEventLoop);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">wakeup</span>(<span class="hljs-params"><span class="hljs-built_in">boolean</span> inEventLoop</span>) &#123;<br>    <span class="hljs-comment">// 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒</span><br>    <span class="hljs-comment">// 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; nextWakeupNanos.<span class="hljs-title function_">getAndSet</span>(<span class="hljs-variable constant_">AWAKE</span>) != <span class="hljs-variable constant_">AWAKE</span>) &#123;<br>        <span class="hljs-comment">// 唤醒被selector.select方法阻塞的NIO线程</span><br>        selector.<span class="hljs-title function_">wakeup</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>唤醒时需要进行两个判断</p><ul><li><p>判断提交任务的</p><p>是否为NIO线程</p><ul><li>若是其他线程，才能唤醒NIO线程</li><li>若是NIO线程自己，则不能唤醒</li></ul></li><li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p></li></ul><h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> strategy = selectStrategy.calculate<span class="hljs-constructor">Strategy(<span class="hljs-params">selectNowSupplier</span>, <span class="hljs-params">hasTasks</span>()</span>);<br>switch (strategy) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>strategy的值由<code>calculateStrategy</code>方法确定</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculateStrategy</span><span class="hljs-params">(IntSupplier selectSupplier, <span class="hljs-keyword">boolean</span> hasTasks)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// selectSupplier.get() 底层是 selector.selectNow();</span><br>    <span class="hljs-keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p><ul><li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p><ul><li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IntSupplier</span> <span class="hljs-variable">selectNowSupplier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntSupplier</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> NioEventLoop.<span class="hljs-built_in">this</span>.selectNow();<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">selectNow</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.selector.selectNow();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>若没有任务，就会进入SELECT分支</p></li></ul><p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p><h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p> Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p><p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@Override<br><span class="hljs-keyword">protected</span> <span class="hljs-literal">void</span> run() &#123;<br>    <span class="hljs-params">...</span><br>    for(;;)&#123;<br>        <span class="hljs-params">...</span><br>        <span class="hljs-comment">// 可能发生空轮询，无法阻塞NIO线程</span><br>        strategy = <span class="hljs-keyword">select</span>(curDeadlineNanos);  <br>        <span class="hljs-params">...</span>     <br>    <br>     <span class="hljs-keyword">if</span>(<span class="hljs-params">...</span>) &#123;<br><span class="hljs-params">...</span><br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt) )&#123;<br>            <span class="hljs-comment">// 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector</span><br>            <span class="hljs-comment">// 并将selectCnt重置为0</span><br>            selectCnt = <span class="hljs-number">0</span>;<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p><p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>    <span class="hljs-comment">// The selector returned prematurely many times in a row.</span><br>    <span class="hljs-comment">// Rebuild the selector to work around the problem.</span><br>    logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,selectCnt, selector);<br>    <span class="hljs-comment">// 重建selector，将原selector的配置信息传给新selector</span><br>    <span class="hljs-comment">// 再用新selector覆盖旧selector</span><br>    rebuildSelector();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p><h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p><p><strong>NioEventLoop.run方法</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 处理IO事件时间比例，默认为<span class="hljs-number">50</span>%<br>final int ioRatio = this.ioRatio;<br><br><span class="hljs-regexp">//</span> 如果IO事件时间比例设置为<span class="hljs-number">100</span>%<br><span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>    try &#123;<br>        <span class="hljs-regexp">//</span> 如果需要去处理IO事件<br>        <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-regexp">//</span> 先处理IO事件<br>            processSelectedKeys();<br>        &#125;<br>    &#125; finally &#123;<br>        <span class="hljs-regexp">//</span> Ensure we always run tasks.<br>        <span class="hljs-regexp">//</span> 剩下的时间都去处理普通任务和定时任务<br>        ranTasks = runAllTasks();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 如果需要去处理IO事件<br>    <span class="hljs-regexp">//</span> 记录处理IO事件前的时间<br>    final long ioStartTime = System.nanoTime();<br>    try &#123;<br>        <span class="hljs-regexp">//</span> 去处理IO事件<br>        processSelectedKeys();<br>    &#125; finally &#123;<br>        <span class="hljs-regexp">//</span> Ensure we always run tasks.<br>        <span class="hljs-regexp">//</span> ioTime为处理IO事件耗费的事件<br>        final long ioTime = System.nanoTime() - ioStartTime;<br>        <span class="hljs-regexp">//</span> 计算出处理其他任务的事件<br>        <span class="hljs-regexp">//</span> 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行<br>        ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span> 没有IO事件需要处理<br>    <span class="hljs-regexp">//</span> This will run the minimum number of tasks<br>    <span class="hljs-regexp">//</span> 直接处理普通和定时任务<br>    ranTasks = runAllTasks(<span class="hljs-number">0</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p><ul><li><p>判断ioRatio是否为100</p><ul><li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p><ul><li>若需要处理IO事件，则先处理IO事件</li></ul></li><li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 没有指定执行任务的时间<br><span class="hljs-attribute">ranTasks</span> <span class="hljs-operator">=</span> runAllTasks()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p>若ioRatio不为100</p><ul><li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p></li><li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 比如ioTime为<span class="hljs-number">10</span>s，ioRatio为<span class="hljs-number">50</span><br><span class="hljs-regexp">//</span> 那么通过 <span class="hljs-number">10</span>*(<span class="hljs-number">100</span>-<span class="hljs-number">50</span>)/<span class="hljs-number">50</span>=<span class="hljs-number">10</span> 计算出其他任务可用的时间为 <span class="hljs-number">10</span>s<br><span class="hljs-regexp">//</span> 处理IO事件占用的事件总比例为<span class="hljs-number">50</span>%<br>ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br></code></pre></td></tr></table></figure></li><li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p></li></ul><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 运行最少数量的任务<br><span class="hljs-attribute">ranTasks</span> <span class="hljs-operator">=</span> runAllTasks(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void process<span class="hljs-constructor">SelectedKeys()</span> &#123;<br>    <span class="hljs-comment">// 如果selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// 一般情况下都走这个分支</span><br>    <span class="hljs-keyword">if</span> (selectedKeys != null) &#123;<br>        <span class="hljs-comment">// 处理各种IO事件</span><br>        process<span class="hljs-constructor">SelectedKeysOptimized()</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        process<span class="hljs-constructor">SelectedKeysPlain(<span class="hljs-params">selector</span>.<span class="hljs-params">selectedKeys</span>()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>processSelectedKeysOptimized方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKeysOptimized</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; selectedKeys.size; ++i) &#123;<br>        <span class="hljs-comment">// 拿到SelectionKeyec</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> selectedKeys.keys[i];<br>        <span class="hljs-comment">// null out entry in the array to allow to have it GC&#x27;ed once the Channel close</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>        selectedKeys.keys[i] = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> k.attachment();<br><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>            <span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span><br>            processSelectedKey(k, (AbstractNioChannel) a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;<br>            processSelectedKey(k, task);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (needsToSelectAgain) &#123;<br>            <span class="hljs-comment">// null out entries in the array to allow to have it GC&#x27;ed once the Channel close</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>            selectedKeys.reset(i + <span class="hljs-number">1</span>);<br><br>            selectAgain();<br>            i = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">final SelectionKey k <span class="hljs-operator">=</span> selectedKeys.keys[i]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">Object</span> a = k.attachment();<br></code></pre></td></tr></table></figure><p>如果附件继承自AbstractNioChannel，则会调用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span><br>process<span class="hljs-constructor">SelectedKey(<span class="hljs-params">k</span>, (AbstractNioChannel)</span> a);<br></code></pre></td></tr></table></figure><p>去处理各个事件</p><p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p><p>获取SelectionKey的事件，然后进行相应处理</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span>(<span class="hljs-params">SelectionKey k, AbstractNioChannel ch</span>)</span> &#123;<br>    final AbstractNioChannel.NioUnsafe <span class="hljs-keyword">unsafe</span> = ch.<span class="hljs-keyword">unsafe</span>();<br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        final EventLoop eventLoop;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop = ch.eventLoop();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span><br>            <span class="hljs-comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span><br>            <span class="hljs-comment">// to close ch.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span><br>        <span class="hljs-comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span><br>        <span class="hljs-comment">// still healthy and should not be closed.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/5125</span><br>        <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// close the channel if the key is not valid anymore</span><br>            <span class="hljs-keyword">unsafe</span>.close(<span class="hljs-keyword">unsafe</span>.voidPromise());<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">int</span> readyOps = k.readyOps();<br>        <span class="hljs-comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span><br>        <span class="hljs-comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/924</span><br>            <span class="hljs-built_in">int</span> ops = k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            <span class="hljs-keyword">unsafe</span>.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br>            ch.<span class="hljs-keyword">unsafe</span>().forceFlush();<br>        &#125;<br><br>        <span class="hljs-comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span><br>        <span class="hljs-comment">// to a spin loop</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">unsafe</span>.read();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;<br>        <span class="hljs-keyword">unsafe</span>.close(<span class="hljs-keyword">unsafe</span>.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、Accept剖析"><a href="#3、Accept剖析" class="headerlink" title="3、Accept剖析"></a>3、Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p><ul><li>selector.select()阻塞线程，直到事件发生</li><li>遍历selectionKeys</li><li>获取一个key，判断事件类型是否为Accept</li></ul><hr><ul><li>创建SocketChannel，设置为非阻塞</li><li>将SocketChannel注册到selector中</li><li>关注selectionKeys的read事件</li></ul><p>代码如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 阻塞直到事件发生<br>selector.select();<br><br>Iterator&lt;SelectionKey&gt; iter = selector.selectionKeys().iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;    <br>    <span class="hljs-regexp">//</span> 拿到一个事件<br>    SelectionKey key = iter.<span class="hljs-keyword">next</span>();<br>    <br>    <span class="hljs-regexp">//</span> 如果是 accept 事件<br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <br>        <span class="hljs-regexp">//</span> 执行accept，获得SocketChannel<br>        SocketChannel channel = serverSocketChannel.accept();<br>        channel.configureBlocking(false);<br>        <br>        <span class="hljs-regexp">//</span> 将SocketChannel注册到selector中，并关注read事件<br>        channel.register(selector, SelectionKey.OP_READ);<br>    &#125;<br>    <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p><h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if ((<span class="hljs-name">readyOps</span> &amp; (<span class="hljs-name">SelectionKey</span>.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == <span class="hljs-number">0</span>) &#123;<br>unsafe.read()<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioMessageUnsafe.read</code>方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void read<span class="hljs-literal">()</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    </span><span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// doReadMessages中执行了accept获得了SocketChannel</span><br>                <span class="hljs-comment">// 并创建NioSocketChannel作为消息放入readBuf</span><br>                <span class="hljs-comment">// readBuf是一个ArrayList用来缓存消息</span><br>                <span class="hljs-comment">// private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();</span><br>                <span class="hljs-built_in">int</span> localRead = <span class="hljs-keyword">do</span><span class="hljs-constructor">ReadMessages(<span class="hljs-params">readBuf</span>)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">                </span><br><span class="hljs-operator">                ...</span><br><span class="hljs-operator">                </span><br><span class="hljs-operator"></span><span class="hljs-comment">// localRead值为1，就一条消息，即接收一个客户端连接</span><br>                allocHandle.inc<span class="hljs-constructor">MessagesRead(<span class="hljs-params">localRead</span>)</span>;<br>            &#125; <span class="hljs-keyword">while</span> (allocHandle.continue<span class="hljs-constructor">Reading()</span>);<br>        &#125; catch (Throwable t) &#123;<br>            <span class="hljs-keyword">exception</span> = t;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> size = readBuf.size<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            readPending = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 触发read事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// ServerBootstrapAcceptor.channelRead</span><br>            pipeline.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">readBuf</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span>);<br>        &#125;<span class="hljs-operator"></span><br><span class="hljs-operator">        </span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">        </span><br><span class="hljs-operator">    </span>&#125; finally &#123;<br>        <span class="hljs-keyword">if</span> (!readPending<span class="hljs-operator"> &amp;&amp; </span>!config.is<span class="hljs-constructor">AutoRead()</span>) &#123;<br>            remove<span class="hljs-constructor">ReadOp()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioSocketChannel.doReadMessages</code>方法</p><p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 处理accpet事件，获得SocketChannel</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> SocketUtils.accept(javaChannel());<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 创建了NioSocketChannel，作为消息放在了readBuf中</span><br>            buf.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioSocketChannel</span>(<span class="hljs-built_in">this</span>, ch));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>       ...<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>ServerBootstrapAcceptor.channelRead</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void channel<span class="hljs-constructor">Read(ChannelHandlerContext <span class="hljs-params">ctx</span>, Object <span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-comment">// 这时的msg是NioSocketChannel</span><br>    final Channel child = (Channel) msg;<br><br>    <span class="hljs-comment">// NioSocketChannel添加childHandler，即初始化器</span><br>    child.pipeline<span class="hljs-literal">()</span>.add<span class="hljs-constructor">Last(<span class="hljs-params">childHandler</span>)</span>;<br><br>    <span class="hljs-comment">// 设置选项</span><br>    set<span class="hljs-constructor">ChannelOptions(<span class="hljs-params">child</span>, <span class="hljs-params">childOptions</span>, <span class="hljs-params">logger</span>)</span>;<br><br>    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<br>        child.attr((AttributeKey&lt;Object&gt;) e.get<span class="hljs-constructor">Key()</span>).set(e.get<span class="hljs-constructor">Value()</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程</span><br>        childGroup.register(child).add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> ChannelFutureListener()</span> &#123;<br>            @Override<br>            public void operation<span class="hljs-constructor">Complete(ChannelFuture <span class="hljs-params">future</span>)</span> throws Exception &#123;<br>                <span class="hljs-keyword">if</span> (!future.is<span class="hljs-constructor">Success()</span>) &#123;<br>                    force<span class="hljs-constructor">Close(<span class="hljs-params">child</span>, <span class="hljs-params">future</span>.<span class="hljs-params">cause</span>()</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; catch (Throwable t) &#123;<br>        force<span class="hljs-constructor">Close(<span class="hljs-params">child</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>AbstractUnsafe.register</code>  方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">    </span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractChannel</span>.</span></span>this.eventLoop = eventLoop;<br><br>    <span class="hljs-keyword">if</span> (eventLoop.<span class="hljs-keyword">in</span><span class="hljs-constructor">EventLoop()</span>) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这行代码完成的是nio boss -&gt; nio worker线程的切换</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>                @Override<br>                public void run<span class="hljs-literal">()</span> &#123;<br>                    <span class="hljs-comment">// 真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; catch (Throwable t) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">        </span>&#125;<br>    &#125;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractChannel</span>.</span><span class="hljs-module"><span class="hljs-identifier">AbstractUnsafe</span>.</span></span>register0<br><span class="hljs-keyword">private</span> void register0(ChannelPromise promise) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">        </span><br><span class="hljs-operator">        ...</span><br><span class="hljs-operator">            </span><br><span class="hljs-operator">        </span><span class="hljs-comment">// 该方法将SocketChannel注册到Selector中</span><br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">Register()</span>;<br>        <br>        <span class="hljs-comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span><br>        pipeline.invoke<span class="hljs-constructor">HandlerAddedIfNeeded()</span>;<br>        <span class="hljs-comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span><br><br>        safe<span class="hljs-constructor">SetSuccess(<span class="hljs-params">promise</span>)</span>;<br>        pipeline.fire<span class="hljs-constructor">ChannelRegistered()</span>;<br>        <br>        <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Active()</span>) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">// 触发pipeline上active事件</span><br>                pipeline.fire<span class="hljs-constructor">ChannelActive()</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config<span class="hljs-literal">()</span>.is<span class="hljs-constructor">AutoRead()</span>) &#123;<br>                <span class="hljs-keyword">begin</span><span class="hljs-constructor">Read()</span>;<br>            &#125;<br>        &#125;<br>    &#125; catch (Throwable t) &#123;<br>        close<span class="hljs-constructor">Forcibly()</span>;<br>        closeFuture.set<span class="hljs-constructor">Closed()</span>;<br>        safe<span class="hljs-constructor">SetFailure(<span class="hljs-params">promise</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将Selector注册到Selector中</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>HeadContext.channelActive</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">public void <span class="hljs-built_in">channelActive</span>(ChannelHandlerContext ctx) &#123;<br>    ctx<span class="hljs-selector-class">.fireChannelActive</span>();<br><span class="hljs-comment">// 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)</span><br>    <span class="hljs-built_in">readIfIsAutoRead</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> doBeginRead() throws Exception &#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 这时候 interestOps是0</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>erestOps = selectionKey.<span class="hljs-built_in">int</span>erestOps();<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">int</span>erestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关注read事件</span><br>        selectionKey.<span class="hljs-built_in">int</span>erestOps(<span class="hljs-built_in">int</span>erestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、Read剖析"><a href="#4、Read剖析" class="headerlink" title="4、Read剖析"></a>4、Read剖析</h2><p>read事件的处理也是在</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if ((<span class="hljs-name">readyOps</span> &amp; (<span class="hljs-name">SelectionKey</span>.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == <span class="hljs-number">0</span>) &#123;<br>unsafe.read()<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public final void read<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-comment">// 获得Channel的配置</span><br>    final ChannelConfig config = config<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (should<span class="hljs-constructor">BreakReadReady(<span class="hljs-params">config</span>)</span>) &#123;<br>        clear<span class="hljs-constructor">ReadPending()</span>;<br>        return;<br>    &#125;<br>    final ChannelPipeline pipeline = pipeline<span class="hljs-literal">()</span>;<br><span class="hljs-comment">// 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）</span><br>final ByteBufAllocator allocator = config.get<span class="hljs-constructor">Allocator()</span>;<br>    <span class="hljs-comment">// 用来分配 byteBuf，确定单次读取大小</span><br>    final RecvByteBufAllocator.Handle allocHandle = recv<span class="hljs-constructor">BufAllocHandle()</span>;<br>    allocHandle.reset(config);<br><br>    ByteBuf byteBuf = null;<br>    boolean close = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 创建ByteBuf</span><br>            byteBuf = allocHandle.allocate(allocator);<br>            <span class="hljs-comment">// 读取内容，放入ByteBUf中</span><br>            allocHandle.last<span class="hljs-constructor">BytesRead(<span class="hljs-params">doReadBytes</span>(<span class="hljs-params">byteBuf</span>)</span>);<br>            <span class="hljs-keyword">if</span> (allocHandle.last<span class="hljs-constructor">BytesRead()</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>                byteBuf.release<span class="hljs-literal">()</span>;<br>                byteBuf = null;<br>                close = allocHandle.last<span class="hljs-constructor">BytesRead()</span> &lt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (close) &#123;<br>                    readPending = <span class="hljs-literal">false</span>;<br>                &#125;<br>                break;<br>            &#125;<br><br>            allocHandle.inc<span class="hljs-constructor">MessagesRead(1)</span>;<br>            readPending = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 触发read 事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// 这时是处理NioSocketChannel上的handler</span><br>            pipeline.fire<span class="hljs-constructor">ChannelRead(<span class="hljs-params">byteBuf</span>)</span>;<br>            byteBuf = null;<br>        &#125; <br>        <span class="hljs-comment">// 是否要继续循环</span><br>        <span class="hljs-keyword">while</span> (allocHandle.continue<span class="hljs-constructor">Reading()</span>);<br><br>        allocHandle.read<span class="hljs-constructor">Complete()</span>;<br>        <span class="hljs-comment">// 触发 read complete事件</span><br>        pipeline.fire<span class="hljs-constructor">ChannelReadComplete()</span>;<br><br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            close<span class="hljs-constructor">OnRead(<span class="hljs-params">pipeline</span>)</span>;<br>        &#125;<br>    &#125; catch (Throwable t) &#123;<br>        handle<span class="hljs-constructor">ReadException(<span class="hljs-params">pipeline</span>, <span class="hljs-params">byteBuf</span>, <span class="hljs-params">t</span>, <span class="hljs-params">close</span>, <span class="hljs-params">allocHandle</span>)</span>;<br>    &#125; finally &#123;<br>         <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>         <span class="hljs-comment">// This could be for two reasons:</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending<span class="hljs-operator"> &amp;&amp; </span>!config.is<span class="hljs-constructor">AutoRead()</span>) &#123;<br>            remove<span class="hljs-constructor">ReadOp()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultMaxMessagesRecvByteBufAllocator</span>.</span><span class="hljs-module"><span class="hljs-identifier">MaxMessageHandle</span>.</span></span>continue<span class="hljs-constructor">Reading(<span class="hljs-params">io</span>.<span class="hljs-params">netty</span>.<span class="hljs-params">util</span>.UncheckedBooleanSupplier)</span><br>public boolean continue<span class="hljs-constructor">Reading(UncheckedBooleanSupplier <span class="hljs-params">maybeMoreDataSupplier</span>)</span> &#123;<br>    return <br>           <span class="hljs-comment">// 一般为true</span><br>           config.is<span class="hljs-constructor">AutoRead()</span><span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">           </span><span class="hljs-comment">// respectMaybeMoreData默认为true</span><br>           <span class="hljs-comment">// maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true</span><br>           (!respectMaybeMoreData<span class="hljs-operator"> || </span>maybeMoreDataSupplier.get<span class="hljs-literal">()</span>)<span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">           </span><span class="hljs-comment">// 小于最大次数，maxMessagePerRead默认16</span><br>           totalMessages &lt; maxMessagePerRead<span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">           </span><span class="hljs-comment">// 实际读到了数据</span><br>           totalBytesRead &gt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NIO基础</title>
    <link href="/2022/09/26/NIO%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/26/NIO%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty学习之NIO基础"><a href="#Netty学习之NIO基础" class="headerlink" title="Netty学习之NIO基础"></a>Netty学习之NIO基础</h1><h1 id="一、三大组件简介"><a href="#一、三大组件简介" class="headerlink" title="一、三大组件简介"></a>一、三大组件简介</h1><p>Channel与Buffer</p><p>Java NIO系统的<strong>核心</strong>在于：<strong>通道(Channel)和缓冲区(Buffer)<strong>。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于</strong>连接 IO 设备的通道</strong>以及用于<strong>容纳数据的缓冲区</strong>。然后操作缓冲区，对数据进行处理</p><p>简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p><p><strong>常见的Channel有以下四种</strong>，其中FileChannel主要用于文件传输，其余三种用于网络通信</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p><strong>Buffer有以下几种</strong>，其中使用较多的是ByteBuffer</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412135510.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412135510.png" alt="img"></a></p><h2 id="1、Selector"><a href="#1、Selector" class="headerlink" title="1、Selector"></a>1、Selector</h2><p>在使用Selector之前，处理socket连接还有以下两种方法</p><p><strong>使用多线程技术</strong></p><p>为每个连接分别开辟一个线程，分别去处理对应的socke连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181918.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181918.png" alt="img"></a></p><p>这种方法存在以下几个问题</p><ul><li>内存占用高<ul><li>每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li></ul></li><li>线程上下文切换成本高</li><li>只适合连接数少的场景<ul><li>连接数过多，会导致创建很多线程，从而出现问题</li></ul></li></ul><p><strong>使用线程池技术</strong></p><p>使用线程池，让线程池中的线程去处理连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181933.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181933.png" alt="img"></a></p><p>这种方法存在以下几个问题</p><ul><li><p>阻塞模式下，线程仅能处理一个连接</p><ul><li>线程池中的线程获取任务（task）后，<strong>只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</strong></li><li>若socke连接一直未断开，则其对应的线程无法处理其他socke连接</li></ul></li><li><p>仅适合</p><p>短连接</p><p>场景</p><ul><li>短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</li></ul></li></ul><p><strong>使用选择器</strong></p><p><strong>selector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector）</strong>，获取这些 channel 上发生的<strong>事件</strong>，这些 channel 工作在<strong>非阻塞模式</strong>下，当一个channel中没有执行任务时，可以去执行其他channel中的任务。<strong>适合连接数多，但流量较少的场景</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181947.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181947.png" alt="img"></a></p><p>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理</p><h2 id="2、ByteBuffer"><a href="#2、ByteBuffer" class="headerlink" title="2、ByteBuffer"></a>2、ByteBuffer</h2><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li><p>向 buffer 写入数据，例如调用 channel.read(buffer)</p></li><li><p>调用 flip() 切换至</p><p>读模式</p><ul><li><strong>flip会使得buffer中的limit变为position，position变为0</strong></li></ul></li><li><p>从 buffer 读取数据，例如调用 buffer.get()</p></li><li><p>调用 clear() 或者compact()切换至</p><p>写模式</p><ul><li>调用clear()方法时<strong>position&#x3D;0，limit变为capacity</strong></li><li>调用compact()方法时，<strong>会将缓冲区中的未读数据压缩到缓冲区前面</strong></li></ul></li><li><p>重复以上步骤</p></li></ul><p><strong>使用ByteBuffer读取文件中的内容</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestByteBuffer</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 获得FileChannel</span><br>        <span class="hljs-built_in">try</span> (FileChannel channel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;stu.txt&quot;</span>).<span class="hljs-built_in">getChannel</span>()) &#123;<br>            <span class="hljs-comment">// 获得缓冲区</span><br>            ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">10</span>);<br>            <span class="hljs-type">int</span> hasNext = <span class="hljs-number">0</span>;<br>            StringBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>            <span class="hljs-keyword">while</span>((hasNext = channel.<span class="hljs-built_in">read</span>(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 切换模式 limit=position, position=0</span><br>                buffer.<span class="hljs-built_in">flip</span>();<br>                <span class="hljs-comment">// 当buffer中还有数据时，获取其中的数据</span><br>                <span class="hljs-keyword">while</span>(buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>                    builder.<span class="hljs-built_in">append</span>((<span class="hljs-type">char</span>)buffer.<span class="hljs-built_in">get</span>());<br>                &#125;<br>                <span class="hljs-comment">// 切换模式 position=0, limit=capacity</span><br>                buffer.<span class="hljs-built_in">clear</span>();<br>            &#125;<br>            System.out.<span class="hljs-built_in">println</span>(builder.<span class="hljs-built_in">toString</span>());<br>        &#125; <span class="hljs-built_in">catch</span> (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0123456789abcdef<br></code></pre></td></tr></table></figure><h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><p>字节缓冲区的父类Buffer中有几个核心属性，如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> mark = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> position = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br></code></pre></td></tr></table></figure><ul><li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity &#x3D; limit ，为缓冲区容量的值。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145709.png" alt="img"></a></p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 &#x2F; 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position &#x3D; 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145753.png" alt="img"></a></p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li><li><strong>注意：get(i)方法不会改变position的值</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145822.png" alt="img"></a></p><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145852.png" alt="img"></a></p><h4 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h4><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position &#x3D; 0, capacity &#x3D; limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201109145905.png" alt="img"></a></p><h4 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h4><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h4 id="compact-方法"><a href="#compact-方法" class="headerlink" title="compact()方法"></a>compact()方法</h4><p><strong>此方法为ByteBuffer的方法，而不是Buffer的方法</strong></p><ul><li>compact会把未读完的数据向前压缩，然后切换到写模式</li><li>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210412155726.png" alt="img"></a></p><h4 id="clear-VS-compact"><a href="#clear-VS-compact" class="headerlink" title="clear() VS compact()"></a>clear() VS compact()</h4><p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong>但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p><p><strong>所以需要根据情况来判断使用哪种方法进行模式切换</strong></p><h3 id="方法调用及演示"><a href="#方法调用及演示" class="headerlink" title="方法调用及演示"></a>方法调用及演示</h3><h4 id="ByteBuffer调试工具类"><a href="#ByteBuffer调试工具类" class="headerlink" title="ByteBuffer调试工具类"></a>ByteBuffer调试工具类</h4><p>需要先导入netty依赖</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;dependency&gt;<br>  &lt;groupId&gt;io.netty&lt;/groupId&gt;<br>  &lt;artifactId&gt;netty-<span class="hljs-keyword">all</span>&lt;/artifactId&gt;<br>  &lt;<span class="hljs-keyword">version</span>&gt;<span class="hljs-number">4.1</span><span class="hljs-number">.51</span>.Final&lt;/<span class="hljs-keyword">version</span>&gt;<br>&lt;/dependency&gt;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><br><span class="hljs-keyword">import</span> io.netty.util.internal.MathUtil;<br><span class="hljs-keyword">import</span> io.netty.util.internal.StringUtil;<br><span class="hljs-keyword">import</span> io.netty.util.internal.MathUtil.*;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author Panwen Chen</span><br><span class="hljs-comment"> * @date 2021/4/12 15:59</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ByteBufferUtil &#123;<br>    private static final <span class="hljs-type">char</span>[] BYTE2CHAR = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">256</span>];<br>    private static final <span class="hljs-type">char</span>[] HEXDUMP_TABLE = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">256</span> * <span class="hljs-number">4</span>];<br>    private static final String[] HEXPADDING = <span class="hljs-built_in">new</span> String[<span class="hljs-number">16</span>];<br>    private static final String[] HEXDUMP_ROWPREFIXES = <span class="hljs-built_in">new</span> String[<span class="hljs-number">65536</span> &gt;&gt;&gt; <span class="hljs-number">4</span>];<br>    private static final String[] BYTE2HEX = <span class="hljs-built_in">new</span> String[<span class="hljs-number">256</span>];<br>    private static final String[] BYTEPADDING = <span class="hljs-built_in">new</span> String[<span class="hljs-number">16</span>];<br><br>    static &#123;<br>        final <span class="hljs-type">char</span>[] DIGITS = &quot;0123456789abcdef&quot;.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>            HEXDUMP_TABLE[i &lt;&lt; <span class="hljs-number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0x0F</span>];<br>            HEXDUMP_TABLE[(i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] = DIGITS[i &amp; <span class="hljs-number">0x0F</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> i;<br><br>        // Generate the lookup <span class="hljs-keyword">table</span> <span class="hljs-keyword">for</span> hex dump paddings<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> padding = HEXPADDING.length - i;<br>            StringBuilder buf = <span class="hljs-built_in">new</span> StringBuilder(padding * <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(&quot;   &quot;);<br>            &#125;<br>            HEXPADDING[i] = buf.toString();<br>        &#125;<br><br>        // Generate the lookup <span class="hljs-keyword">table</span> <span class="hljs-keyword">for</span> the <span class="hljs-keyword">start</span>-<span class="hljs-keyword">offset</span> <span class="hljs-keyword">header</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> (up <span class="hljs-keyword">to</span> <span class="hljs-number">64</span>KiB).<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;<br>            StringBuilder buf = <span class="hljs-built_in">new</span> StringBuilder(<span class="hljs-number">12</span>);<br>            buf.append(StringUtil.NEWLINE);<br>            buf.append(Long.toHexString(i &lt;&lt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xFFFFFFFF</span>L | <span class="hljs-number">0x100000000</span>L));<br>            buf.setCharAt(buf.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            buf.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>            HEXDUMP_ROWPREFIXES[i] = buf.toString();<br>        &#125;<br><br>        // Generate the lookup <span class="hljs-keyword">table</span> <span class="hljs-keyword">for</span> byte-<span class="hljs-keyword">to</span>-hex-dump <span class="hljs-keyword">conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;<br>            BYTE2HEX[i] = <span class="hljs-string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);<br>        &#125;<br><br>        // Generate the lookup <span class="hljs-keyword">table</span> <span class="hljs-keyword">for</span> byte dump paddings<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> padding = BYTEPADDING.length - i;<br>            StringBuilder buf = <span class="hljs-built_in">new</span> StringBuilder(padding);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>            BYTEPADDING[i] = buf.toString();<br>        &#125;<br><br>        // Generate the lookup <span class="hljs-keyword">table</span> <span class="hljs-keyword">for</span> byte-<span class="hljs-keyword">to</span>-<span class="hljs-type">char</span> <span class="hljs-keyword">conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0x1f</span> || i &gt;= <span class="hljs-number">0x7f</span>) &#123;<br>                BYTE2CHAR[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                BYTE2CHAR[i] = (<span class="hljs-type">char</span>) i;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印所有内容</span><br><span class="hljs-comment">     * @param buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> debugAll(ByteBuffer buffer) &#123;<br>        <span class="hljs-type">int</span> oldlimit = buffer.<span class="hljs-keyword">limit</span>();<br>        buffer.<span class="hljs-keyword">limit</span>(buffer.capacity());<br>        StringBuilder origin = <span class="hljs-built_in">new</span> StringBuilder(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(origin, buffer, <span class="hljs-number">0</span>, buffer.capacity());<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;+--------+-------------------- all ------------------------+----------------+&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), oldlimit);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(origin);<br>        buffer.<span class="hljs-keyword">limit</span>(oldlimit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印可读取内容</span><br><span class="hljs-comment">     * @param buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> debugRead(ByteBuffer buffer) &#123;<br>        StringBuilder builder = <span class="hljs-built_in">new</span> StringBuilder(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.<span class="hljs-keyword">limit</span>() - buffer.position());<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;+--------+-------------------- read -----------------------+----------------+&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.printf(&quot;position: [%d], limit: [%d]\n&quot;, buffer.position(), buffer.<span class="hljs-keyword">limit</span>());<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(builder);<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, <span class="hljs-type">int</span> <span class="hljs-keyword">offset</span>, <span class="hljs-type">int</span> length) &#123;<br>        <span class="hljs-keyword">if</span> (MathUtil.isOutOfBounds(<span class="hljs-keyword">offset</span>, length, buf.capacity())) &#123;<br>            throw <span class="hljs-built_in">new</span> IndexOutOfBoundsException(<br>                    &quot;expected: &quot; + &quot;0 &lt;= offset(&quot; + <span class="hljs-keyword">offset</span> + &quot;) &lt;= offset + length(&quot; + length<br>                            + &quot;) &lt;= &quot; + &quot;buf.capacity(&quot; + buf.capacity() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dump.append(<br>                &quot;         +-------------------------------------------------+&quot; +<br>                        StringUtil.NEWLINE + &quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot; +<br>                        StringUtil.NEWLINE + &quot;+--------+-------------------------------------------------+----------------+&quot;);<br><br>        final <span class="hljs-type">int</span> startIndex = <span class="hljs-keyword">offset</span>;<br>        final <span class="hljs-type">int</span> fullRows = length &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        final <span class="hljs-type">int</span> remainder = length &amp; <span class="hljs-number">0xF</span>;<br><br>        // Dump the <span class="hljs-keyword">rows</span> which have <span class="hljs-number">16</span> bytes.<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-keyword">row</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">row</span> &lt; fullRows; <span class="hljs-keyword">row</span>++) &#123;<br>            <span class="hljs-type">int</span> rowStartIndex = (<span class="hljs-keyword">row</span> &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br><br>            // Per-<span class="hljs-keyword">row</span> prefix.<br>            appendHexDumpRowPrefix(dump, <span class="hljs-keyword">row</span>, rowStartIndex);<br><br>            // Hex dump<br>            <span class="hljs-type">int</span> rowEndIndex = rowStartIndex + <span class="hljs-number">16</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(&quot; |&quot;);<br><br>            // ASCII dump<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        // Dump the last <span class="hljs-keyword">row</span> which has less than <span class="hljs-number">16</span> bytes.<br>        <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> rowStartIndex = (fullRows &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br>            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);<br><br>            // Hex dump<br>            <span class="hljs-type">int</span> rowEndIndex = rowStartIndex + remainder;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(HEXPADDING[remainder]);<br>            dump.append(&quot; |&quot;);<br><br>            // Ascii dump<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(BYTEPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        dump.append(StringUtil.NEWLINE +<br>                &quot;+--------+-------------------------------------------------+----------------+&quot;);<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> appendHexDumpRowPrefix(StringBuilder dump, <span class="hljs-type">int</span> <span class="hljs-keyword">row</span>, <span class="hljs-type">int</span> rowStartIndex) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span> &lt; HEXDUMP_ROWPREFIXES.length) &#123;<br>            dump.append(HEXDUMP_ROWPREFIXES[<span class="hljs-keyword">row</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dump.append(StringUtil.NEWLINE);<br>            dump.append(Long.toHexString(rowStartIndex &amp; <span class="hljs-number">0xFFFFFFFF</span>L | <span class="hljs-number">0x100000000</span>L));<br>            dump.setCharAt(dump.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static short getUnsignedByte(ByteBuffer buffer, <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br>        <span class="hljs-keyword">return</span> (short) (buffer.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">index</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调用ByteBuffer的方法"><a href="#调用ByteBuffer的方法" class="headerlink" title="调用ByteBuffer的方法"></a>调用ByteBuffer的方法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestByteBuffer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ByteBuffer buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 向buffer中写入1个字节的数据</span><br>        buffer.put((byte)<span class="hljs-number">97</span>);<br>        <span class="hljs-comment">// 使用工具类，查看buffer状态</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer</span>)</span>;<br><br>        <span class="hljs-comment">// 向buffer中写入4个字节的数据</span><br>        buffer.put(<span class="hljs-keyword">new</span> byte<span class="hljs-literal">[]</span>&#123;<span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>&#125;);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer</span>)</span>;<br><br>        <span class="hljs-comment">// 获取数据</span><br>        buffer.flip<span class="hljs-literal">()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer</span>)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(buffer.get<span class="hljs-literal">()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(buffer.get<span class="hljs-literal">()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer</span>)</span>;<br><br>        <span class="hljs-comment">// 使用compact切换模式</span><br>        buffer.compact<span class="hljs-literal">()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer</span>)</span>;<br><br>        <span class="hljs-comment">// 再次写入</span><br>        buffer.put((byte)<span class="hljs-number">102</span>);<br>        buffer.put((byte)<span class="hljs-number">103</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">// 向缓冲区写入了一个字节的数据，此时postition为1</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [1], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 00 00 00 00 00 00 00 00 00                   |a.........      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><span class="hljs-comment">// 向缓冲区写入四个字节的数据，此时position为5</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><span class="hljs-comment">// 调用flip切换模式，此时position为0，表示从第0个数据开始读取</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [0], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-comment">// 读取两个字节的数据             </span><br>97<br>98<br><span class="hljs-code">            </span><br><span class="hljs-comment">// position变为2             </span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [2], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 62 63 64 65 00 00 00 00 00                   |abcde.....      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">             </span><br><span class="hljs-comment">// 调用compact切换模式，此时position及其后面的数据被压缩到ByteBuffer前面去了</span><br><span class="hljs-comment">// 此时position为3，会覆盖之前的数据             </span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [3], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 64 65 64 65 00 00 00 00 00                   |cdede.....      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">             </span><br><span class="hljs-comment">// 再次写入两个字节的数据，之前的 0x64 0x65 被覆盖         </span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 64 65 66 67 00 00 00 00 00                   |cdefg.....      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h3 id="字符串与ByteBuffer的相互转换"><a href="#字符串与ByteBuffer的相互转换" class="headerlink" title="字符串与ByteBuffer的相互转换"></a><strong>字符串与ByteBuffer的相互转换</strong></h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>编码</strong>：字符串调用getByte方法获得byte数组，将byte数组放入ByteBuffer中</p><p><strong>解码</strong>：<strong>先调用ByteBuffer的flip方法，然后通过StandardCharsets的decoder方法解码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Translate &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 准备两个字符串</span><br>        String str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String str2 = <span class="hljs-string">&quot;&quot;</span>;<br><br><br>        ByteBuffer buffer1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 通过字符串的getByte方法获得字节数组，放入缓冲区中</span><br>        buffer1.put(str1.get<span class="hljs-constructor">Bytes()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br><br>        <span class="hljs-comment">// 将缓冲区中的数据转化为字符串</span><br>        <span class="hljs-comment">// 切换模式</span><br>        buffer1.flip<span class="hljs-literal">()</span>;<br>        <br>        <span class="hljs-comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span><br>        str2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>decode(buffer1).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str2);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [16]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>hello<br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>编码</strong>：通过StandardCharsets的encode方法获得ByteBuffer，此时获得的ByteBuffer为读模式，无需通过flip切换模式</p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Translate &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 准备两个字符串</span><br>        String str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String str2 = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 通过StandardCharsets的encode方法获得ByteBuffer</span><br>        <span class="hljs-comment">// 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span><br>        ByteBuffer buffer1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>encode(str1);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br><br>        <span class="hljs-comment">// 将缓冲区中的数据转化为字符串</span><br>        <span class="hljs-comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span><br>        str2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>decode(buffer1).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str2);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [0], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>hello<br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a><strong>方法三</strong></h4><p><strong>编码</strong>：字符串调用getByte()方法获得字节数组，将字节数组传给<strong>ByteBuffer的wrap()方法</strong>，通过该方法获得ByteBuffer。<strong>同样无需调用flip方法切换为读模式</strong></p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Translate &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 准备两个字符串</span><br>        String str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String str2 = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 通过StandardCharsets的encode方法获得ByteBuffer</span><br>        <span class="hljs-comment">// 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span><br>        ByteBuffer buffer1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>wrap(str1.get<span class="hljs-constructor">Bytes()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br><br>        <span class="hljs-comment">// 将缓冲区中的数据转化为字符串</span><br>        <span class="hljs-comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span><br>        str2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>decode(buffer1).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str2);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">buffer1</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [0], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>hello<br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [5], limit: [5]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h3 id="粘包与半包"><a href="#粘包与半包" class="headerlink" title="粘包与半包"></a>粘包与半包</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p><ul><li>Hello,world\n</li><li>I’m Nyima\n</li><li>How are you?\n</li></ul><p>变成了下面的两个 byteBuffer (粘包，半包)</p><ul><li>Hello,world\nI’m Nyima\nHo</li><li>w are you?\n</li></ul><h4 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h4><p><strong>粘包</strong></p><p>发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p><p><strong>半包</strong></p><p>接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li><p>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。</p><p>注意</p><p>：get(index)不会改变position的值</p><ul><li>记录该段数据长度，以便于申请对应大小的缓冲区</li><li>将缓冲区的数据通过get()方法写入到target中</li></ul></li><li><p>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</p></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufferDemo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">32</span>);<br>        <span class="hljs-comment">// 模拟粘包+半包</span><br>        buffer.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;Hello,world\nI&#x27;m Nyima\nHo&quot;</span>.<span class="hljs-built_in">getBytes</span>());<br>        <span class="hljs-comment">// 调用split函数处理</span><br>        <span class="hljs-built_in">split</span>(buffer);<br>        buffer.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;w are you?\n&quot;</span>.<span class="hljs-built_in">getBytes</span>());<br>        <span class="hljs-built_in">split</span>(buffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(ByteBuffer buffer)</span> </span>&#123;<br>        <span class="hljs-comment">// 切换为读模式</span><br>        buffer.<span class="hljs-built_in">flip</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.<span class="hljs-built_in">limit</span>(); i++) &#123;<br><br>            <span class="hljs-comment">// 遍历寻找分隔符</span><br>            <span class="hljs-comment">// get(i)不会移动position</span><br>            <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">get</span>(i) == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 缓冲区长度</span><br>                <span class="hljs-type">int</span> length = i+<span class="hljs-number">1</span>-buffer.<span class="hljs-built_in">position</span>();<br>                ByteBuffer target = ByteBuffer.<span class="hljs-built_in">allocate</span>(length);<br>                <span class="hljs-comment">// 将前面的内容写入target缓冲区</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                    <span class="hljs-comment">// 将buffer中的数据写入target中</span><br>                    target.<span class="hljs-built_in">put</span>(buffer.<span class="hljs-built_in">get</span>());<br>                &#125;<br>                <span class="hljs-comment">// 打印查看结果</span><br>                ByteBufferUtil.<span class="hljs-built_in">debugAll</span>(target);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 切换为写模式，但是缓冲区可能未读完，这里需要使用compact</span><br>        buffer.<span class="hljs-built_in">compact</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [12], limit: [12]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 48 65 6c 6c 6f 2c 77 6f 72 6c 64 0a             |Hello,world.    |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [10], limit: [10]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 49 27 6d 20 4e 79 69 6d 61 0a                   |I&#x27;m Nyima.      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">+--------+</span>-------------------- all ------------------------<span class="hljs-code">+----------------+</span><br>position: [13], limit: [13]<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 48 6f 77 20 61 72 65 20 79 6f 75 3f 0a          |How are you?.   |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h1 id="二、文件编程"><a href="#二、文件编程" class="headerlink" title="二、文件编程"></a>二、文件编程</h1><h2 id="1、FileChannel"><a href="#1、FileChannel" class="headerlink" title="1、FileChannel"></a>1、FileChannel</h2><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>FileChannel<strong>只能在阻塞模式下工作</strong>，所以无法搭配Selector</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开 FileChannel，<strong>必须</strong>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel <strong>只能读</strong></li><li>通过 FileOutputStream 获取的 channel <strong>只能写</strong></li><li>通过 RandomAccessFile 是否能读写<strong>根据构造 RandomAccessFile 时的读写模式决定</strong></li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中</p><p>read方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> readBytes = channel.<span class="hljs-built_in">read</span>(buffer);<br></code></pre></td></tr></table></figure><p><strong>可根据返回值判断是否读取完毕</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(channel.read(buffer)</span></span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 进行对应操作</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>因为channel也是有大小的，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须<strong>需要按照以下规则进行写入</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中</span><br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">buffer</span>.hasRemaining()) &#123;<br>channel.write(<span class="hljs-built_in">buffer</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>通道需要close，一般情况通过try-with-resource进行关闭，<strong>最好使用以下方法获取strea以及channel，避免某些原因使得资源未被关闭</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestChannel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;stu.txt&quot;</span>);<br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;student.txt&quot;</span>);<br>             <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inputChannel</span> <span class="hljs-operator">=</span> fis.getChannel();<br>             <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outputChannel</span> <span class="hljs-operator">=</span> fos.getChannel()) &#123;<br>            <br>            <span class="hljs-comment">// 执行对应操作</span><br>            ...<br>                <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><strong>position</strong></p><p>channel也拥有一个保存读取数据位置的属性，即position</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">long pos <span class="hljs-operator">=</span> channel.position()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以通过position(int pos)设置channel中position的值</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">long <span class="hljs-keyword">new</span><span class="hljs-type">Pos</span> = ...;<br>channel.position(<span class="hljs-keyword">new</span><span class="hljs-type">Pos</span>);<br></code></pre></td></tr></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1 </li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 <strong>force(true)</strong>  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h2 id="2、两个Channel传输数据"><a href="#2、两个Channel传输数据" class="headerlink" title="2、两个Channel传输数据"></a>2、两个Channel传输数据</h2><h3 id="transferTo方法"><a href="#transferTo方法" class="headerlink" title="transferTo方法"></a>transferTo方法</h3><p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但<strong>一次只能传输2G的内容</strong></p><p>transferTo底层使用了零拷贝技术</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestChannel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;stu.txt&quot;</span>);<br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;student.txt&quot;</span>);<br>             <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inputChannel</span> <span class="hljs-operator">=</span> fis.getChannel();<br>             <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outputChannel</span> <span class="hljs-operator">=</span> fos.getChannel()) &#123;<br>            <span class="hljs-comment">// 参数：inputChannel的起始位置，传输数据的大小，目的channel</span><br>            <span class="hljs-comment">// 返回值为传输的数据的字节数</span><br>            <span class="hljs-comment">// transferTo一次只能传输2G的数据</span><br>            inputChannel.transferTo(<span class="hljs-number">0</span>, inputChannel.size(), outputChannel);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当传输的文件<strong>大于2G</strong>时，需要使用以下方法进行多次传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestChannel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;stu.txt&quot;</span>);<br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;student.txt&quot;</span>);<br>             <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inputChannel</span> <span class="hljs-operator">=</span> fis.getChannel();<br>             <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outputChannel</span> <span class="hljs-operator">=</span> fos.getChannel()) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> inputChannel.size();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> inputChannel.size();<br>            <span class="hljs-comment">// 分多次传输</span><br>            <span class="hljs-keyword">while</span> (capacity &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// transferTo返回值为传输了的字节数</span><br>                capacity -= inputChannel.transferTo(size-capacity, capacity, outputChannel);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、Path与Paths"><a href="#3、Path与Paths" class="headerlink" title="3、Path与Paths"></a>3、Path与Paths</h2><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Path</span> source = Paths.<span class="hljs-keyword">get</span>(&quot;1.txt&quot;); // 相对路径 不带盘符 使用 <span class="hljs-keyword">user</span>.dir 环境变量来定位 <span class="hljs-number">1.</span>txt<br><br><span class="hljs-type">Path</span> source = Paths.<span class="hljs-keyword">get</span>(&quot;d:\\1.txt&quot;); // 绝对路径 代表了  d:\<span class="hljs-number">1.</span>txt 反斜杠需要转义<br><br><span class="hljs-type">Path</span> source = Paths.<span class="hljs-keyword">get</span>(&quot;d:/1.txt&quot;); // 绝对路径 同样代表了  d:\<span class="hljs-number">1.</span>txt<br><br><span class="hljs-type">Path</span> projects = Paths.<span class="hljs-keyword">get</span>(&quot;d:\\data&quot;, &quot;projects&quot;); // 代表了  d:\data\projects<br></code></pre></td></tr></table></figure><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">d:<br><span class="hljs-string">|- data</span><br><span class="hljs-string">|- projects</span><br><span class="hljs-string">|- a</span><br><span class="hljs-string">|- b</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;d:\\data\\projects\\a\\..\\b&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">path</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">path</span>.normalize()); // 正常化路径 会去除 . 以及 ..<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">d</span>:\<span class="hljs-class"><span class="hljs-keyword">data</span>\projects\a\..\b</span><br><span class="hljs-title">d</span>:\<span class="hljs-class"><span class="hljs-keyword">data</span>\projects\b</span><br></code></pre></td></tr></table></figure><h2 id="4、Files"><a href="#4、Files" class="headerlink" title="4、Files"></a>4、Files</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>检查文件是否存在</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/data.txt&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Files.<span class="hljs-keyword">exists</span>(<span class="hljs-type">path</span>));<br></code></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建<strong>一级目录</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/d1&quot;);<br>Files.createDirectory(<span class="hljs-type">path</span>);<br></code></pre></td></tr></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建<strong>多级目录用</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/d1/d2&quot;);<br>Files.createDirectories(<span class="hljs-type">path</span>);<br></code></pre></td></tr></table></figure><h3 id="拷贝及移动"><a href="#拷贝及移动" class="headerlink" title="拷贝及移动"></a>拷贝及移动</h3><p><strong>拷贝文件</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Path</span> source = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/data.txt&quot;);<br><span class="hljs-type">Path</span> target = Paths.<span class="hljs-keyword">get</span>(&quot;helloword/target.txt&quot;);<br><br>Files.<span class="hljs-keyword">copy</span>(source, target);<br></code></pre></td></tr></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source <strong>覆盖</strong>掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Files.<span class="hljs-keyword">copy</span>(<span class="hljs-keyword">source</span>, target, StandardCopyOption.REPLACE_EXISTING);<br></code></pre></td></tr></table></figure><p>移动文件</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Path</span> source = <span class="hljs-keyword">Paths</span>.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><span class="hljs-keyword">Path</span> target = <span class="hljs-keyword">Paths</span>.get(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br><br>Files.<span class="hljs-built_in">move</span>(source, target, StandardCopyOption.ATOMIC_MOVE);<br></code></pre></td></tr></table></figure><ul><li><strong>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</strong></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除文件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Path target <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/target.txt&quot;</span>)<span class="hljs-comment">;</span><br><br>Files.delete(target)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Path target <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;helloword/d1&quot;</span>)<span class="hljs-comment">;</span><br><br>Files.delete(target)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>如果<strong>目录还有内容</strong>，会抛异常 DirectoryNotEmptyException</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>可以<strong>使用Files工具类中的walkFileTree(Path, FileVisitor)方法</strong>，其中需要传入两个参数</p><ul><li><p>Path：文件起始路径</p></li><li><p>FileVisitor：文件访问器，</p><p>使用访问者模式</p><ul><li><p>接口的实现类</p><p>SimpleFileVisitor</p><p>有四个方法</p><ul><li>preVisitDirectory：访问目录前的操作</li><li>visitFile：访问文件的操作</li><li>visitFileFailed：访问文件失败时的操作</li><li>postVisitDirectory：访问目录后的操作</li></ul></li></ul></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestWalkFileTree &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        Path path = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Paths</span>.</span></span>get(<span class="hljs-string">&quot;F:\\JDK 8&quot;</span>);<br>        <span class="hljs-comment">// 文件目录数目</span><br>        AtomicInteger dirCount = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AtomicInteger()</span>;<br>        <span class="hljs-comment">// 文件数目</span><br>        AtomicInteger fileCount = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AtomicInteger()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Files</span>.</span></span>walk<span class="hljs-constructor">FileTree(<span class="hljs-params">path</span>, <span class="hljs-params">new</span> SimpleFileVisitor&lt;Path&gt;()</span>&#123;<br>            @Override<br>            public FileVisitResult pre<span class="hljs-constructor">VisitDirectory(Path <span class="hljs-params">dir</span>, BasicFileAttributes <span class="hljs-params">attrs</span>)</span> throws IOException &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;===&gt;&quot;</span>+dir);<br>                <span class="hljs-comment">// 增加文件目录数</span><br>                dirCount.increment<span class="hljs-constructor">AndGet()</span>;<br>                return super.pre<span class="hljs-constructor">VisitDirectory(<span class="hljs-params">dir</span>, <span class="hljs-params">attrs</span>)</span>;<br>            &#125;<br><br>            @Override<br>            public FileVisitResult visit<span class="hljs-constructor">File(Path <span class="hljs-params">file</span>, BasicFileAttributes <span class="hljs-params">attrs</span>)</span> throws IOException &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(file);<br>                <span class="hljs-comment">// 增加文件数</span><br>                fileCount.increment<span class="hljs-constructor">AndGet()</span>;<br>                return super.visit<span class="hljs-constructor">File(<span class="hljs-params">file</span>, <span class="hljs-params">attrs</span>)</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 打印数目</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;文件目录数:&quot;</span>+dirCount.get<span class="hljs-literal">()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;文件数:&quot;</span>+fileCount.get<span class="hljs-literal">()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livescript">...<br>===&gt;F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\lib\security\policy\unlimited</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\lib\security\policy\unlimited\local_policy.jar</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\lib\security\policy\unlimited\US_export_policy.jar</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\lib\security\trusted.libraries</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\lib\sound.properties</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\lib\tzdb.dat</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\lib\tzmappings</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\LICENSE</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\README.txt</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\release</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\THIRDPARTYLICENSEREADME-JAVAFX.txt</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\THIRDPARTYLICENSEREADME.txt</span><br>F:<span class="hljs-string">\JDK</span> <span class="hljs-number">8</span><span class="hljs-string">\Welcome.html</span><br>文件目录数:<span class="hljs-number">23</span><br>文件数:<span class="hljs-number">279</span><br></code></pre></td></tr></table></figure><h1 id="三、网络编程"><a href="#三、网络编程" class="headerlink" title="三、网络编程"></a>三、网络编程</h1><h2 id="1、阻塞"><a href="#1、阻塞" class="headerlink" title="1、阻塞"></a>1、阻塞</h2><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li><li>SocketChannel.read 会在<strong>通道中没有数据可读时</strong>让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><p><strong>服务端代码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Server &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 创建缓冲区</span><br>        ByteBuffer buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>) &#123;<br>            <span class="hljs-comment">// 为服务器通道绑定端口</span><br>            server.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(8080)</span>);<br>            <span class="hljs-comment">// 用户存放连接的集合</span><br>            ArrayList&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 循环接收连接</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before connecting...&quot;</span>);<br>                <span class="hljs-comment">// 没有连接时，会阻塞线程</span><br>                SocketChannel socketChannel = server.accept<span class="hljs-literal">()</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after connecting...&quot;</span>);<br>                channels.add(socketChannel);<br>                <span class="hljs-comment">// 循环遍历集合中的连接</span><br>                <span class="hljs-keyword">for</span>(SocketChannel channel : channels) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before reading&quot;</span>);<br>                    <span class="hljs-comment">// 处理通道中的数据</span><br>                    <span class="hljs-comment">// 当通道中没有数据可读时，会阻塞线程</span><br>                    channel.read(buffer);<br>                    buffer.flip<span class="hljs-literal">()</span>;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">Read(<span class="hljs-params">buffer</span>)</span>;<br>                    buffer.clear<span class="hljs-literal">()</span>;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after reading&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; catch (IOException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-title class_">SocketChannel</span> socketChannel = <span class="hljs-title class_">SocketChannel</span>.<span class="hljs-title function_">open</span>()) &#123;<br>            <span class="hljs-comment">// 建立连接</span><br>            socketChannel.<span class="hljs-title function_">connect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><ul><li>客户端-服务器建立连接前：服务器端因accept阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213318.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213318.png" alt="img"></a></p><ul><li>客户端-服务器建立连接后，客户端发送消息前：服务器端因通道为空被阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213446.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413213446.png" alt="img"></a></p><ul><li>客户端发送数据后，服务器处理通道中的数据。再次进入循环时，再次被accept阻塞</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214109.png" alt="img"></a></p><ul><li>之前的客户端再次发送消息<strong>，服务器端因为被accept阻塞</strong>，无法处理之前客户端发送到通道中的信息</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214505.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210413214505.png" alt="img"></a></p><h2 id="2、非阻塞"><a href="#2、非阻塞" class="headerlink" title="2、非阻塞"></a>2、非阻塞</h2><ul><li>可以通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li><li>可以通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li></ul><p>服务器代码如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建缓冲区</span><br>        ByteBuffer buffer = ByteBuffer.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-built_in">try</span>(ServerSocketChannel server = ServerSocketChannel.<span class="hljs-built_in">open</span>()) &#123;<br>            <span class="hljs-comment">// 为服务器通道绑定端口</span><br>            server.<span class="hljs-built_in">bind</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 用户存放连接的集合</span><br>            ArrayList&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">// 循环接收连接</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 设置为非阻塞模式，没有连接时返回null，不会阻塞线程</span><br>                server.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>                SocketChannel socketChannel = server.<span class="hljs-built_in">accept</span>();<br>                <span class="hljs-comment">// 通道不为空时才将连接放入到集合中</span><br>                <span class="hljs-keyword">if</span> (socketChannel != null) &#123;<br>                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;after connecting...&quot;</span>);<br>                    channels.<span class="hljs-built_in">add</span>(socketChannel);<br>                &#125;<br>                <span class="hljs-comment">// 循环遍历集合中的连接</span><br>                <span class="hljs-keyword">for</span>(SocketChannel channel : channels) &#123;<br>                    <span class="hljs-comment">// 处理通道中的数据</span><br>                    <span class="hljs-comment">// 设置为非阻塞模式，若通道中没有数据，会返回0，不会阻塞线程</span><br>                    channel.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-type">int</span> read = channel.<span class="hljs-built_in">read</span>(buffer);<br>                    <span class="hljs-keyword">if</span>(read &gt; <span class="hljs-number">0</span>) &#123;<br>                        buffer.<span class="hljs-built_in">flip</span>();<br>                        ByteBufferUtil.<span class="hljs-built_in">debugRead</span>(buffer);<br>                        buffer.<span class="hljs-built_in">clear</span>();<br>                        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;after reading&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-built_in">catch</span> (IOException e) &#123;<br>            e.<span class="hljs-built_in">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写存在一个问题，因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</p><h2 id="3、Selector"><a href="#3、Selector" class="headerlink" title="3、Selector"></a>3、Selector</h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p><ul><li><strong>多路复用仅针对网络 IO</strong>，普通文件 IO <strong>无法</strong>利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><h2 id="4、使用及Accpet事件"><a href="#4、使用及Accpet事件" class="headerlink" title="4、使用及Accpet事件"></a>4、使用及Accpet事件</h2><p>要使用Selector实现多路复用，服务端代码如下改进</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> SelectServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ByteBuffer buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>) &#123;<br>            server.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(8080)</span>);<br>            <span class="hljs-comment">// 创建选择器</span><br>            Selector selector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Selector</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>            <br>            <span class="hljs-comment">// 通道必须设置为非阻塞模式</span><br>            server.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>            <span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的事件</span><br>            server.register(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span><br>                <span class="hljs-comment">// 返回值为就绪的事件个数</span><br>                <span class="hljs-built_in">int</span> ready = selector.select<span class="hljs-literal">()</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;selector ready counts : &quot;</span> + ready);<br>                <br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selected<span class="hljs-constructor">Keys()</span>;<br>                <br>                <span class="hljs-comment">// 使用迭代器遍历事件</span><br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">while</span> (iterator.has<span class="hljs-constructor">Next()</span>) &#123;<br>                    SelectionKey key = iterator.next<span class="hljs-literal">()</span>;<br>                    <br>                    <span class="hljs-comment">// 判断key的类型</span><br>                    <span class="hljs-keyword">if</span>(key.is<span class="hljs-constructor">Acceptable()</span>) &#123;<br>                        <span class="hljs-comment">// 获得key对应的channel</span><br>                        ServerSocketChannel channel = (ServerSocketChannel) key.channel<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before accepting...&quot;</span>);<br>                        <br>        <span class="hljs-comment">// 获取连接并处理，而且是必须处理，否则需要取消</span><br>                        SocketChannel socketChannel = channel.accept<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after accepting...&quot;</span>);<br>                        <br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.remove<span class="hljs-literal">()</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; catch (IOException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>步骤解析</strong></p><ul><li>获得选择器Selector</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span> = <span class="hljs-keyword">Selector</span>.open()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><ul><li><p>将</p><p>通道设置为非阻塞模式</p><p>，并注册到选择器中，并设置感兴趣的事件</p><ul><li><p>channel 必须工作在非阻塞模式</p></li><li><p>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</p></li><li><p>绑定的</p><p>事件类型</p><p>可以有</p><ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接受连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul></li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 通道必须设置为非阻塞模式</span><br><span class="hljs-keyword">server</span>.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的实践</span><br><span class="hljs-keyword">server</span>.register(selector, SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p><ul><li><p>阻塞直到绑定事件发生</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = selector.<span class="hljs-keyword">select</span>();<br></code></pre></td></tr></table></figure></li></ul><p>阻塞直到绑定事件发生，<strong>或是超时</strong>（时间单位为 ms）</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = selector.<span class="hljs-keyword">select</span>(<span class="hljs-built_in">long</span> timeout);<br></code></pre></td></tr></table></figure><p><strong>不会阻塞</strong>，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int count <span class="hljs-operator">=</span> selector.selectNow()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>获取就绪事件并<strong>得到对应的通道</strong>，然后进行处理</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取所有事件<br>Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                <br><span class="hljs-regexp">//</span> 使用迭代器遍历事件<br>Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br><br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>SelectionKey key = iterator.<span class="hljs-keyword">next</span>();<br>                    <br><span class="hljs-regexp">//</span> 判断key的类型，此处为Accept类型<br><span class="hljs-keyword">if</span>(key.isAcceptable()) &#123;<br>        <span class="hljs-regexp">//</span> 获得key对应的channel<br>        ServerSocketChannel channel = (ServerSocketChannel) key.channel();<br><br>        <span class="hljs-regexp">//</span> 获取连接并处理，而且是必须处理，否则需要取消<br>        SocketChannel socketChannel = channel.accept();<br><br>        <span class="hljs-regexp">//</span> 处理完毕后移除<br>        iterator.remove();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>事件发生后能否不处理</strong></p><p>事件发生后，<strong>要么处理，要么取消（cancel）</strong>，不能什么都不做，<strong>否则下次该事件仍会触发</strong>，这是因为 nio 底层使用的是水平触发</p><h2 id="5、Read事件"><a href="#5、Read事件" class="headerlink" title="5、Read事件"></a>5、Read事件</h2><ul><li>在Accept事件中，若有客户端与服务器端建立了连接，<strong>需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</strong></li><li>添加Read事件，触发后进行读取操作</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> SelectServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        ByteBuffer buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">16</span>);<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>) &#123;<br>            server.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(8080)</span>);<br>            <span class="hljs-comment">// 创建选择器</span><br>            Selector selector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Selector</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 通道必须设置为非阻塞模式</span><br>            server.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>            <span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的实践</span><br>            server.register(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-comment">// 为serverKey设置感兴趣的事件</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span><br>                <span class="hljs-comment">// 返回值为就绪的事件个数</span><br>                <span class="hljs-built_in">int</span> ready = selector.select<span class="hljs-literal">()</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;selector ready counts : &quot;</span> + ready);<br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selected<span class="hljs-constructor">Keys()</span>;<br>                <span class="hljs-comment">// 使用迭代器遍历事件</span><br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">while</span> (iterator.has<span class="hljs-constructor">Next()</span>) &#123;<br>                    SelectionKey key = iterator.next<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">// 判断key的类型</span><br>                    <span class="hljs-keyword">if</span>(key.is<span class="hljs-constructor">Acceptable()</span>) &#123;<br>                        <span class="hljs-comment">// 获得key对应的channel</span><br>                        ServerSocketChannel channel = (ServerSocketChannel) key.channel<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before accepting...&quot;</span>);<br>                        <span class="hljs-comment">// 获取连接</span><br>                        SocketChannel socketChannel = channel.accept<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after accepting...&quot;</span>);<br>                        <span class="hljs-comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中</span><br>                        socketChannel.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>                        socketChannel.register(selector, SelectionKey.OP_READ);<br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.remove<span class="hljs-literal">()</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.is<span class="hljs-constructor">Readable()</span>) &#123;<br>                        SocketChannel channel = (SocketChannel) key.channel<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before reading...&quot;</span>);<br>                        channel.read(buffer);<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after reading...&quot;</span>);<br>                        buffer.flip<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">Read(<span class="hljs-params">buffer</span>)</span>;<br>                        buffer.clear<span class="hljs-literal">()</span>;<br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.remove<span class="hljs-literal">()</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; catch (IOException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除事件</strong></p><p><strong>当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误</strong>。原因如下</p><p>以我们上面的 <strong>Read事件</strong> 的代码为例</p><ul><li><p>当调用了 server.register(selector, SelectionKey.OP_ACCEPT)后，Selector中维护了一个集合，<strong>用于存放SelectionKey以及其对应的通道</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// WindowsSelectorImpl 中的 SelectionKeyImpl数组</span><br><span class="hljs-keyword">private</span> SelectionKeyImpl[] channelArray = <span class="hljs-keyword">new</span> <span class="hljs-type">SelectionKeyImpl</span>[<span class="hljs-number">8</span>];<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectionKeyImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSelectionKey</span> </span>&#123;<br>    <span class="hljs-comment">// Key对应的通道</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelChImpl</span> channel;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png" alt="img"></a></li><li>当<strong>选择器中的通道对应的事件发生后</strong>，selecionKey会被放到另一个集合中，但是<strong>selecionKey不会自动移除</strong>，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png" alt="img"></a></li></ul><h3 id="断开处理"><a href="#断开处理" class="headerlink" title="断开处理"></a>断开处理</h3><p>当客户端与服务器之间的连接<strong>断开时，会给服务器端发送一个读事件</strong>，对异常断开和正常断开需要加以不同的方式进行处理</p><ul><li><p><strong>正常断开</strong></p><ul><li><p>正常断开时，服务器端的channel.read(buffer)方法的返回值为-1，<strong>所以当结束到返回值为-1时，需要调用key的cancel方法取消此事件，并在取消后移除该事件</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs maxima">int <span class="hljs-built_in">read</span> = channel.<span class="hljs-built_in">read</span>(buffer);<br>// 断开连接时，客户端会向服务器发送一个写事件，此时<span class="hljs-built_in">read</span>的返回值为-<span class="hljs-number">1</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span> == -<span class="hljs-number">1</span>) &#123;<br>    // 取消该事件的处理<br><span class="hljs-built_in">key</span>.cancel();<br>    channel.<span class="hljs-built_in">close</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    ...<br>&#125;<br>// 取消或者处理，都需要移除<span class="hljs-built_in">key</span><br>iterator.<span class="hljs-built_in">remove</span>();<br></code></pre></td></tr></table></figure></li></ul></li><li><p>异常断开</p><ul><li>异常断开时，会抛出IOException异常， 在try-catch的<strong>catch块中捕获异常并调用key的cancel方法即可</strong></li></ul></li></ul><h3 id="消息边界"><a href="#消息边界" class="headerlink" title="消息边界"></a>消息边界</h3><p><strong>不处理消息边界存在的问题</strong></p><p>将缓冲区的大小设置为4个字节，发送2个汉字（你好），通过decode解码并打印时，会出现乱码</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ByteBuffer <span class="hljs-built_in">buffer</span> = ByteBuffer.allocate(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 解码并打印</span><br>System.out.println(StandardCharsets.UTF_8.<span class="hljs-built_in">decode</span>(<span class="hljs-built_in">buffer</span>));<br>你�<br>��<br></code></pre></td></tr></table></figure><p>这是因为UTF-8字符集下，1个汉字占用3个字节，此时缓冲区大小为4个字节，<strong>一次读时间无法处理完通道中的所有数据，所以一共会触发两次读事件</strong>。这就导致 <code>你好</code> 的 <code>好</code> 字被拆分为了前半部分和后半部分发送，解码时就会出现问题</p><p><strong>处理消息边界</strong></p><p>传输的文本可能有以下三种情况</p><ul><li>文本大于缓冲区大小<ul><li>此时需要将缓冲区进行扩容</li></ul></li><li>发生半包现象</li><li>发生粘包现象</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103442.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103442.png" alt="img"></a></p><p>解决思路大致有以下三种</p><ul><li><p><strong>固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</p></li><li><p>另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符</p></li><li><p>TLV 格式，即 Type 类型、Length 长度、Value 数据</p><p>（也就是在消息开头</p><p>用一些空间存放后面数据的长度</p><p>），如HTTP请求头中的Content-Type与</p><p>Content-Length</p><p>。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量</p><ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103926.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103926.png" alt="img"></a></li></ul></li></ul><p>下文的消息边界处理方式为<strong>第二种：按分隔符拆分</strong></p><p><strong>附件与扩容</strong></p><p>Channel的register方法还有<strong>第三个参数</strong>：<code>附件</code>，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的SelectionKey绑定，可以从SelectionKey获取到对应通道的附件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> SelectionKey <span class="hljs-title function_">register</span><span class="hljs-params">(Selector sel, <span class="hljs-type">int</span> ops, Object att)</span><br></code></pre></td></tr></table></figure><p>可通过SelectionKey的<strong>attachment()方法获得附件</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ByteBuffer </span><span class="hljs-keyword">buffer </span>= (<span class="hljs-keyword">ByteBuffer) </span>key.attachment();<br></code></pre></td></tr></table></figure><p>我们需要在Accept事件发生后，将通道注册到Selector中时，<strong>对每个通道添加一个ByteBuffer附件</strong>，让每个通道发生读事件时都使用自己的通道，避免与其他通道发生冲突而导致问题</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件</span><br>socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>ByteBuffer <span class="hljs-built_in">buffer</span> = ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 添加通道对应的Buffer附件</span><br>socketChannel.register(selector, SelectionKey.OP_READ, <span class="hljs-built_in">buffer</span>);<br></code></pre></td></tr></table></figure><p>当Channel中的数据大于缓冲区时，需要对缓冲区进行<strong>扩容</strong>操作。此代码中的扩容的判定方法：<strong>Channel调用compact方法后，的position与limit相等，说明缓冲区中的数据并未被读取（容量太小），此时创建新的缓冲区，其大小扩大为两倍。同时还要将旧缓冲区中的数据拷贝到新的缓冲区中，同时调用SelectionKey的attach方法将新的缓冲区作为新的附件放入SelectionKey中</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 如果缓冲区太小，就进行扩容</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">buffer</span>.position() == <span class="hljs-built_in">buffer</span>.limit()) &#123;<br>    ByteBuffer newBuffer = ByteBuffer.allocate(<span class="hljs-built_in">buffer</span>.capacity()*<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 将旧buffer中的内容放入新的buffer中</span><br>    ewBuffer.put(<span class="hljs-built_in">buffer</span>);<br>    <span class="hljs-comment">// 将新buffer作为附件放到key中</span><br>    key.attach(newBuffer);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改造后的服务器代码如下</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> SelectServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-comment">// 获得服务器通道</span><br>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>) &#123;<br>            server.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(8080)</span>);<br>            <span class="hljs-comment">// 创建选择器</span><br>            Selector selector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Selector</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>            <span class="hljs-comment">// 通道必须设置为非阻塞模式</span><br>            server.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>            <span class="hljs-comment">// 将通道注册到选择器中，并设置感兴趣的事件</span><br>            server.register(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-comment">// 为serverKey设置感兴趣的事件</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span><br>                <span class="hljs-comment">// 返回值为就绪的事件个数</span><br>                <span class="hljs-built_in">int</span> ready = selector.select<span class="hljs-literal">()</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;selector ready counts : &quot;</span> + ready);<br>                <span class="hljs-comment">// 获取所有事件</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selected<span class="hljs-constructor">Keys()</span>;<br>                <span class="hljs-comment">// 使用迭代器遍历事件</span><br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">while</span> (iterator.has<span class="hljs-constructor">Next()</span>) &#123;<br>                    SelectionKey key = iterator.next<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">// 判断key的类型</span><br>                    <span class="hljs-keyword">if</span>(key.is<span class="hljs-constructor">Acceptable()</span>) &#123;<br>                        <span class="hljs-comment">// 获得key对应的channel</span><br>                        ServerSocketChannel channel = (ServerSocketChannel) key.channel<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before accepting...&quot;</span>);<br>                        <span class="hljs-comment">// 获取连接</span><br>                        SocketChannel socketChannel = channel.accept<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after accepting...&quot;</span>);<br>                        <span class="hljs-comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件</span><br>                        socketChannel.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>                        ByteBuffer buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(<span class="hljs-number">16</span>);<br>                        socketChannel.register(selector, SelectionKey.OP_READ, buffer);<br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.remove<span class="hljs-literal">()</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.is<span class="hljs-constructor">Readable()</span>) &#123;<br>                        SocketChannel channel = (SocketChannel) key.channel<span class="hljs-literal">()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;before reading...&quot;</span>);<br>                        <span class="hljs-comment">// 通过key获得附件（buffer）</span><br>                        ByteBuffer buffer = (ByteBuffer) key.attachment<span class="hljs-literal">()</span>;<br>                        <span class="hljs-built_in">int</span> read = channel.read(buffer);<br>                        <span class="hljs-keyword">if</span>(read<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>) &#123;<br>                            key.cancel<span class="hljs-literal">()</span>;<br>                            channel.close<span class="hljs-literal">()</span>;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">// 通过分隔符来分隔buffer中的数据</span><br>                            split(buffer);<br>                            <span class="hljs-comment">// 如果缓冲区太小，就进行扩容</span><br>                            <span class="hljs-keyword">if</span> (buffer.position<span class="hljs-literal">()</span><span class="hljs-operator"> == </span>buffer.limit<span class="hljs-literal">()</span>) &#123;<br>                                ByteBuffer newBuffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(buffer.capacity<span class="hljs-literal">()</span>*<span class="hljs-number">2</span>);<br>                                <span class="hljs-comment">// 将旧buffer中的内容放入新的buffer中</span><br>                                buffer.flip<span class="hljs-literal">()</span>;<br>                                newBuffer.put(buffer);<br>                                <span class="hljs-comment">// 将新buffer放到key中作为附件</span><br>                                key.attach(newBuffer);<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;after reading...&quot;</span>);<br>                        <span class="hljs-comment">// 处理完毕后移除</span><br>                        iterator.remove<span class="hljs-literal">()</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; catch (IOException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static void split(ByteBuffer buffer) &#123;<br>        buffer.flip<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.limit<span class="hljs-literal">()</span>; i++) &#123;<br>            <span class="hljs-comment">// 遍历寻找分隔符</span><br>            <span class="hljs-comment">// get(i)不会移动position</span><br>            <span class="hljs-keyword">if</span> (buffer.get(i)<span class="hljs-operator"> == </span><span class="hljs-character">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 缓冲区长度</span><br>                <span class="hljs-built_in">int</span> length = i+<span class="hljs-number">1</span>-buffer.position<span class="hljs-literal">()</span>;<br>                ByteBuffer target = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(length);<br>                <span class="hljs-comment">// 将前面的内容写入target缓冲区</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                    <span class="hljs-comment">// 将buffer中的数据写入target中</span><br>                    target.put(buffer.get<span class="hljs-literal">()</span>);<br>                &#125;<br>                <span class="hljs-comment">// 打印结果</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBufferUtil</span>.</span></span>debug<span class="hljs-constructor">All(<span class="hljs-params">target</span>)</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 切换为写模式，但是缓冲区可能未读完，这里需要使用compact</span><br>        buffer.compact<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ByteBuffer的大小分配"><a href="#ByteBuffer的大小分配" class="headerlink" title="ByteBuffer的大小分配"></a>ByteBuffer的大小分配</h3><ul><li>每个 channel 都需要记录可能被切分的消息，因为 <strong>ByteBuffer 不能被多个 channel 共同使用</strong>，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer</li><li>分配思路可以参考<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能<ul><li>参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li></ul></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h2 id="6、Write事件"><a href="#6、Write事件" class="headerlink" title="6、Write事件"></a>6、Write事件</h2><p>服务器通过Buffer向通道中写入数据时，<strong>可能因为通道容量小于Buffer中的数据大小，导致无法一次性将Buffer中的数据全部写入到Channel中，这时便需要分多次写入</strong>，具体步骤如下</p><ul><li><p>执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据</p></li><li><p>若Buffer中还有数据，则<strong>需要将SockerChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> <span class="hljs-type">int</span> write = socket.<span class="hljs-built_in">write</span>(buffer);<br><span class="hljs-comment">// 通道中可能无法放入缓冲区中的所有数据</span><br><span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>    <span class="hljs-comment">// 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span><br>    socket.<span class="hljs-built_in">configureBlocking</span>(<span class="hljs-literal">false</span>);<br>    socket.<span class="hljs-built_in">register</span>(selector, SelectionKey.OP_WRITE, buffer);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>添加写事件的相关操作<code>key.isWritable()</code>，对Buffer再次进行写操作</p><ul><li>每次写后需要判断Buffer中是否还有数据（是否写完）。<strong>若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注</strong></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino">SocketChannel socket = (SocketChannel) key.<span class="hljs-built_in">channel</span>();<br><span class="hljs-comment">// 获得buffer</span><br>ByteBuffer buffer = (ByteBuffer) key.<span class="hljs-built_in">attachment</span>();<br><span class="hljs-comment">// 执行写操作</span><br><span class="hljs-type">int</span> write = socket.<span class="hljs-built_in">write</span>(buffer);<br>System.out.<span class="hljs-built_in">println</span>(write);<br><span class="hljs-comment">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span><br><span class="hljs-keyword">if</span> (!buffer.<span class="hljs-built_in">hasRemaining</span>()) &#123;<br>    key.<span class="hljs-built_in">attach</span>(null);<br>    key.<span class="hljs-built_in">interestOps</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>整体代码如下</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> WriteServer &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        <span class="hljs-keyword">try</span>(ServerSocketChannel server = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServerSocketChannel</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>) &#123;<br>            server.bind(<span class="hljs-keyword">new</span> <span class="hljs-constructor">InetSocketAddress(8080)</span>);<br>            server.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>            Selector selector = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Selector</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-literal">()</span>;<br>            server.register(selector, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                selector.select<span class="hljs-literal">()</span>;<br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selected<span class="hljs-constructor">Keys()</span>;<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator<span class="hljs-literal">()</span>;<br>                <span class="hljs-keyword">while</span> (iterator.has<span class="hljs-constructor">Next()</span>) &#123;<br>                    SelectionKey key = iterator.next<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">// 处理后就移除事件</span><br>                    iterator.remove<span class="hljs-literal">()</span>;<br>                    <span class="hljs-keyword">if</span> (key.is<span class="hljs-constructor">Acceptable()</span>) &#123;<br>                        <span class="hljs-comment">// 获得客户端的通道</span><br>                        SocketChannel socket = server.accept<span class="hljs-literal">()</span>;<br>                        <span class="hljs-comment">// 写入数据</span><br>                        StringBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500000000</span>; i++) &#123;<br>                            builder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                        &#125;<br>                        ByteBuffer buffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardCharsets</span>.</span><span class="hljs-module"><span class="hljs-identifier">UTF_8</span>.</span></span>encode(builder.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>                        <span class="hljs-comment">// 先执行一次Buffer-&gt;Channel的写入，如果未写完，就添加一个可写事件</span><br>                        <span class="hljs-built_in">int</span> write = socket.write(buffer);<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(write);<br>                        <span class="hljs-comment">// 通道中可能无法放入缓冲区中的所有数据</span><br>                        <span class="hljs-keyword">if</span> (buffer.has<span class="hljs-constructor">Remaining()</span>) &#123;<br>                            <span class="hljs-comment">// 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span><br>                            socket.configure<span class="hljs-constructor">Blocking(<span class="hljs-params">false</span>)</span>;<br>                            socket.register(selector, SelectionKey.OP_WRITE, buffer);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.is<span class="hljs-constructor">Writable()</span>) &#123;<br>                        SocketChannel socket = (SocketChannel) key.channel<span class="hljs-literal">()</span>;<br>                        <span class="hljs-comment">// 获得buffer</span><br>                        ByteBuffer buffer = (ByteBuffer) key.attachment<span class="hljs-literal">()</span>;<br>                        <span class="hljs-comment">// 执行写操作</span><br>                        <span class="hljs-built_in">int</span> write = socket.write(buffer);<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(write);<br>                        <span class="hljs-comment">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span><br>                        <span class="hljs-keyword">if</span> (!buffer.has<span class="hljs-constructor">Remaining()</span>) &#123;<br>                            key.attach(null);<br>                            key.interest<span class="hljs-constructor">Ops(0)</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; catch (IOException e) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7、优化"><a href="#7、优化" class="headerlink" title="7、优化"></a>7、优化</h2><h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><p>充分利用多核CPU，分两组选择器</p><ul><li>单线程配一个选择器（Boss），<strong>专门处理 accept 事件</strong></li><li>创建 cpu 核心数的线程（Worker），<strong>每个线程配一个选择器，轮流处理 read 事件</strong></li></ul><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li><p>创建<strong>一个</strong>负责处理Accept事件的Boss线程，与<strong>多个</strong>负责处理Read事件的Worker线程</p></li><li><p><strong>Boss线程</strong>执行的操作</p><ul><li><p>接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要<strong>根据标识robin去判断将任务分配给哪个Worker</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 创建固定数量的Worker</span><br>Worker[] workers = <span class="hljs-keyword">new</span> <span class="hljs-type">Worker</span>[<span class="hljs-number">4</span>];<br><span class="hljs-comment">// 用于负载均衡的原子整数</span><br>AtomicInteger robin = <span class="hljs-keyword">new</span> <span class="hljs-type">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 负载均衡，轮询分配Worker</span><br>workers[robin.getAndIncrement()% workers.length].register(socket);<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>register(SocketChannel socket)方法会<strong>通过同步队列完成Boss线程与Worker线程之间的通信</strong>，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketChannel socket)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 只启动一次</span><br>    <span class="hljs-keyword">if</span> (!started) &#123;<br>       <span class="hljs-comment">// 初始化操作</span><br>    &#125;<br>    <span class="hljs-comment">// 向同步队列中添加SocketChannel的注册事件</span><br>    <span class="hljs-comment">// 在Worker线程中执行注册事件</span><br>    queue.add(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.register(selector, SelectionKey.OP_READ);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 唤醒被阻塞的Selector</span><br>    <span class="hljs-comment">// select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark</span><br>    selector.wakeup();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Worker线程执行</strong>的操作<ul><li><strong>从同步队列中获取注册任务，并处理Read事件</strong></li></ul></li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadsServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> ServerSocketChannel.open()) &#123;<br>            <span class="hljs-comment">// 当前线程为Boss线程</span><br>            Thread.currentThread().setName(<span class="hljs-string">&quot;Boss&quot;</span>);<br>            server.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>            <span class="hljs-comment">// 负责轮询Accept事件的Selector</span><br>            <span class="hljs-type">Selector</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> Selector.open();<br>            server.configureBlocking(<span class="hljs-literal">false</span>);<br>            server.register(boss, SelectionKey.OP_ACCEPT);<br>            <span class="hljs-comment">// 创建固定数量的Worker</span><br>            Worker[] workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>[<span class="hljs-number">4</span>];<br>            <span class="hljs-comment">// 用于负载均衡的原子整数</span><br>            <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">robin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; workers.length; i++) &#123;<br>                workers[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;worker-&quot;</span>+i);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                boss.select();<br>                Set&lt;SelectionKey&gt; selectionKeys = boss.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                    iterator.remove();<br>                    <span class="hljs-comment">// BossSelector负责Accept事件</span><br>                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                        <span class="hljs-comment">// 建立连接</span><br>                        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();<br>                        System.out.println(<span class="hljs-string">&quot;connected...&quot;</span>);<br>                        socket.configureBlocking(<span class="hljs-literal">false</span>);<br>                        <span class="hljs-comment">// socket注册到Worker的Selector中</span><br>                        System.out.println(<span class="hljs-string">&quot;before read...&quot;</span>);<br>                        <span class="hljs-comment">// 负载均衡，轮询分配Worker</span><br>                        workers[robin.getAndIncrement()% workers.length].register(socket);<br>                        System.out.println(<span class="hljs-string">&quot;after read...&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> Thread thread;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Selector selector;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 同步队列，用于Boss线程与Worker线程之间的通信</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketChannel socket)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-comment">// 只启动一次</span><br>            <span class="hljs-keyword">if</span> (!started) &#123;<br>                thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>, name);<br>                selector = Selector.open();<br>                queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>                thread.start();<br>                started = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 向同步队列中添加SocketChannel的注册事件</span><br>            <span class="hljs-comment">// 在Worker线程中执行注册事件</span><br>            queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        socket.register(selector, SelectionKey.OP_READ);<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">// 唤醒被阻塞的Selector</span><br>            <span class="hljs-comment">// select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark</span><br>            selector.wakeup();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    selector.select();<br>                    <span class="hljs-comment">// 通过同步队列获得任务并运行</span><br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> queue.poll();<br>                    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">// 获得任务，执行注册操作</span><br>                        task.run();<br>                    &#125;<br>                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                    <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>                        iterator.remove();<br>                        <span class="hljs-comment">// Worker只负责Read事件</span><br>                        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                            <span class="hljs-comment">// 简化处理，省略细节</span><br>                            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>                            socket.read(buffer);<br>                            buffer.flip();<br>                            ByteBufferUtil.debugAll(buffer);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、NIO与BIO"><a href="#四、NIO与BIO" class="headerlink" title="四、NIO与BIO"></a>四、NIO与BIO</h1><h2 id="1、Stream与Channel"><a href="#1、Stream与Channel" class="headerlink" title="1、Stream与Channel"></a>1、Stream与Channel</h2><ul><li><p>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</p></li><li><p>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></p></li><li><p>二者</p><p>均为全双工</p><p>，即读写可以同时进行</p><ul><li>虽然Stream是单向流动的，但是它也是全双工的</li></ul></li></ul><h2 id="2、IO模型"><a href="#2、IO模型" class="headerlink" title="2、IO模型"></a>2、IO模型</h2><ul><li><p>同步</p><p>：线程自己去获取结果（一个线程）</p><ul><li>例如：线程调用一个方法后，需要等待方法返回结果</li></ul></li><li><p>异步</p><p>：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）</p><ul><li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li></ul></li></ul><p>当调用一次 channel.<strong>read</strong> 或 stream.<strong>read</strong> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p><ul><li><p>等待数据阶段</p></li><li><p>复制数据阶段</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png" alt="img"></a></p></li></ul><p>根据UNIX 网络编程 - 卷 I，IO模型主要有以下几种</p><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png" alt="img"></a></p><ul><li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li></ul><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png" alt="img"></a></p><ul><li><p>用户线程</p><p>在一个循环中一直调用read方法</p><p>，若内核空间中还没有数据可读，立即返回</p><ul><li><strong>只是在等待阶段非阻塞</strong></li></ul></li><li><p>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</p></li></ul><h3 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png" alt="img"></a></p><p><strong>Java中通过Selector实现多路复用</strong></p><ul><li>当没有事件是，调用select方法会被阻塞住</li><li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li></ul><p><strong>多路复用与阻塞IO的区别</strong></p><ul><li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li><li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li></ul><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png" alt="img"></a></p><ul><li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li><li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li></ul><h2 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a>3、零拷贝</h2><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h3><p>传统的 IO 将一个文件通过 socket 写出</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">File</span> f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>);<br>RandomAccessFile <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-keyword">file</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)f.length()];<br><span class="hljs-keyword">file</span>.<span class="hljs-keyword">read</span>(buf);<br><br>Socket socket = ...;<br>socket.getOutputStream().<span class="hljs-keyword">write</span>(buf);<br></code></pre></td></tr></table></figure><p><strong>内部工作流如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png" alt="img"></a></p><ul><li><p>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</p><p><code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></p></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</p></li><li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></p></li><li><p>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p></li></ul><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h3 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h3><p>通过 <strong>DirectByteBuf</strong> </p><ul><li><p>ByteBuffer.allocate(10)  </p><ul><li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li></ul></li><li><p>ByteBuffer.</p><p>allocateDirect</p><p>(10)  </p><ul><li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png" alt="img"></a></p><p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p><ul><li>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列<ul><li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存 </li><li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li></ul></li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></li></ul><h3 id="进一步优化1"><a href="#进一步优化1" class="headerlink" title="进一步优化1"></a>进一步优化1</h3><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p><p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo&#x2F;transferFrom</strong> 方法拷贝数据</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p>这种方法下</p><ul><li>只发生了1次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><h3 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a>进一步优化2</h3><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p><h2 id="4、AIO"><a href="#4、AIO" class="headerlink" title="4、AIO"></a>4、AIO</h2><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li><li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
